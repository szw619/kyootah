{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"source/CNAME","path":"CNAME","modified":1,"renderable":0},{"_id":"source/favicon.ico","path":"favicon.ico","modified":1,"renderable":0},{"_id":"source/img/article/tag.png","path":"img/article/tag.png","modified":1,"renderable":0},{"_id":"source/img/header_img/about.jpg","path":"img/header_img/about.jpg","modified":1,"renderable":0},{"_id":"themes/huweihuang/source/fonts/glyphicons-halflings-regular.eot","path":"fonts/glyphicons-halflings-regular.eot","modified":1,"renderable":1},{"_id":"themes/huweihuang/source/fonts/glyphicons-halflings-regular.ttf","path":"fonts/glyphicons-halflings-regular.ttf","modified":1,"renderable":1},{"_id":"themes/huweihuang/source/fonts/glyphicons-halflings-regular.woff","path":"fonts/glyphicons-halflings-regular.woff","modified":1,"renderable":1},{"_id":"themes/huweihuang/source/fonts/glyphicons-halflings-regular.woff2","path":"fonts/glyphicons-halflings-regular.woff2","modified":1,"renderable":1},{"_id":"themes/huweihuang/source/js/bootstrap.min.js","path":"js/bootstrap.min.js","modified":1,"renderable":1},{"_id":"themes/huweihuang/source/js/hux-blog.js","path":"js/hux-blog.js","modified":1,"renderable":1},{"_id":"themes/huweihuang/source/js/hux-blog.min.js","path":"js/hux-blog.min.js","modified":1,"renderable":1},{"_id":"themes/huweihuang/source/js/jquery.nav.js","path":"js/jquery.nav.js","modified":1,"renderable":1},{"_id":"themes/huweihuang/source/js/jquery.tagcloud.js","path":"js/jquery.tagcloud.js","modified":1,"renderable":1},{"_id":"themes/huweihuang/source/js/toc.js","path":"js/toc.js","modified":1,"renderable":1},{"_id":"themes/huweihuang/source/js/totop.js","path":"js/totop.js","modified":1,"renderable":1},{"_id":"themes/huweihuang/source/css/archive.styl","path":"css/archive.styl","modified":1,"renderable":1},{"_id":"themes/huweihuang/source/css/beantech.css","path":"css/beantech.css","modified":1,"renderable":1},{"_id":"themes/huweihuang/source/css/beantech.min.css","path":"css/beantech.min.css","modified":1,"renderable":1},{"_id":"themes/huweihuang/source/css/donate.css","path":"css/donate.css","modified":1,"renderable":1},{"_id":"themes/huweihuang/source/css/highlight.styl","path":"css/highlight.styl","modified":1,"renderable":1},{"_id":"themes/huweihuang/source/css/hux-blog.min.css","path":"css/hux-blog.min.css","modified":1,"renderable":1},{"_id":"themes/huweihuang/source/css/rocket.styl","path":"css/rocket.styl","modified":1,"renderable":1},{"_id":"themes/huweihuang/source/css/toc.styl","path":"css/toc.styl","modified":1,"renderable":1},{"_id":"themes/huweihuang/source/css/signature.styl","path":"css/signature.styl","modified":1,"renderable":1},{"_id":"themes/huweihuang/source/css/widget.styl","path":"css/widget.styl","modified":1,"renderable":1},{"_id":"source/img/article_header/article_bg3.jpg","path":"img/article_header/article_bg3.jpg","modified":1,"renderable":0},{"_id":"source/img/header_img/about3.jpg","path":"img/header_img/about3.jpg","modified":1,"renderable":0},{"_id":"source/img/header_img/archive1.jpg","path":"img/header_img/archive1.jpg","modified":1,"renderable":0},{"_id":"source/img/avatar/avatar.jpg","path":"img/avatar/avatar.jpg","modified":1,"renderable":0},{"_id":"themes/huweihuang/source/fonts/glyphicons-halflings-regular.svg","path":"fonts/glyphicons-halflings-regular.svg","modified":1,"renderable":1},{"_id":"themes/huweihuang/source/js/bootstrap.js","path":"js/bootstrap.js","modified":1,"renderable":1},{"_id":"themes/huweihuang/source/js/jquery.min.js","path":"js/jquery.min.js","modified":1,"renderable":1},{"_id":"themes/huweihuang/source/css/bootstrap.min.css","path":"css/bootstrap.min.css","modified":1,"renderable":1},{"_id":"source/img/header_img/archives-widget.jpg","path":"img/header_img/archives-widget.jpg","modified":1,"renderable":0},{"_id":"source/img/signature/BeanTechSign-white.png","path":"img/signature/BeanTechSign-white.png","modified":1,"renderable":0},{"_id":"themes/huweihuang/source/css/bootstrap.css","path":"css/bootstrap.css","modified":1,"renderable":1},{"_id":"themes/huweihuang/source/css/images/ironman.png","path":"css/images/ironman.png","modified":1,"renderable":1},{"_id":"themes/huweihuang/source/css/images/rocket.png","path":"css/images/rocket.png","modified":1,"renderable":1},{"_id":"source/img/header_img/archive.jpg","path":"img/header_img/archive.jpg","modified":1,"renderable":0},{"_id":"source/img/signature/BeanTechSign-black.png","path":"img/signature/BeanTechSign-black.png","modified":1,"renderable":0},{"_id":"themes/huweihuang/source/js/jquery.js","path":"js/jquery.js","modified":1,"renderable":1},{"_id":"source/img/article_header/article_bg.jpg","path":"img/article_header/article_bg.jpg","modified":1,"renderable":0},{"_id":"source/img/avatar/ironman.png","path":"img/avatar/ironman.png","modified":1,"renderable":0},{"_id":"source/img/article/huweihuang_blog.png","path":"img/article/huweihuang_blog.png","modified":1,"renderable":0},{"_id":"source/img/article_header/article_bg4.jpg","path":"img/article_header/article_bg4.jpg","modified":1,"renderable":0},{"_id":"source/img/header_img/home.jpg","path":"img/header_img/home.jpg","modified":1,"renderable":0},{"_id":"source/img/header_img/tag.png","path":"img/header_img/tag.png","modified":1,"renderable":0},{"_id":"source/img/article_header/article_header.png","path":"img/article_header/article_header.png","modified":1,"renderable":0},{"_id":"source/img/header_img/home-bg-o.png","path":"img/header_img/home-bg-o.png","modified":1,"renderable":0},{"_id":"source/img/header_img/home2.png","path":"img/header_img/home2.png","modified":1,"renderable":0},{"_id":"source/img/header_img/404.png","path":"img/header_img/404.png","modified":1,"renderable":0}],"Cache":[{"_id":"source/404.md","hash":"06c09628020ce1ae5e2917d6aa079c98a241d73f","modified":1619141164801},{"_id":"source/CNAME","hash":"ba3fba224d4bcb9fa4f74531817d57e580bffb1c","modified":1619161928215},{"_id":"themes/huweihuang/LICENSE","hash":"2b209f06bebeb2a8c2b7e187e436f3e1e1fbc8a7","modified":1616068545000},{"_id":"themes/huweihuang/_config.yml","hash":"bec07302dc2c6ab7d3b5e516a673e3ef1c73a2bc","modified":1619141049069},{"_id":"source/favicon.ico","hash":"ca2a4e7d041fa0a86b38a29ea6d2328d41e2da4e","modified":1590040172113},{"_id":"source/_posts/ES2020可选链式操作符.md","hash":"3d3d9a4a1e3c47f16d9d041afbce34e208637760","modified":1646988068572},{"_id":"source/_posts/BFC理解与应用.md","hash":"8a8893eb17101ade7a032e5c79022c0ce6a4bd4a","modified":1646876870556},{"_id":"source/_posts/div横向排版的几种方式.md","hash":"d781768d4187fdddf07f46bbb06033ce63f253c7","modified":1644828117310},{"_id":"source/_posts/ElementUI弹窗默认z-index层问题.md","hash":"3ea0d9db3276a1a105e3b63ed68c024751f522fc","modified":1644828117287},{"_id":"source/_posts/事件循环机制.md","hash":"e9713ead4defaf5e9ee497c9966cc8d44e0b5b7d","modified":1646815180045},{"_id":"source/_posts/js深拷贝的应用与封装.md","hash":"9b8bda3d4b2b478318f122048e45f6604bb7757f","modified":1650476968105},{"_id":"source/_posts/封装一个uniapp列表拖拽排序组件.md","hash":"84b1edd287077b0b8b445974d6b6fccc0fdffc39","modified":1650470869756},{"_id":"source/_posts/从URL输入到页面展现到底发生什么？.md","hash":"d926a9889f544aa7d5b260d8046777dccdc9ab24","modified":1646295838411},{"_id":"source/_posts/在scroll-view中使用sticky.md","hash":"7f7474744ed5ef76e8f4a1ee67706fa2c7a866d6","modified":1620466504767},{"_id":"source/_posts/小程序原生组件页面层级问题.md","hash":"d6f6260ff2daf02f527424960750bf57ecc08dab","modified":1627375585883},{"_id":"source/_posts/微信小程序后台播放音频.md","hash":"bafe77afd6af0e3bf512fbddc978a3e1169a5884","modified":1620284459492},{"_id":"source/_posts/弹性布局flex详解.md","hash":"a9fd96c6bd5bcfbd49b4ff97bcb21b2e3b09b9e1","modified":1644828117248},{"_id":"source/_posts/浏览器缓存.md","hash":"a224f551238ea2ce7ab5ee9a4074e264c2eb1ec4","modified":1644657211937},{"_id":"source/_posts/理解JS中的new及其工作.md","hash":"77374d97d3f924d6ccd090e595ce14bc5b88d2b8","modified":1645059963010},{"_id":"source/about/index.md","hash":"5445f225cbf08929d19d06d783e9231cf977590e","modified":1644571306341},{"_id":"source/_posts/计算机基础知识-什么是http？.md","hash":"ea792a935718d30127335d99580fa0da364bd56a","modified":1644828117244},{"_id":"source/_posts/重排(reflow)和重绘(repaint).md","hash":"70971fdaff1b99ae8f004347e500b238825e7158","modified":1646298999052},{"_id":"source/archive/index.md","hash":"47a9501d3a291bf7aa454a397b7f4138d3f4affc","modified":1644571033600},{"_id":"source/tags/index.md","hash":"61e00a7d2151f528a7c5744594b48b105ae5b20b","modified":1644826219636},{"_id":"themes/huweihuang/layout/404.ejs","hash":"40de38bd399f6f4aef0d6c63c7b13b02d74f1c56","modified":1616068545000},{"_id":"themes/huweihuang/layout/about.ejs","hash":"edcf8fa3bf7093c974d418ffef42ac89c19af128","modified":1616068545000},{"_id":"themes/huweihuang/layout/archive.ejs","hash":"c15726ab348cbf75291b88ffe5e5e50335b5cb0b","modified":1616068545000},{"_id":"themes/huweihuang/layout/index.ejs","hash":"9e682d5d19cce88ffcae6bbcd0d644df64a6d735","modified":1616068545000},{"_id":"themes/huweihuang/layout/keynote.ejs","hash":"f5689862281e34dbe8402b0e72f632902e53e88b","modified":1616068545000},{"_id":"themes/huweihuang/layout/layout.ejs","hash":"6efee96baaeb079b0abb2642c8d64edf01946a2e","modified":1619162231963},{"_id":"themes/huweihuang/layout/post.ejs","hash":"cad30f3be80a7f0c98bfee58c1de5a527a25e9fa","modified":1619143563148},{"_id":"themes/huweihuang/layout/tags.ejs","hash":"2c72eb2e89130658aa068d80d27b561b509c5dcd","modified":1616068545000},{"_id":"themes/huweihuang/layout/page.ejs","hash":"5e588f200a7b7cd3ae40402b0dd3b779aac6787f","modified":1616068545000},{"_id":"themes/huweihuang/languages_to_be_added/de.yml","hash":"424a9c1e6ab69334d7873f6574da02ca960aa572","modified":1616068545000},{"_id":"themes/huweihuang/languages_to_be_added/default.yml","hash":"97326c9e6518d9f379778178b3b8f9a58434725d","modified":1616068545000},{"_id":"themes/huweihuang/languages_to_be_added/en.yml","hash":"97326c9e6518d9f379778178b3b8f9a58434725d","modified":1616068545000},{"_id":"themes/huweihuang/languages_to_be_added/no.yml","hash":"8ca475a3b4f8efe6603030f0013aae39668230e1","modified":1616068545000},{"_id":"themes/huweihuang/languages_to_be_added/pl.yml","hash":"de7eb5850ae65ba7638e907c805fea90617a988c","modified":1616068545000},{"_id":"themes/huweihuang/languages_to_be_added/es.yml","hash":"cb4eeca0ed3768a77e0cd216300f2b2549628b1b","modified":1616068545000},{"_id":"themes/huweihuang/languages_to_be_added/ru.yml","hash":"42df7afeb7a35dc46d272b7f4fb880a9d9ebcaa5","modified":1616068545000},{"_id":"themes/huweihuang/languages_to_be_added/zh-CN.yml","hash":"7bfcb0b8e97d7e5edcfca8ab26d55d9da2573c1c","modified":1616068545000},{"_id":"themes/huweihuang/languages_to_be_added/zh-TW.yml","hash":"9acac6cc4f8002c3fa53ff69fb8cf66c915bd016","modified":1616068545000},{"_id":"source/img/article/tag.png","hash":"c8632d64d9471009098b84f70273e63037a4e7b8","modified":1616068545000},{"_id":"source/img/header_img/about.jpg","hash":"30c7c4843b74afd972407b6797cf04c54a6ad2f4","modified":1593590301270},{"_id":"themes/huweihuang/layout/_partial/head.ejs","hash":"f057d6140035de0c7dd841511615d8cbdb531f1b","modified":1619142557326},{"_id":"themes/huweihuang/layout/_partial/footer.ejs","hash":"d9f657b9ccf17006a3b66d51cee6ee587ba473ec","modified":1631240713189},{"_id":"themes/huweihuang/layout/_partial/header.ejs","hash":"3bd09df76e0622d76d186b020393fcab361e6c97","modified":1616068545000},{"_id":"themes/huweihuang/layout/_partial/nav.ejs","hash":"4c905166c960852e9b9a3c9d5c680091e37b481f","modified":1616068545000},{"_id":"themes/huweihuang/layout/_partial/pagination.ejs","hash":"557d6bb069a1d48af49ae912994653f44b32a570","modified":1616068545000},{"_id":"themes/huweihuang/layout/_partial/sidebar.ejs","hash":"2e4e528a555917b2a267da4db2440bcc4a7a65ab","modified":1616068545000},{"_id":"themes/huweihuang/layout/_partial/toc.ejs","hash":"65232e4840ff4ab95cb9d33d299dad8ac9160046","modified":1644378042508},{"_id":"themes/huweihuang/layout/_widget/archive.ejs","hash":"7594929d472806ca4c64d9906d9903a96de111a0","modified":1616068545000},{"_id":"themes/huweihuang/layout/_widget/category.ejs","hash":"1cf485def07dc06e870dc9613767c6c614bcf428","modified":1616068545000},{"_id":"themes/huweihuang/layout/_widget/featured-tags.ejs","hash":"0c9ce1942f1943dc8891a9302a922ef1ffe300c5","modified":1616068545000},{"_id":"themes/huweihuang/layout/_widget/friends-blog.ejs","hash":"734d3775017aedac185028924baf890a71a74548","modified":1616068545000},{"_id":"themes/huweihuang/layout/_widget/recent-posts.ejs","hash":"e08ab8ba60e31638006acf27f066b989a0a3c433","modified":1616068545000},{"_id":"themes/huweihuang/layout/_widget/short-about.ejs","hash":"315de02246f07c747c32495e107ad7b19cb3ff54","modified":1616068545000},{"_id":"themes/huweihuang/source/fonts/glyphicons-halflings-regular.eot","hash":"86b6f62b7853e67d3e635f6512a5a5efc58ea3c3","modified":1616068545000},{"_id":"themes/huweihuang/source/fonts/glyphicons-halflings-regular.ttf","hash":"44bc1850f570972267b169ae18f1cb06b611ffa2","modified":1616068545000},{"_id":"themes/huweihuang/source/fonts/glyphicons-halflings-regular.woff","hash":"278e49a86e634da6f2a02f3b47dd9d2a8f26210f","modified":1616068545000},{"_id":"themes/huweihuang/source/fonts/glyphicons-halflings-regular.woff2","hash":"ca35b697d99cae4d1b60f2d60fcd37771987eb07","modified":1616068545000},{"_id":"themes/huweihuang/source/js/bootstrap.min.js","hash":"b3f2ef9f985e7906c9360756b73cd64bf7733647","modified":1616068545000},{"_id":"themes/huweihuang/source/js/hux-blog.js","hash":"4b4d3c557405d04c3087d36c13e2834fe05c0f73","modified":1616068545000},{"_id":"themes/huweihuang/source/js/hux-blog.min.js","hash":"1563e7f70550ac6b30803d6f449719b853200e35","modified":1616068545000},{"_id":"themes/huweihuang/source/js/jquery.nav.js","hash":"ef2160a456176a4d09cc0b95d52b27dfbbadf2d8","modified":1616068545000},{"_id":"themes/huweihuang/source/js/jquery.tagcloud.js","hash":"4e5fd0b07f3bd935f2e603710447e039e3677211","modified":1616068545000},{"_id":"themes/huweihuang/source/js/toc.js","hash":"6df6fb0a39ce2586b406dabf53e3a3e9681c5a54","modified":1619186364367},{"_id":"themes/huweihuang/source/js/totop.js","hash":"c05360f6fc699ac12e794b1764b4a952713a3017","modified":1616068545000},{"_id":"themes/huweihuang/source/css/archive.styl","hash":"715bcbd085eb95ec26c9805c11c374919cde971c","modified":1616068545000},{"_id":"themes/huweihuang/source/css/beantech.css","hash":"6b0f3ca09c19cd0ec0ee80fca2a33b958dc5cc72","modified":1644826567466},{"_id":"themes/huweihuang/source/css/beantech.min.css","hash":"05a06230b1a9eca0b30cece54a397008cb77dc50","modified":1616068545000},{"_id":"themes/huweihuang/source/css/donate.css","hash":"f65ac8363d8d215adb896158e7b45165db259a47","modified":1616068545000},{"_id":"themes/huweihuang/source/css/highlight.styl","hash":"e842080e6d580f0f70a7df71fbde3c4e49463c19","modified":1616068545000},{"_id":"themes/huweihuang/source/css/hux-blog.min.css","hash":"1baef04de262aeb7023d835429b49a805ac4ab40","modified":1616068545000},{"_id":"themes/huweihuang/source/css/rocket.styl","hash":"ede0821bc5b8e02ff87349bd9bf2bc822a537a67","modified":1618585644877},{"_id":"themes/huweihuang/source/css/toc.styl","hash":"631e97f634d30f53314e2fec8bdde267c1c49f4c","modified":1616068545000},{"_id":"themes/huweihuang/source/css/signature.styl","hash":"88159b31c59d59c01a0b534af57242662a2a3969","modified":1616068545000},{"_id":"themes/huweihuang/source/css/widget.styl","hash":"7a9f735f5ef323dc2950fbd9d76daa16c9a0f1a9","modified":1616068545000},{"_id":"source/img/article_header/article_bg3.jpg","hash":"41b318cfc7f8c1e0a4a0dd18859976c8f46c4f00","modified":1590175012129},{"_id":"source/img/header_img/about3.jpg","hash":"fcde77730a40808a22e9dc61b0453a2a10c5b1c8","modified":1590175040361},{"_id":"source/img/header_img/archive1.jpg","hash":"dd5a6b397a19772bcc37eda7d8b7c22848b606b9","modified":1640267848189},{"_id":"source/img/avatar/avatar.jpg","hash":"eab80038a5ebb0d736e730a126bd547c00e8cf71","modified":1590036907106},{"_id":"themes/huweihuang/source/fonts/glyphicons-halflings-regular.svg","hash":"de51a8494180a6db074af2dee2383f0a363c5b08","modified":1616068545000},{"_id":"themes/huweihuang/source/js/bootstrap.js","hash":"f8752e9ae24daec0a0baffd7819122f8c6fd9103","modified":1616068545000},{"_id":"themes/huweihuang/source/js/jquery.min.js","hash":"41b4bfbaa96be6d1440db6e78004ade1c134e276","modified":1616068545000},{"_id":"themes/huweihuang/source/css/bootstrap.min.css","hash":"fec7b176a4b9a67c0eb5d184f57b84297efc23aa","modified":1616068545000},{"_id":"source/img/header_img/archives-widget.jpg","hash":"68f7d525269a94287e0ad18713ae232fb59dcf71","modified":1616068545000},{"_id":"source/img/signature/BeanTechSign-white.png","hash":"34289ed41cf9ddac2d56be46fbb1515b7d5913cd","modified":1616068545000},{"_id":"themes/huweihuang/source/css/bootstrap.css","hash":"53e6ff9a1b3eebdef21499576f155922a291a94b","modified":1618585575717},{"_id":"themes/huweihuang/source/css/images/ironman.png","hash":"2f0db0ab15d466c4065d9f6102fdf829726d9e3f","modified":1616068545000},{"_id":"themes/huweihuang/source/css/images/rocket.png","hash":"6dee0406955aa9b7a261161d30f2538a671e806b","modified":1616068545000},{"_id":"source/img/header_img/archive.jpg","hash":"990f6f9dd0ecb5348bfcc47305553d58c0d8f326","modified":1616068545000},{"_id":"source/img/signature/BeanTechSign-black.png","hash":"94b7102e819fd6ee082d3fb0166f4de7458c22ff","modified":1616068545000},{"_id":"themes/huweihuang/source/js/jquery.js","hash":"1852661bd11a09ca9b9cb63d1aa6ff390fffaf4e","modified":1616068545000},{"_id":"source/img/article_header/article_bg.jpg","hash":"6af63305c923899017e727b5ca968a2703bc08cf","modified":1616068545000},{"_id":"source/img/avatar/ironman.png","hash":"7d6a06b4b544ab146c3b3e8474edc33f14ac6e4d","modified":1616068545000},{"_id":"source/img/article/huweihuang_blog.png","hash":"392cf8b33be6c752dd908e027fa3346a6ecd58ab","modified":1616068545000},{"_id":"source/img/article_header/article_bg4.jpg","hash":"bbe665cdd63c6dfea670749d3642aad2dd03f6c1","modified":1590175076131},{"_id":"source/img/header_img/home.jpg","hash":"8f1c440427a4aa86b623503a926c027e2e10cd66","modified":1616068545000},{"_id":"source/img/header_img/tag.png","hash":"e83cd7b04ff85bcbc9bd3ebf5e57a55166e82568","modified":1616068545000},{"_id":"source/img/article_header/article_header.png","hash":"d9fa12f1e40924a0db57761d09d52dce450b4f7b","modified":1616068545000},{"_id":"source/img/header_img/home-bg-o.png","hash":"134ece4cb4c49c7ca1403a5afe7f46d0e2f9ecbb","modified":1616068545000},{"_id":"source/img/header_img/home2.png","hash":"da6a3d5ca787bdc25e69655abd879b4f821aeb30","modified":1616068545000},{"_id":"source/img/header_img/404.png","hash":"6bf9c224543ec54e250309db89cbdf46e0c4b5ba","modified":1616068545000},{"_id":"public/post-sitemap.xml","hash":"9a1e385de71910247a48a123544b14268621e690","modified":1650477156780},{"_id":"public/page-sitemap.xml","hash":"dc3eb00b21b7853f1a6fe938f7a6183141d73f7a","modified":1650477156781},{"_id":"public/category-sitemap.xml","hash":"8bf1b441e603b35b691e08d4fd7fc638bf371ed3","modified":1650477156781},{"_id":"public/sitemap.xml","hash":"7f94ecfa638b63e9f3e98dc0c3f7144be4f9020d","modified":1650477156781},{"_id":"public/sitemap.xsl","hash":"4321fa69dc1b8811d32b7a1478e5603e038cea1a","modified":1650477156781},{"_id":"public/tag-sitemap.xml","hash":"ff2094e034c19d98438de733c038d709e45b71ce","modified":1650477156929},{"_id":"public/404.html","hash":"e1cfebe57714bc5dd1286c537eb5586837a86fa2","modified":1650477157661},{"_id":"public/tags/index.html","hash":"25505980a10207d742ead510b80cd3b8e5102bc2","modified":1650477157661},{"_id":"public/article/事件循环机制/index.html","hash":"84ad2627f01c7893115c5292f1131922a0e9c62c","modified":1650477157661},{"_id":"public/article/js深拷贝的应用与封装/index.html","hash":"2fd580f1f107ed59b5cf2e037bc49a082eb97a16","modified":1650477157661},{"_id":"public/article/浏览器缓存/index.html","hash":"be8d4bf4d770c75dbab3f0d811b291520a3d8b2e","modified":1650477157661},{"_id":"public/article/BFC理解与应用/index.html","hash":"c4f38913741bda9c3a78bfcf67cb5c7a4f6e2ec0","modified":1650477157661},{"_id":"public/article/ES2020可选链式操作符/index.html","hash":"9f339d03172708be4676ebf4d957fe957e964d89","modified":1650477157661},{"_id":"public/微信小程序/封装一个uniapp列表拖拽排序组件/index.html","hash":"3884ea1e38c019a515a322f038469fec0983f5b2","modified":1650477157661},{"_id":"public/article/重排(reflow)和重绘(repaint)/index.html","hash":"441d795a08dcb8bd40cbab7af23466ec791c6543","modified":1650477157661},{"_id":"public/article/计算机基础知识-什么是http？/index.html","hash":"1bb0f02d8c7b8dde41f3e0f25d368046cc86d126","modified":1650477157661},{"_id":"public/article/从URL输入到页面展现到底发生什么？/index.html","hash":"b3f7bc3c4ff83cdf36a658cc25c1d14e7b627336","modified":1650477157661},{"_id":"public/微信小程序/微信小程序后台播放音频/index.html","hash":"d31cb22b22e540b2099904581d67c6f5d2f41893","modified":1650477157661},{"_id":"public/微信小程序/在scroll-view中使用sticky/index.html","hash":"71a6166f597816abc04cad8607e5f51566ef5399","modified":1650477157662},{"_id":"public/article/ElementUI弹窗默认z-index层问题/index.html","hash":"dc99a7907cdc0e0005eabfef733e1ae588747b7b","modified":1650477157662},{"_id":"public/article/理解JS中的new及其工作/index.html","hash":"9b8912595a4309b1b49b82762833948a4ffc9128","modified":1650477157662},{"_id":"public/css/弹性布局flex详解/index.html","hash":"a2224d61882472005128935aa9faf66e16bd0c01","modified":1650477157662},{"_id":"public/css/div横向排版的几种方式/index.html","hash":"3acb94142a645053836e4906ff19429db75d9a1f","modified":1650477157662},{"_id":"public/微信小程序/小程序原生组件页面层级问题/index.html","hash":"bb563f43de2ae2fa63ab67665c254c8e3e2e8b6f","modified":1650477157662},{"_id":"public/about/index.html","hash":"1d6b30111c834357f541c793d58183026a83ad4e","modified":1650477157662},{"_id":"public/archive/index.html","hash":"f704f19bf58324f1354e8b236ccc770e300022cc","modified":1650477157662},{"_id":"public/archives/index.html","hash":"b19d7653a41011ed2ce16e94ca698dd574248503","modified":1650477157662},{"_id":"public/archives/archives/2/index.html","hash":"28caf4918a29384dca05c8e4ecc64c5cc1f1d69c","modified":1650477157662},{"_id":"public/archives/2020/index.html","hash":"877d8d3af3cce5a687b3f01f573b519534dd2031","modified":1650477157662},{"_id":"public/archives/2020/03/index.html","hash":"ed7834676e799e565931f3a7006fc08cd8c4d7bb","modified":1650477157662},{"_id":"public/archives/2020/04/index.html","hash":"d150635686f0f4e83aa5f6490e6129a71e3c3f56","modified":1650477157662},{"_id":"public/archives/2020/05/index.html","hash":"5fd03bf3379944513b9f75b0bb9f46055f5b841f","modified":1650477157662},{"_id":"public/archives/2020/06/index.html","hash":"bac39333467a665012c5cf9e10b0c68b1605f386","modified":1650477157662},{"_id":"public/archives/2020/07/index.html","hash":"a929bb7dcb2beef2734041ced0cf3958d8196049","modified":1650477157662},{"_id":"public/archives/2020/10/index.html","hash":"6a23cafdaa5534371e67fb713fec3c0492167b2f","modified":1650477157662},{"_id":"public/archives/2020/11/index.html","hash":"413bf2aac2d26f8e2127c7a7aeafb41e12bb2666","modified":1650477157662},{"_id":"public/archives/2021/index.html","hash":"2f9a4178bd3551d42bb28360da9cd4f9063cf45b","modified":1650477157662},{"_id":"public/archives/2021/04/index.html","hash":"b4e3b638bfe2572b42dd61eed52c38efebf10bdf","modified":1650477157663},{"_id":"public/archives/2021/05/index.html","hash":"4004db6fa2a91f8024452354c3b627c1b4e2c9ff","modified":1650477157663},{"_id":"public/archives/2021/08/index.html","hash":"e7a824ac7538ff9ec7786776706ef0456133a195","modified":1650477157663},{"_id":"public/archives/2021/09/index.html","hash":"ab50e65cb7b763e8dd358d95fc72092f534fc78d","modified":1650477157663},{"_id":"public/index.html","hash":"16a1626578cf3d4b47b97a89588f54016b8f7273","modified":1650477157663},{"_id":"public/archives/2021/10/index.html","hash":"0b447132fedc1417f506768355674ac76e60be52","modified":1650477157663},{"_id":"public/archives/2021/12/index.html","hash":"bfd20e8416907ac3b888ffb7c85ec460afe3363c","modified":1650477157663},{"_id":"public/page/2/index.html","hash":"74d19866a337f5c42220d5a28e036f9b83143f24","modified":1650477157663},{"_id":"public/categories/css/index.html","hash":"88779f038b425018be0d090b48907039c8d8c3d4","modified":1650477157663},{"_id":"public/categories/微信小程序/index.html","hash":"f495cbaccba9192d40ed8c450d6fec320864820c","modified":1650477157663},{"_id":"public/tags/工作中遇到的问题/index.html","hash":"7f1f69b83b3b3e3b3ee7664e4d6c18ef1cc5e0e0","modified":1650477157663},{"_id":"public/tags/js基础/index.html","hash":"53163ee6a3a3849872a6671b9d3a9e43cc5cf5ca","modified":1650477157663},{"_id":"public/tags/css/index.html","hash":"920860ea53e374f3f95932297fc0a5cb4b3fb543","modified":1650477157663},{"_id":"public/tags/BFC/index.html","hash":"6634e29f48f92773db1aec1d89ff77bfbcd47973","modified":1650477157663},{"_id":"public/tags/边距重合/index.html","hash":"49649af59fa5a3357ac53d02582097a1953cdebf","modified":1650477157663},{"_id":"public/tags/边距塌陷/index.html","hash":"410c89c5c30ea38477d6e4a9c383670e87a2af17","modified":1650477157663},{"_id":"public/tags/JavaScript深入/index.html","hash":"aff59d23f930b5969fd58802c286051d32b057d7","modified":1650477157663},{"_id":"public/tags/事件循环/index.html","hash":"77438acfee814be5ef7db12d9d913880c9e8f8c8","modified":1650477157663},{"_id":"public/tags/js进阶/index.html","hash":"3033d608df7e27f53312aa8205567bf496a16af5","modified":1650477157664},{"_id":"public/tags/深拷贝/index.html","hash":"ee803d289b518fb10387b93d5c76b24c3156af55","modified":1650477157664},{"_id":"public/tags/拖拽排序/index.html","hash":"30d0e5173234443c445130b19eaf6cf8b24a0d63","modified":1650477157664},{"_id":"public/tags/uniapp/index.html","hash":"5c6e80faf946a4e1d9c4a72531e882b54dd018a1","modified":1650477157664},{"_id":"public/tags/前端基础/index.html","hash":"0acf12432e9322d7f13f2fa5a64d1917e26d1b54","modified":1650477157664},{"_id":"public/tags/浏览器基础/index.html","hash":"24e36bef8b6566980d1e588a57c826022f035f73","modified":1650477157664},{"_id":"public/tags/flex弹性布局/index.html","hash":"ef8f53dfa10108eb62987eb712b37e2c017b5657","modified":1650477157664},{"_id":"public/tags/网络基础/index.html","hash":"1eaac289918a849ba0f2300865db491dcdef081d","modified":1650477157664},{"_id":"public/tags/浏览器缓存/index.html","hash":"669f7c142f1c039dd267ac058f4d037669a0e702","modified":1650477157664},{"_id":"public/tags/http/index.html","hash":"8f9fc6d5d1485d188915c04ac45faa0bdf44b9f6","modified":1650477157664},{"_id":"public/tags/JS基础/index.html","hash":"6abbbd6c713bc00352263f06cfc4cc3cae5accab","modified":1650477157664},{"_id":"public/tags/渲染队列/index.html","hash":"9b474cd6d96e0f5b02ffef53f5079754a037c619","modified":1650477157664},{"_id":"public/tags/回流重绘/index.html","hash":"ebb9cf73bc0a5009923a91c5dbcaec99ba0deaa4","modified":1650477157664},{"_id":"public/tags/前端进阶/index.html","hash":"a040f2a7fdf87e39c4fa845bf6cbcae806493ccf","modified":1650477157664},{"_id":"public/tags/项目优化/index.html","hash":"ca1db116e6d657f4a79590436085ccf614671ac6","modified":1650477157664},{"_id":"public/CNAME","hash":"ba3fba224d4bcb9fa4f74531817d57e580bffb1c","modified":1650477157664},{"_id":"public/img/header_img/about.jpg","hash":"30c7c4843b74afd972407b6797cf04c54a6ad2f4","modified":1650477157664},{"_id":"public/img/article/tag.png","hash":"c8632d64d9471009098b84f70273e63037a4e7b8","modified":1650477157665},{"_id":"public/fonts/glyphicons-halflings-regular.eot","hash":"86b6f62b7853e67d3e635f6512a5a5efc58ea3c3","modified":1650477157665},{"_id":"public/fonts/glyphicons-halflings-regular.ttf","hash":"44bc1850f570972267b169ae18f1cb06b611ffa2","modified":1650477157665},{"_id":"public/fonts/glyphicons-halflings-regular.woff","hash":"278e49a86e634da6f2a02f3b47dd9d2a8f26210f","modified":1650477157665},{"_id":"public/fonts/glyphicons-halflings-regular.woff2","hash":"ca35b697d99cae4d1b60f2d60fcd37771987eb07","modified":1650477157665},{"_id":"public/css/images/ironman.png","hash":"2f0db0ab15d466c4065d9f6102fdf829726d9e3f","modified":1650477157665},{"_id":"public/css/images/rocket.png","hash":"6dee0406955aa9b7a261161d30f2538a671e806b","modified":1650477157665},{"_id":"public/favicon.ico","hash":"ca2a4e7d041fa0a86b38a29ea6d2328d41e2da4e","modified":1650477157953},{"_id":"public/img/article_header/article_bg3.jpg","hash":"41b318cfc7f8c1e0a4a0dd18859976c8f46c4f00","modified":1650477157953},{"_id":"public/img/avatar/avatar.jpg","hash":"eab80038a5ebb0d736e730a126bd547c00e8cf71","modified":1650477157955},{"_id":"public/fonts/glyphicons-halflings-regular.svg","hash":"de51a8494180a6db074af2dee2383f0a363c5b08","modified":1650477157955},{"_id":"public/img/header_img/archive1.jpg","hash":"dd5a6b397a19772bcc37eda7d8b7c22848b606b9","modified":1650477157955},{"_id":"public/img/header_img/about3.jpg","hash":"fcde77730a40808a22e9dc61b0453a2a10c5b1c8","modified":1650477157955},{"_id":"public/js/hux-blog.js","hash":"4b4d3c557405d04c3087d36c13e2834fe05c0f73","modified":1650477157962},{"_id":"public/js/hux-blog.min.js","hash":"1563e7f70550ac6b30803d6f449719b853200e35","modified":1650477157962},{"_id":"public/js/jquery.tagcloud.js","hash":"4e5fd0b07f3bd935f2e603710447e039e3677211","modified":1650477157962},{"_id":"public/js/totop.js","hash":"c05360f6fc699ac12e794b1764b4a952713a3017","modified":1650477157962},{"_id":"public/css/archive.css","hash":"8db895ebaeff19ac145c961abcfd5d4a8d67a8ea","modified":1650477157962},{"_id":"public/js/jquery.nav.js","hash":"ef2160a456176a4d09cc0b95d52b27dfbbadf2d8","modified":1650477157962},{"_id":"public/js/toc.js","hash":"6df6fb0a39ce2586b406dabf53e3a3e9681c5a54","modified":1650477157962},{"_id":"public/css/donate.css","hash":"f65ac8363d8d215adb896158e7b45165db259a47","modified":1650477157962},{"_id":"public/css/highlight.css","hash":"c58b4569c086e477a00dcbf5a95a166fe5fecfb0","modified":1650477157962},{"_id":"public/css/rocket.css","hash":"ff363acbf4d07259228a37738221033665b28794","modified":1650477157962},{"_id":"public/css/signature.css","hash":"820fa4743cea34a61808cd8f7de528605c32d7e3","modified":1650477157962},{"_id":"public/css/toc.css","hash":"f756b9e1b2208d2e5b0f3d2ac5e4fea3b7da0e10","modified":1650477157962},{"_id":"public/css/widget.css","hash":"da95ad3f1938f24d20f1fa77d7a38f0c392b5ec8","modified":1650477157962},{"_id":"public/js/bootstrap.min.js","hash":"b3f2ef9f985e7906c9360756b73cd64bf7733647","modified":1650477157962},{"_id":"public/css/beantech.css","hash":"6b0f3ca09c19cd0ec0ee80fca2a33b958dc5cc72","modified":1650477157962},{"_id":"public/css/beantech.min.css","hash":"05a06230b1a9eca0b30cece54a397008cb77dc50","modified":1650477157962},{"_id":"public/css/hux-blog.min.css","hash":"1baef04de262aeb7023d835429b49a805ac4ab40","modified":1650477157962},{"_id":"public/js/bootstrap.js","hash":"f8752e9ae24daec0a0baffd7819122f8c6fd9103","modified":1650477157963},{"_id":"public/js/jquery.min.js","hash":"41b4bfbaa96be6d1440db6e78004ade1c134e276","modified":1650477157963},{"_id":"public/css/bootstrap.min.css","hash":"fec7b176a4b9a67c0eb5d184f57b84297efc23aa","modified":1650477157963},{"_id":"public/css/bootstrap.css","hash":"53e6ff9a1b3eebdef21499576f155922a291a94b","modified":1650477157963},{"_id":"public/js/jquery.js","hash":"1852661bd11a09ca9b9cb63d1aa6ff390fffaf4e","modified":1650477157963},{"_id":"public/img/header_img/archives-widget.jpg","hash":"68f7d525269a94287e0ad18713ae232fb59dcf71","modified":1650477157963},{"_id":"public/img/header_img/archive.jpg","hash":"990f6f9dd0ecb5348bfcc47305553d58c0d8f326","modified":1650477157963},{"_id":"public/img/signature/BeanTechSign-white.png","hash":"34289ed41cf9ddac2d56be46fbb1515b7d5913cd","modified":1650477157969},{"_id":"public/img/signature/BeanTechSign-black.png","hash":"94b7102e819fd6ee082d3fb0166f4de7458c22ff","modified":1650477157977},{"_id":"public/img/article_header/article_bg.jpg","hash":"6af63305c923899017e727b5ca968a2703bc08cf","modified":1650477157977},{"_id":"public/img/avatar/ironman.png","hash":"7d6a06b4b544ab146c3b3e8474edc33f14ac6e4d","modified":1650477157995},{"_id":"public/img/article_header/article_bg4.jpg","hash":"bbe665cdd63c6dfea670749d3642aad2dd03f6c1","modified":1650477158014},{"_id":"public/img/article/huweihuang_blog.png","hash":"392cf8b33be6c752dd908e027fa3346a6ecd58ab","modified":1650477158033},{"_id":"public/img/header_img/home.jpg","hash":"8f1c440427a4aa86b623503a926c027e2e10cd66","modified":1650477158039},{"_id":"public/img/header_img/tag.png","hash":"e83cd7b04ff85bcbc9bd3ebf5e57a55166e82568","modified":1650477158048},{"_id":"public/img/article_header/article_header.png","hash":"d9fa12f1e40924a0db57761d09d52dce450b4f7b","modified":1650477158051},{"_id":"public/img/header_img/home-bg-o.png","hash":"134ece4cb4c49c7ca1403a5afe7f46d0e2f9ecbb","modified":1650477158054},{"_id":"public/img/header_img/home2.png","hash":"da6a3d5ca787bdc25e69655abd879b4f821aeb30","modified":1650477158054},{"_id":"public/img/header_img/404.png","hash":"6bf9c224543ec54e250309db89cbdf46e0c4b5ba","modified":1650477158060}],"Category":[{"name":"css","_id":"cl27vhg5d0008u8q5vixblpzh"},{"name":"微信小程序","_id":"cl27vhg5n000ju8q5oh39jo5p"}],"Data":[],"Page":[{"layout":"404","description":"这里空空如也，看看网址有没有问题~","header-img":"/img/header_img/404.png","_content":"","source":"404.md","raw":"---\nlayout: 404\ndescription: \"这里空空如也，看看网址有没有问题~\"\nheader-img: \"/img/header_img/404.png\"\n---\n","date":"2021-04-23T01:26:04.801Z","updated":"2021-04-23T01:26:04.801Z","path":"404.html","title":"","comments":1,"_id":"cl27vhg4e0000u8q51kba152n","content":"","site":{"data":{}},"excerpt":"","more":""},{"layout":"about","title":"About","date":"2018-10-03T02:48:33.000Z","description":"","header-img":"/img/header_img/about3.jpg","aplayer":true,"fixed":false,"_content":" \n### 关于我\n\n>一个做前端的\n>喜欢敲代码\n>喜欢徒步\n>喜欢思考（有时候想太多）\n>热爱音乐\n\n  \n### 联系我\n\n>Email: kyootah@foxmail.com\n\n\n\n\n\n#### 来听听歌 Aimer粉~\n","source":"about/index.md","raw":"---\nlayout: \"about\"\ntitle: \"About\"\ndate: 2018-10-03 10:48:33\ndescription: \"\"\nheader-img: \"/img/header_img/about3.jpg\"\naplayer: true\nfixed: false\n---\n \n### 关于我\n\n>一个做前端的\n>喜欢敲代码\n>喜欢徒步\n>喜欢思考（有时候想太多）\n>热爱音乐\n\n  \n### 联系我\n\n>Email: kyootah@foxmail.com\n\n\n\n\n\n#### 来听听歌 Aimer粉~\n","updated":"2022-02-11T09:21:46.341Z","path":"about/index.html","comments":1,"_id":"cl27vhg540002u8q5sjkzpu9v","content":"<h3 id=\"关于我\">关于我</h3>\n<blockquote>\n<p>一个做前端的<br>\n喜欢敲代码<br>\n喜欢徒步<br>\n喜欢思考（有时候想太多）<br>\n热爱音乐</p>\n</blockquote>\n<h3 id=\"联系我\">联系我</h3>\n<blockquote>\n<p>Email: <a href=\"mailto:kyootah@foxmail.com\" target=\"_blank\" rel=\"noopener\">kyootah@foxmail.com</a></p>\n</blockquote>\n<h4 id=\"来听听歌-aimer粉~\">来听听歌 Aimer粉~</h4>\n","site":{"data":{}},"excerpt":"","more":"<h3>关于我</h3>\n<blockquote>\n<p>一个做前端的<br>\n喜欢敲代码<br>\n喜欢徒步<br>\n喜欢思考（有时候想太多）<br>\n热爱音乐</p>\n</blockquote>\n<h3>联系我</h3>\n<blockquote>\n<p>Email: <a href=\"mailto:kyootah@foxmail.com\" target=\"_blank\" rel=\"noopener\">kyootah@foxmail.com</a></p>\n</blockquote>\n<h4>来听听歌 Aimer粉~</h4>\n"},{"layout":"archive","title":"Archives","header-img":"/img/header_img/archive1.jpg","comments":0,"date":"2018-09-20T12:49:56.000Z","description":"Hey, this is archives","_content":"","source":"archive/index.md","raw":"---\nlayout: \"archive\"\ntitle: \"Archives\"\nheader-img: \"/img/header_img/archive1.jpg\"\ncomments: false\ndate: 2018-09-20 20:49:56\ndescription: \"Hey, this is archives\"\n---\n","updated":"2022-02-11T09:17:13.600Z","path":"archive/index.html","_id":"cl27vhg570004u8q5r6gaff34","content":"","site":{"data":{}},"excerpt":"","more":""},{"layout":"tags","title":"Tags","description":"Hey, this is Tags.","header-img":"/img/article_header/article_bg3.jpg","_content":"","source":"tags/index.md","raw":"---\nlayout: \"tags\"\ntitle: \"Tags\"\ndescription: \"Hey, this is Tags.\"\nheader-img: \"/img/article_header/article_bg3.jpg\"\n---\n","date":"2022-02-14T08:10:19.636Z","updated":"2022-02-14T08:10:19.636Z","path":"tags/index.html","comments":1,"_id":"cl27vhg5c0007u8q5g88cuy9t","content":"","site":{"data":{}},"excerpt":"","more":""}],"Post":[{"title":"可选链式操作符(?.)","catalog":true,"date":"2021-09-22T14:14:40.000Z","subtitle":null,"header-img":null,"_content":"\n## 定意\n> 可选链式操作符(?.)允许读取位于连接对象链深处的属性值, 而不必明确验证链中的每个引用是否有效。\n\n通俗点讲：该操作符跟.链式操作符类似, 不同之处在于引用为null或者undefined的情况下不会引起报错, 不存在返回值是undefined.\n\n## 作用\n 在查询具有多个层级的对象时、不再需要进行冗余的前置校验、\n\n## 链式操作符(.)\n我们平时开发时要取对象中的某一个属性时用到,但遇到对象是null或undefined时就会报错。\n为了避免报错，我们需要对对象进行一个非空判断，当对象有很多层嵌套时，就会产生大量类似繁琐的校验步骤。\n```js\nconst obj = null\nlet status1 =  obj && obj.info && obj.info.isCheck;\nconsole.log(status1) //null\n\nlet status2 = obj.info.isCheck;\nconsole.log(status2) //error \n \n```\n我们会发现，如果不先确认对象非null，就会出现报错，判断了又多写很多校验代码。\n于是有了** 可选链式操作符(?.)**\n\n## 可选链式操作符(?.)\n\n我们来试下通过可选链式操作符(?.)简化上面繁琐的校验步骤。\n```js\nconst obj = null\nlet status=obj?.info?.isCheck;\nconsole.log(status) // null;\n```\n\n是不是简洁很多了。\n结果是：若该obj或者obj.info为null/undefined, 则会直接返回undefined;\n\n\n","source":"_posts/ES2020可选链式操作符.md","raw":"---\ntitle: 可选链式操作符(?.)\ncatalog: true\ndate: 2021-09-22 22:14:40\nsubtitle:\nheader-img:\ntags:\n- 工作中遇到的问题\n- js基础\n---\n\n## 定意\n> 可选链式操作符(?.)允许读取位于连接对象链深处的属性值, 而不必明确验证链中的每个引用是否有效。\n\n通俗点讲：该操作符跟.链式操作符类似, 不同之处在于引用为null或者undefined的情况下不会引起报错, 不存在返回值是undefined.\n\n## 作用\n 在查询具有多个层级的对象时、不再需要进行冗余的前置校验、\n\n## 链式操作符(.)\n我们平时开发时要取对象中的某一个属性时用到,但遇到对象是null或undefined时就会报错。\n为了避免报错，我们需要对对象进行一个非空判断，当对象有很多层嵌套时，就会产生大量类似繁琐的校验步骤。\n```js\nconst obj = null\nlet status1 =  obj && obj.info && obj.info.isCheck;\nconsole.log(status1) //null\n\nlet status2 = obj.info.isCheck;\nconsole.log(status2) //error \n \n```\n我们会发现，如果不先确认对象非null，就会出现报错，判断了又多写很多校验代码。\n于是有了** 可选链式操作符(?.)**\n\n## 可选链式操作符(?.)\n\n我们来试下通过可选链式操作符(?.)简化上面繁琐的校验步骤。\n```js\nconst obj = null\nlet status=obj?.info?.isCheck;\nconsole.log(status) // null;\n```\n\n是不是简洁很多了。\n结果是：若该obj或者obj.info为null/undefined, 则会直接返回undefined;\n\n\n","slug":"ES2020可选链式操作符","published":1,"updated":"2022-03-11T08:41:08.572Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl27vhg510001u8q5uztrs37v","content":"<h2 id=\"定意\">定意</h2>\n<blockquote>\n<p>可选链式操作符(?.)允许读取位于连接对象链深处的属性值, 而不必明确验证链中的每个引用是否有效。</p>\n</blockquote>\n<p>通俗点讲：该操作符跟.链式操作符类似, 不同之处在于引用为null或者undefined的情况下不会引起报错, 不存在返回值是undefined.</p>\n<h2 id=\"作用\">作用</h2>\n<p>在查询具有多个层级的对象时、不再需要进行冗余的前置校验、</p>\n<h2 id=\"链式操作符\">链式操作符(.)</h2>\n<p>我们平时开发时要取对象中的某一个属性时用到,但遇到对象是null或undefined时就会报错。<br>\n为了避免报错，我们需要对对象进行一个非空判断，当对象有很多层嵌套时，就会产生大量类似繁琐的校验步骤。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> obj = <span class=\"literal\">null</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> status1 =  obj &amp;&amp; obj.info &amp;&amp; obj.info.isCheck;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(status1) <span class=\"comment\">//null</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> status2 = obj.info.isCheck;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(status2) <span class=\"comment\">//error</span></span><br></pre></td></tr></table></figure>\n<p>我们会发现，如果不先确认对象非null，就会出现报错，判断了又多写很多校验代码。<br>\n于是有了** 可选链式操作符(?.)**</p>\n<h2 id=\"可选链式操作符\">可选链式操作符(?.)</h2>\n<p>我们来试下通过可选链式操作符(?.)简化上面繁琐的校验步骤。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> obj = <span class=\"literal\">null</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> status=obj?.info?.isCheck;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(status) <span class=\"comment\">// null;</span></span><br></pre></td></tr></table></figure>\n<p>是不是简洁很多了。<br>\n结果是：若该obj或者obj.info为null/undefined, 则会直接返回undefined;</p>\n","site":{"data":{}},"excerpt":"","more":"<h2>定意</h2>\n<blockquote>\n<p>可选链式操作符(?.)允许读取位于连接对象链深处的属性值, 而不必明确验证链中的每个引用是否有效。</p>\n</blockquote>\n<p>通俗点讲：该操作符跟.链式操作符类似, 不同之处在于引用为null或者undefined的情况下不会引起报错, 不存在返回值是undefined.</p>\n<h2>作用</h2>\n<p>在查询具有多个层级的对象时、不再需要进行冗余的前置校验、</p>\n<h2>链式操作符(.)</h2>\n<p>我们平时开发时要取对象中的某一个属性时用到,但遇到对象是null或undefined时就会报错。<br>\n为了避免报错，我们需要对对象进行一个非空判断，当对象有很多层嵌套时，就会产生大量类似繁琐的校验步骤。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> obj = <span class=\"literal\">null</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> status1 =  obj &amp;&amp; obj.info &amp;&amp; obj.info.isCheck;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(status1) <span class=\"comment\">//null</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> status2 = obj.info.isCheck;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(status2) <span class=\"comment\">//error</span></span><br></pre></td></tr></table></figure>\n<p>我们会发现，如果不先确认对象非null，就会出现报错，判断了又多写很多校验代码。<br>\n于是有了** 可选链式操作符(?.)**</p>\n<h2>可选链式操作符(?.)</h2>\n<p>我们来试下通过可选链式操作符(?.)简化上面繁琐的校验步骤。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> obj = <span class=\"literal\">null</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> status=obj?.info?.isCheck;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(status) <span class=\"comment\">// null;</span></span><br></pre></td></tr></table></figure>\n<p>是不是简洁很多了。<br>\n结果是：若该obj或者obj.info为null/undefined, 则会直接返回undefined;</p>\n"},{"title":"div横向排版的几种方式","catalog":true,"toc_nav_num":true,"date":"2020-04-12T13:30:45.000Z","toc":true,"_content":"\ndiv盒子本身默认样式属性是独占一行，平时将各个内容横向排版是最常见的操作，记录总结一下div的几种横向排列方法~\n\n<!--more-->\n\n以下面代码为例，列举下横向div排列的方法\n\n```\n<div class=\"wrap\">\n    <div class=\"item div1\">div1</div>\n    <div class=\"item div2\">div2</div>\n    <div class=\"item div3\">div3</div>\n</div>\n\n<style>\n.wrap{\n  width:500px;\n  background:#f0f0f0;\n}\n.wrap .item{\n  width:100px;\n  height:100px;\n  background:#ccc;\n  text-align:center;\n  line-height:100px;\n  margin:10px;\n}\n</style>\n```\n![image](http://img.kyootah.com/2021/04/07/e52a3bb76424c.png)\n\n## 一、浮动\n\n```css\n.div1{\n    float:left;\n}\n.div2{\n    float:left;\n}\n.div3{\n    float:right;\n}\n```\n效果：\n![image](http://img.kyootah.com/2021/04/07/5dc5bf37973d5.png)\n\nfloat 的特点：\n* 左右浮动同时用时，顺序就会出现颠倒\n* 不会撑开，可以看到wrap的背景颜色没了，height变成0\n* 字会环绕在浮动元素周围\n\n\n## 二、inline-block 行块标签\n\n```css\n.div1, .div2, .div3{\n    display: inline-block;\n}\n```\n![image](http://img.kyootah.com/2021/04/07/eeafe59460bbe.png)\ninline-block存在的小问题：\n\n1. 用了display:inline-block后，存在间隙问题，间隙为4像素，这个问题产生的原因是换行引起的，因为我们写标签时通常会在标签结束符后顺手打个回车，而回车会产生回车符，回车符相当于空白符，通常情况下，多个连续的空白符会合并成一个空白符，而产生“空白间隙”的真正原因就是这个让我们并不怎么注意的空白符。\n  \n2. 去除空隙的方法:对父元素添加，{font-size:0}，即将字体大小设为0，那么那个空白符也变成0px，从而消除空隙\n \n\n ## 三、flex 弹性盒子\n\n```css\n.wrap{\n    display:flex;\n}\n```\n![image](http://img.kyootah.com/2021/04/10/446ba728945a7.png)\n\n 可以通过 `justify-content` 属性调整子元素的水平对齐方式：\n\n* `flex-start`\t默认值。项目位于容器的开头。\t\n* `flex-end`\t项目位于容器的结尾。\t \n* `center`\t项目位于容器的中心。\t \n* `space-between`\t项目位于各行之间留有空白的容器内。\t \n* `space-around`\t项目位于各行之前、之间、之后都留有空白的容器内。\t \n* `initial`\t设置该属性为它的默认值。请参阅 initial。 \n* `inherit`\t从父元素继承该属性\n","source":"_posts/div横向排版的几种方式.md","raw":"---\ntitle: div横向排版的几种方式\ncatalog: true\ntoc_nav_num: true\ndate: 2020-04-12 21:30:45\ncategories:\n- css\ntags:\n- css\ntoc: true\n---\n\ndiv盒子本身默认样式属性是独占一行，平时将各个内容横向排版是最常见的操作，记录总结一下div的几种横向排列方法~\n\n<!--more-->\n\n以下面代码为例，列举下横向div排列的方法\n\n```\n<div class=\"wrap\">\n    <div class=\"item div1\">div1</div>\n    <div class=\"item div2\">div2</div>\n    <div class=\"item div3\">div3</div>\n</div>\n\n<style>\n.wrap{\n  width:500px;\n  background:#f0f0f0;\n}\n.wrap .item{\n  width:100px;\n  height:100px;\n  background:#ccc;\n  text-align:center;\n  line-height:100px;\n  margin:10px;\n}\n</style>\n```\n![image](http://img.kyootah.com/2021/04/07/e52a3bb76424c.png)\n\n## 一、浮动\n\n```css\n.div1{\n    float:left;\n}\n.div2{\n    float:left;\n}\n.div3{\n    float:right;\n}\n```\n效果：\n![image](http://img.kyootah.com/2021/04/07/5dc5bf37973d5.png)\n\nfloat 的特点：\n* 左右浮动同时用时，顺序就会出现颠倒\n* 不会撑开，可以看到wrap的背景颜色没了，height变成0\n* 字会环绕在浮动元素周围\n\n\n## 二、inline-block 行块标签\n\n```css\n.div1, .div2, .div3{\n    display: inline-block;\n}\n```\n![image](http://img.kyootah.com/2021/04/07/eeafe59460bbe.png)\ninline-block存在的小问题：\n\n1. 用了display:inline-block后，存在间隙问题，间隙为4像素，这个问题产生的原因是换行引起的，因为我们写标签时通常会在标签结束符后顺手打个回车，而回车会产生回车符，回车符相当于空白符，通常情况下，多个连续的空白符会合并成一个空白符，而产生“空白间隙”的真正原因就是这个让我们并不怎么注意的空白符。\n  \n2. 去除空隙的方法:对父元素添加，{font-size:0}，即将字体大小设为0，那么那个空白符也变成0px，从而消除空隙\n \n\n ## 三、flex 弹性盒子\n\n```css\n.wrap{\n    display:flex;\n}\n```\n![image](http://img.kyootah.com/2021/04/10/446ba728945a7.png)\n\n 可以通过 `justify-content` 属性调整子元素的水平对齐方式：\n\n* `flex-start`\t默认值。项目位于容器的开头。\t\n* `flex-end`\t项目位于容器的结尾。\t \n* `center`\t项目位于容器的中心。\t \n* `space-between`\t项目位于各行之间留有空白的容器内。\t \n* `space-around`\t项目位于各行之前、之间、之后都留有空白的容器内。\t \n* `initial`\t设置该属性为它的默认值。请参阅 initial。 \n* `inherit`\t从父元素继承该属性\n","slug":"div横向排版的几种方式","published":1,"updated":"2022-02-14T08:41:57.310Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl27vhg550003u8q559ywynem","content":"<p>div盒子本身默认样式属性是独占一行，平时将各个内容横向排版是最常见的操作，记录总结一下div的几种横向排列方法~</p>\n<a id=\"more\"></a>\n<p>以下面代码为例，列举下横向div排列的方法</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;div class=&quot;wrap&quot;&gt;</span><br><span class=\"line\">    &lt;div class=&quot;item div1&quot;&gt;div1&lt;/div&gt;</span><br><span class=\"line\">    &lt;div class=&quot;item div2&quot;&gt;div2&lt;/div&gt;</span><br><span class=\"line\">    &lt;div class=&quot;item div3&quot;&gt;div3&lt;/div&gt;</span><br><span class=\"line\">&lt;/div&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;style&gt;</span><br><span class=\"line\">.wrap&#123;</span><br><span class=\"line\">  width:500px;</span><br><span class=\"line\">  background:#f0f0f0;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">.wrap .item&#123;</span><br><span class=\"line\">  width:100px;</span><br><span class=\"line\">  height:100px;</span><br><span class=\"line\">  background:#ccc;</span><br><span class=\"line\">  text-align:center;</span><br><span class=\"line\">  line-height:100px;</span><br><span class=\"line\">  margin:10px;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&lt;/style&gt;</span><br></pre></td></tr></table></figure>\n<p><img src=\"http://img.kyootah.com/2021/04/07/e52a3bb76424c.png\" alt=\"image\"></p>\n<h2 id=\"一-浮动\">一、浮动</h2>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.div1</span>&#123;</span><br><span class=\"line\">    <span class=\"attribute\">float</span>:left;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-class\">.div2</span>&#123;</span><br><span class=\"line\">    <span class=\"attribute\">float</span>:left;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-class\">.div3</span>&#123;</span><br><span class=\"line\">    <span class=\"attribute\">float</span>:right;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>效果：<br>\n<img src=\"http://img.kyootah.com/2021/04/07/5dc5bf37973d5.png\" alt=\"image\"></p>\n<p>float 的特点：</p>\n<ul>\n<li>左右浮动同时用时，顺序就会出现颠倒</li>\n<li>不会撑开，可以看到wrap的背景颜色没了，height变成0</li>\n<li>字会环绕在浮动元素周围</li>\n</ul>\n<h2 id=\"二-inline-block-行块标签\">二、inline-block 行块标签</h2>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.div1</span>, <span class=\"selector-class\">.div2</span>, <span class=\"selector-class\">.div3</span>&#123;</span><br><span class=\"line\">    <span class=\"attribute\">display</span>: inline-block;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><img src=\"http://img.kyootah.com/2021/04/07/eeafe59460bbe.png\" alt=\"image\"><br>\ninline-block存在的小问题：</p>\n<ol>\n<li>\n<p>用了display:inline-block后，存在间隙问题，间隙为4像素，这个问题产生的原因是换行引起的，因为我们写标签时通常会在标签结束符后顺手打个回车，而回车会产生回车符，回车符相当于空白符，通常情况下，多个连续的空白符会合并成一个空白符，而产生“空白间隙”的真正原因就是这个让我们并不怎么注意的空白符。</p>\n</li>\n<li>\n<p>去除空隙的方法:对父元素添加，{font-size:0}，即将字体大小设为0，那么那个空白符也变成0px，从而消除空隙</p>\n</li>\n</ol>\n<h2 id=\"三-flex-弹性盒子\">三、flex 弹性盒子</h2>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.wrap</span>&#123;</span><br><span class=\"line\">    <span class=\"attribute\">display</span>:flex;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><img src=\"http://img.kyootah.com/2021/04/10/446ba728945a7.png\" alt=\"image\"></p>\n<p>可以通过 <code>justify-content</code> 属性调整子元素的水平对齐方式：</p>\n<ul>\n<li><code>flex-start</code>\t默认值。项目位于容器的开头。</li>\n<li><code>flex-end</code>\t项目位于容器的结尾。</li>\n<li><code>center</code>\t项目位于容器的中心。</li>\n<li><code>space-between</code>\t项目位于各行之间留有空白的容器内。</li>\n<li><code>space-around</code>\t项目位于各行之前、之间、之后都留有空白的容器内。</li>\n<li><code>initial</code>\t设置该属性为它的默认值。请参阅 initial。</li>\n<li><code>inherit</code>\t从父元素继承该属性</li>\n</ul>\n","site":{"data":{}},"excerpt":"<p>div盒子本身默认样式属性是独占一行，平时将各个内容横向排版是最常见的操作，记录总结一下div的几种横向排列方法~</p>","more":"<p>以下面代码为例，列举下横向div排列的方法</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;div class=&quot;wrap&quot;&gt;</span><br><span class=\"line\">    &lt;div class=&quot;item div1&quot;&gt;div1&lt;/div&gt;</span><br><span class=\"line\">    &lt;div class=&quot;item div2&quot;&gt;div2&lt;/div&gt;</span><br><span class=\"line\">    &lt;div class=&quot;item div3&quot;&gt;div3&lt;/div&gt;</span><br><span class=\"line\">&lt;/div&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;style&gt;</span><br><span class=\"line\">.wrap&#123;</span><br><span class=\"line\">  width:500px;</span><br><span class=\"line\">  background:#f0f0f0;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">.wrap .item&#123;</span><br><span class=\"line\">  width:100px;</span><br><span class=\"line\">  height:100px;</span><br><span class=\"line\">  background:#ccc;</span><br><span class=\"line\">  text-align:center;</span><br><span class=\"line\">  line-height:100px;</span><br><span class=\"line\">  margin:10px;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&lt;/style&gt;</span><br></pre></td></tr></table></figure>\n<p><img src=\"http://img.kyootah.com/2021/04/07/e52a3bb76424c.png\" alt=\"image\"></p>\n<h2>一、浮动</h2>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.div1</span>&#123;</span><br><span class=\"line\">    <span class=\"attribute\">float</span>:left;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-class\">.div2</span>&#123;</span><br><span class=\"line\">    <span class=\"attribute\">float</span>:left;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-class\">.div3</span>&#123;</span><br><span class=\"line\">    <span class=\"attribute\">float</span>:right;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>效果：<br>\n<img src=\"http://img.kyootah.com/2021/04/07/5dc5bf37973d5.png\" alt=\"image\"></p>\n<p>float 的特点：</p>\n<ul>\n<li>左右浮动同时用时，顺序就会出现颠倒</li>\n<li>不会撑开，可以看到wrap的背景颜色没了，height变成0</li>\n<li>字会环绕在浮动元素周围</li>\n</ul>\n<h2>二、inline-block 行块标签</h2>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.div1</span>, <span class=\"selector-class\">.div2</span>, <span class=\"selector-class\">.div3</span>&#123;</span><br><span class=\"line\">    <span class=\"attribute\">display</span>: inline-block;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><img src=\"http://img.kyootah.com/2021/04/07/eeafe59460bbe.png\" alt=\"image\"><br>\ninline-block存在的小问题：</p>\n<ol>\n<li>\n<p>用了display:inline-block后，存在间隙问题，间隙为4像素，这个问题产生的原因是换行引起的，因为我们写标签时通常会在标签结束符后顺手打个回车，而回车会产生回车符，回车符相当于空白符，通常情况下，多个连续的空白符会合并成一个空白符，而产生“空白间隙”的真正原因就是这个让我们并不怎么注意的空白符。</p>\n</li>\n<li>\n<p>去除空隙的方法:对父元素添加，{font-size:0}，即将字体大小设为0，那么那个空白符也变成0px，从而消除空隙</p>\n</li>\n</ol>\n<h2>三、flex 弹性盒子</h2>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.wrap</span>&#123;</span><br><span class=\"line\">    <span class=\"attribute\">display</span>:flex;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><img src=\"http://img.kyootah.com/2021/04/10/446ba728945a7.png\" alt=\"image\"></p>\n<p>可以通过 <code>justify-content</code> 属性调整子元素的水平对齐方式：</p>\n<ul>\n<li><code>flex-start</code>\t默认值。项目位于容器的开头。</li>\n<li><code>flex-end</code>\t项目位于容器的结尾。</li>\n<li><code>center</code>\t项目位于容器的中心。</li>\n<li><code>space-between</code>\t项目位于各行之间留有空白的容器内。</li>\n<li><code>space-around</code>\t项目位于各行之前、之间、之后都留有空白的容器内。</li>\n<li><code>initial</code>\t设置该属性为它的默认值。请参阅 initial。</li>\n<li><code>inherit</code>\t从父元素继承该属性</li>\n</ul>"},{"title":"BFC理解与应用","catalog":true,"date":"2021-09-08T06:21:05.000Z","subtitle":null,"header-img":null,"_content":"\n### 定意\n>在解释`BFC`之前，先说一下文档流。我们常说的文档流其实分为定位流、浮动流和普通流三种。而普通流其实就是指`BFC`中的`FC`。`FC`是`formatting context`的首字母缩写，直译过来是格式化上下文，它是页面中的一块渲染区域，有一套渲染规则，决定了其子元素如何布局，以及和其他元素之间的关系和作用。常见的FC有BFC、IFC，还有GFC和FFC。`BFC`是`block formatting context`，也就是块级格式化上下文，是用于布局块级盒子的一块渲染区域\n\n简单来说`BFC`是一个独立的区域，它内部的元素都依照它的规则渲染，不会与 BFC 外部打交道。\n\n### 如何触发\n* `overflow`:hidden | scroll | auto; （不是visible） \n* `float`:不为none \n* `display`:inline-block | table-cell | table-caption | flex | grid ;（ 非none 非inline 非block） \n* `position`: absolute | fiexed ;（ 非relative） \n可以简单理解成`OFDP`。\n\n### BFC布局规则 \n* 1.浮动的元素会被父级计算高度（父级触发了BFC）\n* 2.非浮动元素不会覆盖浮动元素位置（非浮动元素触发了BFC）\n* 3.margin不会传递给父级（父级触发了BFC）\n* 4.两个相邻元素上下margin会重叠（给其中一个元素增加一个父级，然后让他的父级触发BFC）\n\n### 可以解决什么问题\n\n#### 浮动元素父级高度塌陷问题\n```html\n<div class=\"father\"> \n  <div class=\"child\"></div>\n</div>  \n```\n```css\n.father{\n  width:200px;\n  background:#CCC; \n  border:4px solid #000;\n}\n.child{\n  width:100px;\n  height:100px;\n  float:left;\n  background:red; \n}\n```\n![](http://img.kyootah.com/2022/02/11/3bb61c98b5c8d.png)\n例如这里我们给定一个空间，将空间内的元素浮动，这时候会发现父级的高度并不会被撑开，这种情况就是我们常说的`高度塌陷`。\n我们可以利用`BFC`来解决这个问题，给父级设置一个`overflow:hidden`，触发`BFC`。\n```css\n.father{\n  width:200px;\n  background:#CCC; \n  border:4px solid #000;\n  overflow:hidden;\n}\n.child{\n  width:100px;\n  height:100px;\n  float:left;\n  background:red; \n}\n```\n \n\n\n![](http://img.kyootah.com/2022/02/11/28e96ce1f9180.png)\n这个时候可以看到我们的容器高度被撑开了,遵循BFC布局规则第1条: __计算BFC的高度时，浮动元素也参与计算__\n\n\n\n#### 元素被浮动元素覆盖问题\n```html\n<div class=\"aside\"></div>\n<div class=\"main\"></div>\n```\n```css\n.main{\n  width:200px;\n  height:200px;\n  background:#CCC;   \n}\n.aside{\n  width:100px;\n  height:100px;\n  float:left;\n  background:red; \n}\n```\n ![](http://img.kyootah.com/2022/02/11/2cdfaf30985e6.png)\n 可以看到当`aside`浮动了之后覆盖在了没设置浮动的`main`上。\n __为什么会这样__？因为BFC布局规则规定：__每个元素的margin box的左边，与包含块border box的左边相接触(对于从左往右的格式化，否则相反)。即使存在浮动也是如此__。因此，虽然存在浮动的元素`aside`，但main的左边依然会与包含块的左边相接触。\n__解决方法：利用`BFC`的规则非浮动元素不会覆盖浮动元素位置（非浮动元素触发了BFC）__,给`main`设置`overflow:hidden`。\n__适用场景__： 自适应多栏布局（避免多列布局由于宽度计算四舍五入而自动换行）\n ```css\n .main{\n  width:200px;\n  height:200px;\n  background:#CCC;   \n  overflow:hidden;\n}\n```\n![](http://img.kyootah.com/2022/02/11/d51a57d70ee73.png)\n\n#### margin重合问题\n```html\n<div class=\"father\">\n  <div class=\"child1\"></div>\n  <div class=\"child2\"></div>\n</div>\n```\n\n```css\n.father{\n  width:200px;\n  background:#ccc;\n}\n\n.child1{\n  width:100px;\n  height:100px;\n  background:red;\n  margin-bottom:10px;  \n}\n.child2{\n  width:100px;\n  height:100px;\n  background:red; \n  margin-top:10px; \n}\n```\n![](http://img.kyootah.com/2022/02/11/9c78fdbd677fc.png)\n例如上面两个`child`，分别设置了`margin-bottom`与`margin-top`10px，但实际效果是两个元素的间隔只有 __10px__ ,而非理想的 __20px__\n__解决方法__:给其中某个元素给定一个外层并触发BFC。\n\n```html\n<div class=\"father\">\n  <div class=\"child1\"></div>\n  <div class=\"wrap\">\n    <div class=\"child2\"></div>\n  </div>\n</div>\n```\n```css\n.wrap{\n  overflow: hidden;\n}\n```\n可以看到间距恢复正常了\n![](http://img.kyootah.com/2022/02/11/c1193823448c7.png)\n\n\n\n#### margin塌陷问题\n```html\n<div class=\"father\">\n  <div class=\"child\"></div> \n</div>\n```\n```css\n.father{\n  width:200px;\n  height:200px;\n  background:blue;\n  margin:60px;  \n}\n \n.child{\n  width:100px;\n  height:100px;\n  background:red;\n  margin:50px;  \n}\n```\n![](http://img.kyootah.com/2022/02/11/b599137ffb6bb.png)\n我们给定一个元素`father`并设置`margin:60px`，并在其中放入子元素`child`，设置` margin:50px`，可以看到水平上面的边距生效了，垂直方向没效果,这就是**外边距塌陷**现象\n**什么是margin外边距塌陷？**对于两个嵌套关系（父子关系）的块元素，父元素有上外边距同时子元素也有上外边距，此时父元素会塌陷**较大**的外边距值。\n**解决方法**：让父元素变成`BFC`,在`father`中加入`overflow:hidden;`\n效果：\n![](http://img.kyootah.com/2022/02/11/39a3214151401.png)\n\n ","source":"_posts/BFC理解与应用.md","raw":"---\ntitle: BFC理解与应用\ncatalog: true\ndate: 2021-09-08 14:21:05\nsubtitle:\nheader-img:\ntags:\n- BFC\n- 边距重合\n- 边距塌陷\n- css\n---\n\n### 定意\n>在解释`BFC`之前，先说一下文档流。我们常说的文档流其实分为定位流、浮动流和普通流三种。而普通流其实就是指`BFC`中的`FC`。`FC`是`formatting context`的首字母缩写，直译过来是格式化上下文，它是页面中的一块渲染区域，有一套渲染规则，决定了其子元素如何布局，以及和其他元素之间的关系和作用。常见的FC有BFC、IFC，还有GFC和FFC。`BFC`是`block formatting context`，也就是块级格式化上下文，是用于布局块级盒子的一块渲染区域\n\n简单来说`BFC`是一个独立的区域，它内部的元素都依照它的规则渲染，不会与 BFC 外部打交道。\n\n### 如何触发\n* `overflow`:hidden | scroll | auto; （不是visible） \n* `float`:不为none \n* `display`:inline-block | table-cell | table-caption | flex | grid ;（ 非none 非inline 非block） \n* `position`: absolute | fiexed ;（ 非relative） \n可以简单理解成`OFDP`。\n\n### BFC布局规则 \n* 1.浮动的元素会被父级计算高度（父级触发了BFC）\n* 2.非浮动元素不会覆盖浮动元素位置（非浮动元素触发了BFC）\n* 3.margin不会传递给父级（父级触发了BFC）\n* 4.两个相邻元素上下margin会重叠（给其中一个元素增加一个父级，然后让他的父级触发BFC）\n\n### 可以解决什么问题\n\n#### 浮动元素父级高度塌陷问题\n```html\n<div class=\"father\"> \n  <div class=\"child\"></div>\n</div>  \n```\n```css\n.father{\n  width:200px;\n  background:#CCC; \n  border:4px solid #000;\n}\n.child{\n  width:100px;\n  height:100px;\n  float:left;\n  background:red; \n}\n```\n![](http://img.kyootah.com/2022/02/11/3bb61c98b5c8d.png)\n例如这里我们给定一个空间，将空间内的元素浮动，这时候会发现父级的高度并不会被撑开，这种情况就是我们常说的`高度塌陷`。\n我们可以利用`BFC`来解决这个问题，给父级设置一个`overflow:hidden`，触发`BFC`。\n```css\n.father{\n  width:200px;\n  background:#CCC; \n  border:4px solid #000;\n  overflow:hidden;\n}\n.child{\n  width:100px;\n  height:100px;\n  float:left;\n  background:red; \n}\n```\n \n\n\n![](http://img.kyootah.com/2022/02/11/28e96ce1f9180.png)\n这个时候可以看到我们的容器高度被撑开了,遵循BFC布局规则第1条: __计算BFC的高度时，浮动元素也参与计算__\n\n\n\n#### 元素被浮动元素覆盖问题\n```html\n<div class=\"aside\"></div>\n<div class=\"main\"></div>\n```\n```css\n.main{\n  width:200px;\n  height:200px;\n  background:#CCC;   \n}\n.aside{\n  width:100px;\n  height:100px;\n  float:left;\n  background:red; \n}\n```\n ![](http://img.kyootah.com/2022/02/11/2cdfaf30985e6.png)\n 可以看到当`aside`浮动了之后覆盖在了没设置浮动的`main`上。\n __为什么会这样__？因为BFC布局规则规定：__每个元素的margin box的左边，与包含块border box的左边相接触(对于从左往右的格式化，否则相反)。即使存在浮动也是如此__。因此，虽然存在浮动的元素`aside`，但main的左边依然会与包含块的左边相接触。\n__解决方法：利用`BFC`的规则非浮动元素不会覆盖浮动元素位置（非浮动元素触发了BFC）__,给`main`设置`overflow:hidden`。\n__适用场景__： 自适应多栏布局（避免多列布局由于宽度计算四舍五入而自动换行）\n ```css\n .main{\n  width:200px;\n  height:200px;\n  background:#CCC;   \n  overflow:hidden;\n}\n```\n![](http://img.kyootah.com/2022/02/11/d51a57d70ee73.png)\n\n#### margin重合问题\n```html\n<div class=\"father\">\n  <div class=\"child1\"></div>\n  <div class=\"child2\"></div>\n</div>\n```\n\n```css\n.father{\n  width:200px;\n  background:#ccc;\n}\n\n.child1{\n  width:100px;\n  height:100px;\n  background:red;\n  margin-bottom:10px;  \n}\n.child2{\n  width:100px;\n  height:100px;\n  background:red; \n  margin-top:10px; \n}\n```\n![](http://img.kyootah.com/2022/02/11/9c78fdbd677fc.png)\n例如上面两个`child`，分别设置了`margin-bottom`与`margin-top`10px，但实际效果是两个元素的间隔只有 __10px__ ,而非理想的 __20px__\n__解决方法__:给其中某个元素给定一个外层并触发BFC。\n\n```html\n<div class=\"father\">\n  <div class=\"child1\"></div>\n  <div class=\"wrap\">\n    <div class=\"child2\"></div>\n  </div>\n</div>\n```\n```css\n.wrap{\n  overflow: hidden;\n}\n```\n可以看到间距恢复正常了\n![](http://img.kyootah.com/2022/02/11/c1193823448c7.png)\n\n\n\n#### margin塌陷问题\n```html\n<div class=\"father\">\n  <div class=\"child\"></div> \n</div>\n```\n```css\n.father{\n  width:200px;\n  height:200px;\n  background:blue;\n  margin:60px;  \n}\n \n.child{\n  width:100px;\n  height:100px;\n  background:red;\n  margin:50px;  \n}\n```\n![](http://img.kyootah.com/2022/02/11/b599137ffb6bb.png)\n我们给定一个元素`father`并设置`margin:60px`，并在其中放入子元素`child`，设置` margin:50px`，可以看到水平上面的边距生效了，垂直方向没效果,这就是**外边距塌陷**现象\n**什么是margin外边距塌陷？**对于两个嵌套关系（父子关系）的块元素，父元素有上外边距同时子元素也有上外边距，此时父元素会塌陷**较大**的外边距值。\n**解决方法**：让父元素变成`BFC`,在`father`中加入`overflow:hidden;`\n效果：\n![](http://img.kyootah.com/2022/02/11/39a3214151401.png)\n\n ","slug":"BFC理解与应用","published":1,"updated":"2022-03-10T01:47:50.556Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl27vhg5a0006u8q5povh1sr9","content":"<h3 id=\"定意\">定意</h3>\n<blockquote>\n<p>在解释<code>BFC</code>之前，先说一下文档流。我们常说的文档流其实分为定位流、浮动流和普通流三种。而普通流其实就是指<code>BFC</code>中的<code>FC</code>。<code>FC</code>是<code>formatting context</code>的首字母缩写，直译过来是格式化上下文，它是页面中的一块渲染区域，有一套渲染规则，决定了其子元素如何布局，以及和其他元素之间的关系和作用。常见的FC有BFC、IFC，还有GFC和FFC。<code>BFC</code>是<code>block formatting context</code>，也就是块级格式化上下文，是用于布局块级盒子的一块渲染区域</p>\n</blockquote>\n<p>简单来说<code>BFC</code>是一个独立的区域，它内部的元素都依照它的规则渲染，不会与 BFC 外部打交道。</p>\n<h3 id=\"如何触发\">如何触发</h3>\n<ul>\n<li><code>overflow</code>:hidden | scroll | auto; （不是visible）</li>\n<li><code>float</code>:不为none</li>\n<li><code>display</code>:inline-block | table-cell | table-caption | flex | grid ;（ 非none 非inline 非block）</li>\n<li><code>position</code>: absolute | fiexed ;（ 非relative）<br>\n可以简单理解成<code>OFDP</code>。</li>\n</ul>\n<h3 id=\"bfc布局规则\">BFC布局规则</h3>\n<ul>\n<li>1.浮动的元素会被父级计算高度（父级触发了BFC）</li>\n<li>2.非浮动元素不会覆盖浮动元素位置（非浮动元素触发了BFC）</li>\n<li>3.margin不会传递给父级（父级触发了BFC）</li>\n<li>4.两个相邻元素上下margin会重叠（给其中一个元素增加一个父级，然后让他的父级触发BFC）</li>\n</ul>\n<h3 id=\"可以解决什么问题\">可以解决什么问题</h3>\n<h4 id=\"浮动元素父级高度塌陷问题\">浮动元素父级高度塌陷问题</h4>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"father\"</span>&gt;</span> </span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"child\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.father</span>&#123;</span><br><span class=\"line\">  <span class=\"attribute\">width</span>:<span class=\"number\">200px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">background</span>:<span class=\"number\">#CCC</span>; </span><br><span class=\"line\">  <span class=\"attribute\">border</span>:<span class=\"number\">4px</span> solid <span class=\"number\">#000</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-class\">.child</span>&#123;</span><br><span class=\"line\">  <span class=\"attribute\">width</span>:<span class=\"number\">100px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">height</span>:<span class=\"number\">100px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">float</span>:left;</span><br><span class=\"line\">  <span class=\"attribute\">background</span>:red; </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><img src=\"http://img.kyootah.com/2022/02/11/3bb61c98b5c8d.png\" alt><br>\n例如这里我们给定一个空间，将空间内的元素浮动，这时候会发现父级的高度并不会被撑开，这种情况就是我们常说的<code>高度塌陷</code>。<br>\n我们可以利用<code>BFC</code>来解决这个问题，给父级设置一个<code>overflow:hidden</code>，触发<code>BFC</code>。</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.father</span>&#123;</span><br><span class=\"line\">  <span class=\"attribute\">width</span>:<span class=\"number\">200px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">background</span>:<span class=\"number\">#CCC</span>; </span><br><span class=\"line\">  <span class=\"attribute\">border</span>:<span class=\"number\">4px</span> solid <span class=\"number\">#000</span>;</span><br><span class=\"line\">  <span class=\"attribute\">overflow</span>:hidden;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-class\">.child</span>&#123;</span><br><span class=\"line\">  <span class=\"attribute\">width</span>:<span class=\"number\">100px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">height</span>:<span class=\"number\">100px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">float</span>:left;</span><br><span class=\"line\">  <span class=\"attribute\">background</span>:red; </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><img src=\"http://img.kyootah.com/2022/02/11/28e96ce1f9180.png\" alt><br>\n这个时候可以看到我们的容器高度被撑开了,遵循BFC布局规则第1条: <strong>计算BFC的高度时，浮动元素也参与计算</strong></p>\n<h4 id=\"元素被浮动元素覆盖问题\">元素被浮动元素覆盖问题</h4>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"aside\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"main\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.main</span>&#123;</span><br><span class=\"line\">  <span class=\"attribute\">width</span>:<span class=\"number\">200px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">height</span>:<span class=\"number\">200px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">background</span>:<span class=\"number\">#CCC</span>;   </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-class\">.aside</span>&#123;</span><br><span class=\"line\">  <span class=\"attribute\">width</span>:<span class=\"number\">100px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">height</span>:<span class=\"number\">100px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">float</span>:left;</span><br><span class=\"line\">  <span class=\"attribute\">background</span>:red; </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><img src=\"http://img.kyootah.com/2022/02/11/2cdfaf30985e6.png\" alt><br>\n可以看到当<code>aside</code>浮动了之后覆盖在了没设置浮动的<code>main</code>上。<br>\n<strong>为什么会这样</strong>？因为BFC布局规则规定：<strong>每个元素的margin box的左边，与包含块border box的左边相接触(对于从左往右的格式化，否则相反)。即使存在浮动也是如此</strong>。因此，虽然存在浮动的元素<code>aside</code>，但main的左边依然会与包含块的左边相接触。<br>\n<strong>解决方法：利用<code>BFC</code>的规则非浮动元素不会覆盖浮动元素位置（非浮动元素触发了BFC）</strong>,给<code>main</code>设置<code>overflow:hidden</code>。<br>\n<strong>适用场景</strong>： 自适应多栏布局（避免多列布局由于宽度计算四舍五入而自动换行）</p>\n <figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> <span class=\"selector-class\">.main</span>&#123;</span><br><span class=\"line\">  <span class=\"attribute\">width</span>:<span class=\"number\">200px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">height</span>:<span class=\"number\">200px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">background</span>:<span class=\"number\">#CCC</span>;   </span><br><span class=\"line\">  <span class=\"attribute\">overflow</span>:hidden;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><img src=\"http://img.kyootah.com/2022/02/11/d51a57d70ee73.png\" alt></p>\n<h4 id=\"margin重合问题\">margin重合问题</h4>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"father\"</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"child1\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"child2\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.father</span>&#123;</span><br><span class=\"line\">  <span class=\"attribute\">width</span>:<span class=\"number\">200px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">background</span>:<span class=\"number\">#ccc</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-class\">.child1</span>&#123;</span><br><span class=\"line\">  <span class=\"attribute\">width</span>:<span class=\"number\">100px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">height</span>:<span class=\"number\">100px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">background</span>:red;</span><br><span class=\"line\">  <span class=\"attribute\">margin-bottom</span>:<span class=\"number\">10px</span>;  </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-class\">.child2</span>&#123;</span><br><span class=\"line\">  <span class=\"attribute\">width</span>:<span class=\"number\">100px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">height</span>:<span class=\"number\">100px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">background</span>:red; </span><br><span class=\"line\">  <span class=\"attribute\">margin-top</span>:<span class=\"number\">10px</span>; </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><img src=\"http://img.kyootah.com/2022/02/11/9c78fdbd677fc.png\" alt><br>\n例如上面两个<code>child</code>，分别设置了<code>margin-bottom</code>与<code>margin-top</code>10px，但实际效果是两个元素的间隔只有 <strong>10px</strong> ,而非理想的 <strong>20px</strong><br>\n<strong>解决方法</strong>:给其中某个元素给定一个外层并触发BFC。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"father\"</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"child1\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"wrap\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"child2\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.wrap</span>&#123;</span><br><span class=\"line\">  <span class=\"attribute\">overflow</span>: hidden;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>可以看到间距恢复正常了<br>\n<img src=\"http://img.kyootah.com/2022/02/11/c1193823448c7.png\" alt></p>\n<h4 id=\"margin塌陷问题\">margin塌陷问题</h4>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"father\"</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"child\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span> </span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.father</span>&#123;</span><br><span class=\"line\">  <span class=\"attribute\">width</span>:<span class=\"number\">200px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">height</span>:<span class=\"number\">200px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">background</span>:blue;</span><br><span class=\"line\">  <span class=\"attribute\">margin</span>:<span class=\"number\">60px</span>;  </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"selector-class\">.child</span>&#123;</span><br><span class=\"line\">  <span class=\"attribute\">width</span>:<span class=\"number\">100px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">height</span>:<span class=\"number\">100px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">background</span>:red;</span><br><span class=\"line\">  <span class=\"attribute\">margin</span>:<span class=\"number\">50px</span>;  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><img src=\"http://img.kyootah.com/2022/02/11/b599137ffb6bb.png\" alt><br>\n我们给定一个元素<code>father</code>并设置<code>margin:60px</code>，并在其中放入子元素<code>child</code>，设置<code>margin:50px</code>，可以看到水平上面的边距生效了，垂直方向没效果,这就是<strong>外边距塌陷</strong>现象<br>\n<strong>什么是margin外边距塌陷？<strong>对于两个嵌套关系（父子关系）的块元素，父元素有上外边距同时子元素也有上外边距，此时父元素会塌陷</strong>较大</strong>的外边距值。<br>\n<strong>解决方法</strong>：让父元素变成<code>BFC</code>,在<code>father</code>中加入<code>overflow:hidden;</code><br>\n效果：<br>\n<img src=\"http://img.kyootah.com/2022/02/11/39a3214151401.png\" alt></p>\n","site":{"data":{}},"excerpt":"","more":"<h3>定意</h3>\n<blockquote>\n<p>在解释<code>BFC</code>之前，先说一下文档流。我们常说的文档流其实分为定位流、浮动流和普通流三种。而普通流其实就是指<code>BFC</code>中的<code>FC</code>。<code>FC</code>是<code>formatting context</code>的首字母缩写，直译过来是格式化上下文，它是页面中的一块渲染区域，有一套渲染规则，决定了其子元素如何布局，以及和其他元素之间的关系和作用。常见的FC有BFC、IFC，还有GFC和FFC。<code>BFC</code>是<code>block formatting context</code>，也就是块级格式化上下文，是用于布局块级盒子的一块渲染区域</p>\n</blockquote>\n<p>简单来说<code>BFC</code>是一个独立的区域，它内部的元素都依照它的规则渲染，不会与 BFC 外部打交道。</p>\n<h3>如何触发</h3>\n<ul>\n<li><code>overflow</code>:hidden | scroll | auto; （不是visible）</li>\n<li><code>float</code>:不为none</li>\n<li><code>display</code>:inline-block | table-cell | table-caption | flex | grid ;（ 非none 非inline 非block）</li>\n<li><code>position</code>: absolute | fiexed ;（ 非relative）<br>\n可以简单理解成<code>OFDP</code>。</li>\n</ul>\n<h3>BFC布局规则</h3>\n<ul>\n<li>1.浮动的元素会被父级计算高度（父级触发了BFC）</li>\n<li>2.非浮动元素不会覆盖浮动元素位置（非浮动元素触发了BFC）</li>\n<li>3.margin不会传递给父级（父级触发了BFC）</li>\n<li>4.两个相邻元素上下margin会重叠（给其中一个元素增加一个父级，然后让他的父级触发BFC）</li>\n</ul>\n<h3>可以解决什么问题</h3>\n<h4>浮动元素父级高度塌陷问题</h4>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"father\"</span>&gt;</span> </span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"child\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.father</span>&#123;</span><br><span class=\"line\">  <span class=\"attribute\">width</span>:<span class=\"number\">200px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">background</span>:<span class=\"number\">#CCC</span>; </span><br><span class=\"line\">  <span class=\"attribute\">border</span>:<span class=\"number\">4px</span> solid <span class=\"number\">#000</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-class\">.child</span>&#123;</span><br><span class=\"line\">  <span class=\"attribute\">width</span>:<span class=\"number\">100px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">height</span>:<span class=\"number\">100px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">float</span>:left;</span><br><span class=\"line\">  <span class=\"attribute\">background</span>:red; </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><img src=\"http://img.kyootah.com/2022/02/11/3bb61c98b5c8d.png\" alt><br>\n例如这里我们给定一个空间，将空间内的元素浮动，这时候会发现父级的高度并不会被撑开，这种情况就是我们常说的<code>高度塌陷</code>。<br>\n我们可以利用<code>BFC</code>来解决这个问题，给父级设置一个<code>overflow:hidden</code>，触发<code>BFC</code>。</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.father</span>&#123;</span><br><span class=\"line\">  <span class=\"attribute\">width</span>:<span class=\"number\">200px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">background</span>:<span class=\"number\">#CCC</span>; </span><br><span class=\"line\">  <span class=\"attribute\">border</span>:<span class=\"number\">4px</span> solid <span class=\"number\">#000</span>;</span><br><span class=\"line\">  <span class=\"attribute\">overflow</span>:hidden;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-class\">.child</span>&#123;</span><br><span class=\"line\">  <span class=\"attribute\">width</span>:<span class=\"number\">100px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">height</span>:<span class=\"number\">100px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">float</span>:left;</span><br><span class=\"line\">  <span class=\"attribute\">background</span>:red; </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><img src=\"http://img.kyootah.com/2022/02/11/28e96ce1f9180.png\" alt><br>\n这个时候可以看到我们的容器高度被撑开了,遵循BFC布局规则第1条: <strong>计算BFC的高度时，浮动元素也参与计算</strong></p>\n<h4>元素被浮动元素覆盖问题</h4>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"aside\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"main\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.main</span>&#123;</span><br><span class=\"line\">  <span class=\"attribute\">width</span>:<span class=\"number\">200px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">height</span>:<span class=\"number\">200px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">background</span>:<span class=\"number\">#CCC</span>;   </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-class\">.aside</span>&#123;</span><br><span class=\"line\">  <span class=\"attribute\">width</span>:<span class=\"number\">100px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">height</span>:<span class=\"number\">100px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">float</span>:left;</span><br><span class=\"line\">  <span class=\"attribute\">background</span>:red; </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><img src=\"http://img.kyootah.com/2022/02/11/2cdfaf30985e6.png\" alt><br>\n可以看到当<code>aside</code>浮动了之后覆盖在了没设置浮动的<code>main</code>上。<br>\n<strong>为什么会这样</strong>？因为BFC布局规则规定：<strong>每个元素的margin box的左边，与包含块border box的左边相接触(对于从左往右的格式化，否则相反)。即使存在浮动也是如此</strong>。因此，虽然存在浮动的元素<code>aside</code>，但main的左边依然会与包含块的左边相接触。<br>\n<strong>解决方法：利用<code>BFC</code>的规则非浮动元素不会覆盖浮动元素位置（非浮动元素触发了BFC）</strong>,给<code>main</code>设置<code>overflow:hidden</code>。<br>\n<strong>适用场景</strong>： 自适应多栏布局（避免多列布局由于宽度计算四舍五入而自动换行）</p>\n <figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> <span class=\"selector-class\">.main</span>&#123;</span><br><span class=\"line\">  <span class=\"attribute\">width</span>:<span class=\"number\">200px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">height</span>:<span class=\"number\">200px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">background</span>:<span class=\"number\">#CCC</span>;   </span><br><span class=\"line\">  <span class=\"attribute\">overflow</span>:hidden;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><img src=\"http://img.kyootah.com/2022/02/11/d51a57d70ee73.png\" alt></p>\n<h4>margin重合问题</h4>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"father\"</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"child1\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"child2\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.father</span>&#123;</span><br><span class=\"line\">  <span class=\"attribute\">width</span>:<span class=\"number\">200px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">background</span>:<span class=\"number\">#ccc</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-class\">.child1</span>&#123;</span><br><span class=\"line\">  <span class=\"attribute\">width</span>:<span class=\"number\">100px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">height</span>:<span class=\"number\">100px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">background</span>:red;</span><br><span class=\"line\">  <span class=\"attribute\">margin-bottom</span>:<span class=\"number\">10px</span>;  </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-class\">.child2</span>&#123;</span><br><span class=\"line\">  <span class=\"attribute\">width</span>:<span class=\"number\">100px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">height</span>:<span class=\"number\">100px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">background</span>:red; </span><br><span class=\"line\">  <span class=\"attribute\">margin-top</span>:<span class=\"number\">10px</span>; </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><img src=\"http://img.kyootah.com/2022/02/11/9c78fdbd677fc.png\" alt><br>\n例如上面两个<code>child</code>，分别设置了<code>margin-bottom</code>与<code>margin-top</code>10px，但实际效果是两个元素的间隔只有 <strong>10px</strong> ,而非理想的 <strong>20px</strong><br>\n<strong>解决方法</strong>:给其中某个元素给定一个外层并触发BFC。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"father\"</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"child1\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"wrap\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"child2\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.wrap</span>&#123;</span><br><span class=\"line\">  <span class=\"attribute\">overflow</span>: hidden;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>可以看到间距恢复正常了<br>\n<img src=\"http://img.kyootah.com/2022/02/11/c1193823448c7.png\" alt></p>\n<h4>margin塌陷问题</h4>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"father\"</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"child\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span> </span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.father</span>&#123;</span><br><span class=\"line\">  <span class=\"attribute\">width</span>:<span class=\"number\">200px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">height</span>:<span class=\"number\">200px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">background</span>:blue;</span><br><span class=\"line\">  <span class=\"attribute\">margin</span>:<span class=\"number\">60px</span>;  </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"selector-class\">.child</span>&#123;</span><br><span class=\"line\">  <span class=\"attribute\">width</span>:<span class=\"number\">100px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">height</span>:<span class=\"number\">100px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">background</span>:red;</span><br><span class=\"line\">  <span class=\"attribute\">margin</span>:<span class=\"number\">50px</span>;  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><img src=\"http://img.kyootah.com/2022/02/11/b599137ffb6bb.png\" alt><br>\n我们给定一个元素<code>father</code>并设置<code>margin:60px</code>，并在其中放入子元素<code>child</code>，设置<code>margin:50px</code>，可以看到水平上面的边距生效了，垂直方向没效果,这就是<strong>外边距塌陷</strong>现象<br>\n<strong>什么是margin外边距塌陷？<strong>对于两个嵌套关系（父子关系）的块元素，父元素有上外边距同时子元素也有上外边距，此时父元素会塌陷</strong>较大</strong>的外边距值。<br>\n<strong>解决方法</strong>：让父元素变成<code>BFC</code>,在<code>father</code>中加入<code>overflow:hidden;</code><br>\n效果：<br>\n<img src=\"http://img.kyootah.com/2022/02/11/39a3214151401.png\" alt></p>\n"},{"title":"ElementUI弹窗默认z-index层问题级","catalog":true,"toc_nav_num":false,"toc":false,"date":"2020-07-08T09:14:12.000Z","subtitle":null,"header-img":null,"_content":"\n\n\n>当我在Element的dailog组件中使用富文本编辑器tinymce-editor的时候发现图片上传弹窗的层级比Element组件的层级低了不少，导致显示被遮挡的情况，后来发现在引用的时候可以设置默认属性，记录一下加深印象。\n\ndailog组件默认会加上一个z-index\n![](http://img.kyootah.com/2021/05/08/60f5654be8bc0.png)\n\n官网文档有说明这个问题\n```\nVue.use(Element, { size: 'small', zIndex: 3000 });\n```\n![](http://img.kyootah.com/2021/05/08/b74f1f827cda1.png)\n\n","source":"_posts/ElementUI弹窗默认z-index层问题.md","raw":"---\ntitle: ElementUI弹窗默认z-index层问题级\ncatalog: true\ntoc_nav_num: false\ntoc: false\ndate: 2020-07-08 17:14:12\nsubtitle:\nheader-img:\ntags:\n- 工作中遇到的问题\n---\n\n\n\n>当我在Element的dailog组件中使用富文本编辑器tinymce-editor的时候发现图片上传弹窗的层级比Element组件的层级低了不少，导致显示被遮挡的情况，后来发现在引用的时候可以设置默认属性，记录一下加深印象。\n\ndailog组件默认会加上一个z-index\n![](http://img.kyootah.com/2021/05/08/60f5654be8bc0.png)\n\n官网文档有说明这个问题\n```\nVue.use(Element, { size: 'small', zIndex: 3000 });\n```\n![](http://img.kyootah.com/2021/05/08/b74f1f827cda1.png)\n\n","slug":"ElementUI弹窗默认z-index层问题","published":1,"updated":"2022-02-14T08:41:57.287Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl27vhg5d0009u8q5c0im9slx","content":"<blockquote>\n<p>当我在Element的dailog组件中使用富文本编辑器tinymce-editor的时候发现图片上传弹窗的层级比Element组件的层级低了不少，导致显示被遮挡的情况，后来发现在引用的时候可以设置默认属性，记录一下加深印象。</p>\n</blockquote>\n<p>dailog组件默认会加上一个z-index<br>\n<img src=\"http://img.kyootah.com/2021/05/08/60f5654be8bc0.png\" alt></p>\n<p>官网文档有说明这个问题</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Vue.use(Element, &#123; size: &apos;small&apos;, zIndex: 3000 &#125;);</span><br></pre></td></tr></table></figure>\n<p><img src=\"http://img.kyootah.com/2021/05/08/b74f1f827cda1.png\" alt></p>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>当我在Element的dailog组件中使用富文本编辑器tinymce-editor的时候发现图片上传弹窗的层级比Element组件的层级低了不少，导致显示被遮挡的情况，后来发现在引用的时候可以设置默认属性，记录一下加深印象。</p>\n</blockquote>\n<p>dailog组件默认会加上一个z-index<br>\n<img src=\"http://img.kyootah.com/2021/05/08/60f5654be8bc0.png\" alt></p>\n<p>官网文档有说明这个问题</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Vue.use(Element, &#123; size: &apos;small&apos;, zIndex: 3000 &#125;);</span><br></pre></td></tr></table></figure>\n<p><img src=\"http://img.kyootah.com/2021/05/08/b74f1f827cda1.png\" alt></p>\n"},{"title":"理解浏览器与node的事件循环机制","catalog":true,"date":"2021-10-03T13:33:21.000Z","subtitle":null,"header-img":null,"_content":" \n\n \n\n\n## 事件循环机制并不是js本身的特性\n\n>在谈事件循环的时候，经常会说请说一说JS的事件循环机制。这常常会让人产生一种误解，事件循环好像是JS语言的特性。实际上并不是，简单来说是宿主环境提供事件循环。\n\n\n浏览器宿主环境包含JS引擎和渲染引擎。最常见的宿主环境就是浏览器提供的环境。\n* JS引擎：运行JavaScript代码。最出名的是Chrome的V8引擎。\n* 渲染引擎：对网页进行排版和显示。最出名的是Webkit引擎。\n\n**除了浏览器**，`Node.js`也是一个主要的宿主环境，这个环境就不包含渲染引擎了。它也提供了同浏览器稍有不同的事件循环机制。\n\n\n\n## JS是单线程语言\n>在浏览器环境中，有JS 引擎线程和渲染线程，且两个线程互斥。\nNode环境中，只有JS 线程。\n\n\nJS是单线程的，一个任务完成之后才能执行另一个任务。 \n比如下面这串代码,我们可以思考下输出结果是`setTimeout`的会穿插到`for`之间还是说在最后\n```js\nfor(let i=0;i<2000;i++){\n    console.log(1)\n} \nsetTimeout(()=>{console.log(2)},0);\nconsole.log(3);\n```\n结果是输出了2000个1之后再输出3,再输出2。\n\n因为JS引擎并不提供事件循环，且关键的一点，JS是单线程语言，所以浏览器**需要有一种机制，让JS能处理异步任务**，于是有了事件循环机制。\n\n## 调用栈 Call Stack\n在`JavaScript`运行的时候，主线程会形成一个栈，这个栈主要是解释器用来最终函数执行流的一种机制。通常这个栈被称为`调用栈Call Stack`，或者`执行栈（Execution Context Stack）`。\n\n* 每调用一个函数，解释器就会把该函数的执行上下文添加到调用栈并开始执行；\n* 正在调用栈中执行的函数，如果还调用了其他函数，那么新函数也会被添加到调用栈，并立即执行；\n* 当前函数执行完毕后，解释器会将其执行上下文清除调用栈，继续执行剩余执行上下文中的剩余代码；\n* 但分配的调用栈空间被占满，会引发”堆栈溢出“的报错。  \n \n## 任务队列\n由于js是单线程的执行方式，这个时候会衍生出一些问题，就是如果当一个语句需要执行很长一段事件的话，比如请求数据、定时器、读取文件等，后面的语句就一定得等到前面的执行语句结束之后才会执行，显而易见，这是不可取的。\n\n所以js将所有执行任务分为了`同步任务`和`异步任务`。\n\n其实我们每个任务都是在做两件事情，就是**发起调用**和**得到结果**。\n而同步任务和异步任务最主要的差别就是，同步任务发起调用后，很快就可以得到结果，而异步任务是无法立即得到结果，比如请求接口，每个接口都会有一定的响应时间，根据网速、服务器等等因素决定，再比如定时器，它需要固定时间后才会返回结果。\n\n因此，对于同步任务和异步任务的执行机制也不同。\n**同步任务的执行**，就是按照代码顺序和调用循序，进入调用栈中并执行，执行结束后就移除调用栈。\n而**异步任务的执行**，首先它依旧会进入调用栈中，并发起调用，然后解析器会**将其响应回调任务**放入一个**任务队列**，接着调用栈会将这个任务一处，当主线程清空后（即所有同步任务结束后）,解析器会读取任务队列，并一次将**已完成的异步任务（事件回调）**加入调用栈中并执行。\n**注： 异步任务不是直接进入任务队列的**\n\n### 宏任务微任务\n\n在任务队列中，分为`宏任务队列（Task Queue）`和`微任务队列（Microtask Queue）`，对应的里面存放的就是`宏任务`和`微任务`。\n\n**宏任务:** `Ajax` 、`setTimeout`、`setInterval`、`setImediate`（node）、`requestAnimationFrame`(浏览器)、`读取文件`，这些任务都是宏任务 \n**微任务:** `Promise.then/catch/finally` 、`MutaionObserver`（浏览器）、`process.nextTick`（Node.js），这些任务都是微任务\n\n首先，**宏任务和微任务都是异步任务**。\n\n\n### 任务队列入队\n虽说JS是单线程语言，**但是浏览器是多线程的**。对于不同的线程会对不同的事件进行处理，当事件可以执行的时候，就会放入任务队列之中。\n* **js引擎线程**：用于解释执行js代码、用户输入、网络请求等；\n* **GUI渲染线程**：绘制用户界面，与JS主线程互斥（因为js可以操作DOM，进而会影响到GUI的渲染结果）；\n* **http异步网络请求线程**：处理用户的get、post等请求，等返回结果后将回调函数推入到任务队列；\n* **定时触发器线程**：setInterval、setTimeout等待时间结束后，会把执行函数推入任务队列中；\n* **浏览器事件处理线程**：将click、mouse等UI交互事件发生后，将要执行的回调函数放入到事件队列中。 \n\n我们根据下面代码来理解一下：\n```js\nsetTimeout(()=>{\nconsole.log(1)\n},1000)\n\nsetTimeout(()=>{\nconsole.log(2)\n},100)\n```\n按照上面结论**当事件可以执行的时候,就会放入任务队列之中**，第二个定时器的事件比第一个事件先执行，即先放入队列之中，所以是先输出的2再是1.\n\n### 执行顺序\n1. 同步程序\n2. process.nextTick\n3. 微任务\n4. 宏任务\n5. setimmediate\n\n## 事件循环\n![](https://img.kyootah.com/2022/03/08/97916a96baef2.png)\n\n\n从这张图 我们可以得出来一个结论，**同步任务永远先于异步任务执行**。因为执行栈判断出该任务是同步任务，会直接执行，而异步任务会加入到任务队列(一种先进先出的数据结构）后，暂且不会执行。等到执行栈为空后，再看任务队列的首任务有没有事件回调，存在事件回调那就执行，执行完后移出任务队列，依次往复，直到任务队列为空。\n\n我们来通过一个常见的面试题来理解一下事件循环\n```js\nconsole.log(\"a\");\n\nsetTimeout(function () {\n    console.log(\"b\");\n}, 0);\n\nnew Promise((resolve) => {\n    console.log(\"c\");\n    resolve();\n}).then(function () {\n        console.log(\"d\");\n}).then(function () {\n        console.log(\"e\");\n    });\n\nconsole.log(\"f\");\n\n/**\n* 输出结果：a c f d e b\n*/\n```\n我们来解析一下循环步骤：\n1. 代码执行，先将**整体代码script**推入宏任务队列中，执行该宏任务。\n2. 执行同步代码`console.log(\"a\")`：推入调用栈，执行完成后移出调用栈。\n3. 执行`setTimeout()`：由于`setTimeout()`是宏任务，所以进入调用栈中，将它的callback推入宏任务队列后移出调用栈\n4. 接下来是`Promise`,先将`Promise`推入调用栈，执行`console.log(\"c\")`...,执行`resolve()`...。（这里...省略调用栈的入栈出栈\n5. 接下来是`new Promise().then()`，这是一个微任务，因此推入微任务队列之中`new Promise()`结束，移出调用栈\n6. 接下来是`console.log('f')`,执行结束，`script`宏任务就结束了，移出宏任务队列。\n7. 接下来就开始清空微任务队列。首先执行的是`new Promise().then()`，推入调用栈，执行并移出调用栈\n8. 结束`console.log('d')`后检测还有一个`then`，将其推入微任务队列后将本次then移出微任务队列。\n9. 接着再查一遍微任务队列，发现还有一个`then`，因此继续执行下一个`then`,将其推入调用栈，执行并移除，此时微任务队列就清空了，第一个事件循环结束\n10. 接下来执行下一个宏任务，`setTimeout callback`,执行结束后，它也被移除宏任务队列和调用栈。\n11. 这时候微任务队列里面没有任务，因此第二个事件循环也结束了\n\n总结：\n* 从宏任务队列中，按照入队顺序，找到第一个执行的宏任务，放入调用栈，开始执行；\n* 执行完该宏任务下所有同步任务后，即调用栈清空后，该宏任务被推出宏任务队列，然后微任务队列开始按照入队顺序，依次执行其中的微任务，直至微任务队列清空为止；\n* 当微任务队列清空后，一个事件循环结束；\n* 接着从宏任务队列中，找到下一个执行的宏任务，开始第二个事件循环，直至宏任务队列清空为止。\n\n重点： \n* 当我们第一次执行的时候，解释器会将整体代码script放入宏任务队列中，因此事件循环是从第一个宏任务开始的；\n* 如果在执行微任务的过程中，产生新的微任务添加到微任务队列中，也需要一起清空；微任务队列没清空之前，是不会执行下一个宏任务的。\n\n\n\n## async await\n \n\n ","source":"_posts/事件循环机制.md","raw":"---\ntitle: 理解浏览器与node的事件循环机制\ncatalog: true \ndate: 2021-10-03 21:33:21\nsubtitle:\nheader-img:\ntags:\n- JavaScript深入\n- 事件循环\n---\n \n\n \n\n\n## 事件循环机制并不是js本身的特性\n\n>在谈事件循环的时候，经常会说请说一说JS的事件循环机制。这常常会让人产生一种误解，事件循环好像是JS语言的特性。实际上并不是，简单来说是宿主环境提供事件循环。\n\n\n浏览器宿主环境包含JS引擎和渲染引擎。最常见的宿主环境就是浏览器提供的环境。\n* JS引擎：运行JavaScript代码。最出名的是Chrome的V8引擎。\n* 渲染引擎：对网页进行排版和显示。最出名的是Webkit引擎。\n\n**除了浏览器**，`Node.js`也是一个主要的宿主环境，这个环境就不包含渲染引擎了。它也提供了同浏览器稍有不同的事件循环机制。\n\n\n\n## JS是单线程语言\n>在浏览器环境中，有JS 引擎线程和渲染线程，且两个线程互斥。\nNode环境中，只有JS 线程。\n\n\nJS是单线程的，一个任务完成之后才能执行另一个任务。 \n比如下面这串代码,我们可以思考下输出结果是`setTimeout`的会穿插到`for`之间还是说在最后\n```js\nfor(let i=0;i<2000;i++){\n    console.log(1)\n} \nsetTimeout(()=>{console.log(2)},0);\nconsole.log(3);\n```\n结果是输出了2000个1之后再输出3,再输出2。\n\n因为JS引擎并不提供事件循环，且关键的一点，JS是单线程语言，所以浏览器**需要有一种机制，让JS能处理异步任务**，于是有了事件循环机制。\n\n## 调用栈 Call Stack\n在`JavaScript`运行的时候，主线程会形成一个栈，这个栈主要是解释器用来最终函数执行流的一种机制。通常这个栈被称为`调用栈Call Stack`，或者`执行栈（Execution Context Stack）`。\n\n* 每调用一个函数，解释器就会把该函数的执行上下文添加到调用栈并开始执行；\n* 正在调用栈中执行的函数，如果还调用了其他函数，那么新函数也会被添加到调用栈，并立即执行；\n* 当前函数执行完毕后，解释器会将其执行上下文清除调用栈，继续执行剩余执行上下文中的剩余代码；\n* 但分配的调用栈空间被占满，会引发”堆栈溢出“的报错。  \n \n## 任务队列\n由于js是单线程的执行方式，这个时候会衍生出一些问题，就是如果当一个语句需要执行很长一段事件的话，比如请求数据、定时器、读取文件等，后面的语句就一定得等到前面的执行语句结束之后才会执行，显而易见，这是不可取的。\n\n所以js将所有执行任务分为了`同步任务`和`异步任务`。\n\n其实我们每个任务都是在做两件事情，就是**发起调用**和**得到结果**。\n而同步任务和异步任务最主要的差别就是，同步任务发起调用后，很快就可以得到结果，而异步任务是无法立即得到结果，比如请求接口，每个接口都会有一定的响应时间，根据网速、服务器等等因素决定，再比如定时器，它需要固定时间后才会返回结果。\n\n因此，对于同步任务和异步任务的执行机制也不同。\n**同步任务的执行**，就是按照代码顺序和调用循序，进入调用栈中并执行，执行结束后就移除调用栈。\n而**异步任务的执行**，首先它依旧会进入调用栈中，并发起调用，然后解析器会**将其响应回调任务**放入一个**任务队列**，接着调用栈会将这个任务一处，当主线程清空后（即所有同步任务结束后）,解析器会读取任务队列，并一次将**已完成的异步任务（事件回调）**加入调用栈中并执行。\n**注： 异步任务不是直接进入任务队列的**\n\n### 宏任务微任务\n\n在任务队列中，分为`宏任务队列（Task Queue）`和`微任务队列（Microtask Queue）`，对应的里面存放的就是`宏任务`和`微任务`。\n\n**宏任务:** `Ajax` 、`setTimeout`、`setInterval`、`setImediate`（node）、`requestAnimationFrame`(浏览器)、`读取文件`，这些任务都是宏任务 \n**微任务:** `Promise.then/catch/finally` 、`MutaionObserver`（浏览器）、`process.nextTick`（Node.js），这些任务都是微任务\n\n首先，**宏任务和微任务都是异步任务**。\n\n\n### 任务队列入队\n虽说JS是单线程语言，**但是浏览器是多线程的**。对于不同的线程会对不同的事件进行处理，当事件可以执行的时候，就会放入任务队列之中。\n* **js引擎线程**：用于解释执行js代码、用户输入、网络请求等；\n* **GUI渲染线程**：绘制用户界面，与JS主线程互斥（因为js可以操作DOM，进而会影响到GUI的渲染结果）；\n* **http异步网络请求线程**：处理用户的get、post等请求，等返回结果后将回调函数推入到任务队列；\n* **定时触发器线程**：setInterval、setTimeout等待时间结束后，会把执行函数推入任务队列中；\n* **浏览器事件处理线程**：将click、mouse等UI交互事件发生后，将要执行的回调函数放入到事件队列中。 \n\n我们根据下面代码来理解一下：\n```js\nsetTimeout(()=>{\nconsole.log(1)\n},1000)\n\nsetTimeout(()=>{\nconsole.log(2)\n},100)\n```\n按照上面结论**当事件可以执行的时候,就会放入任务队列之中**，第二个定时器的事件比第一个事件先执行，即先放入队列之中，所以是先输出的2再是1.\n\n### 执行顺序\n1. 同步程序\n2. process.nextTick\n3. 微任务\n4. 宏任务\n5. setimmediate\n\n## 事件循环\n![](https://img.kyootah.com/2022/03/08/97916a96baef2.png)\n\n\n从这张图 我们可以得出来一个结论，**同步任务永远先于异步任务执行**。因为执行栈判断出该任务是同步任务，会直接执行，而异步任务会加入到任务队列(一种先进先出的数据结构）后，暂且不会执行。等到执行栈为空后，再看任务队列的首任务有没有事件回调，存在事件回调那就执行，执行完后移出任务队列，依次往复，直到任务队列为空。\n\n我们来通过一个常见的面试题来理解一下事件循环\n```js\nconsole.log(\"a\");\n\nsetTimeout(function () {\n    console.log(\"b\");\n}, 0);\n\nnew Promise((resolve) => {\n    console.log(\"c\");\n    resolve();\n}).then(function () {\n        console.log(\"d\");\n}).then(function () {\n        console.log(\"e\");\n    });\n\nconsole.log(\"f\");\n\n/**\n* 输出结果：a c f d e b\n*/\n```\n我们来解析一下循环步骤：\n1. 代码执行，先将**整体代码script**推入宏任务队列中，执行该宏任务。\n2. 执行同步代码`console.log(\"a\")`：推入调用栈，执行完成后移出调用栈。\n3. 执行`setTimeout()`：由于`setTimeout()`是宏任务，所以进入调用栈中，将它的callback推入宏任务队列后移出调用栈\n4. 接下来是`Promise`,先将`Promise`推入调用栈，执行`console.log(\"c\")`...,执行`resolve()`...。（这里...省略调用栈的入栈出栈\n5. 接下来是`new Promise().then()`，这是一个微任务，因此推入微任务队列之中`new Promise()`结束，移出调用栈\n6. 接下来是`console.log('f')`,执行结束，`script`宏任务就结束了，移出宏任务队列。\n7. 接下来就开始清空微任务队列。首先执行的是`new Promise().then()`，推入调用栈，执行并移出调用栈\n8. 结束`console.log('d')`后检测还有一个`then`，将其推入微任务队列后将本次then移出微任务队列。\n9. 接着再查一遍微任务队列，发现还有一个`then`，因此继续执行下一个`then`,将其推入调用栈，执行并移除，此时微任务队列就清空了，第一个事件循环结束\n10. 接下来执行下一个宏任务，`setTimeout callback`,执行结束后，它也被移除宏任务队列和调用栈。\n11. 这时候微任务队列里面没有任务，因此第二个事件循环也结束了\n\n总结：\n* 从宏任务队列中，按照入队顺序，找到第一个执行的宏任务，放入调用栈，开始执行；\n* 执行完该宏任务下所有同步任务后，即调用栈清空后，该宏任务被推出宏任务队列，然后微任务队列开始按照入队顺序，依次执行其中的微任务，直至微任务队列清空为止；\n* 当微任务队列清空后，一个事件循环结束；\n* 接着从宏任务队列中，找到下一个执行的宏任务，开始第二个事件循环，直至宏任务队列清空为止。\n\n重点： \n* 当我们第一次执行的时候，解释器会将整体代码script放入宏任务队列中，因此事件循环是从第一个宏任务开始的；\n* 如果在执行微任务的过程中，产生新的微任务添加到微任务队列中，也需要一起清空；微任务队列没清空之前，是不会执行下一个宏任务的。\n\n\n\n## async await\n \n\n ","slug":"事件循环机制","published":1,"updated":"2022-03-09T08:39:40.045Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl27vhg5f000au8q595v94p4k","content":"<h2 id=\"事件循环机制并不是js本身的特性\">事件循环机制并不是js本身的特性</h2>\n<blockquote>\n<p>在谈事件循环的时候，经常会说请说一说JS的事件循环机制。这常常会让人产生一种误解，事件循环好像是JS语言的特性。实际上并不是，简单来说是宿主环境提供事件循环。</p>\n</blockquote>\n<p>浏览器宿主环境包含JS引擎和渲染引擎。最常见的宿主环境就是浏览器提供的环境。</p>\n<ul>\n<li>JS引擎：运行JavaScript代码。最出名的是Chrome的V8引擎。</li>\n<li>渲染引擎：对网页进行排版和显示。最出名的是Webkit引擎。</li>\n</ul>\n<p><strong>除了浏览器</strong>，<code>Node.js</code>也是一个主要的宿主环境，这个环境就不包含渲染引擎了。它也提供了同浏览器稍有不同的事件循环机制。</p>\n<h2 id=\"js是单线程语言\">JS是单线程语言</h2>\n<blockquote>\n<p>在浏览器环境中，有JS 引擎线程和渲染线程，且两个线程互斥。<br>\nNode环境中，只有JS 线程。</p>\n</blockquote>\n<p>JS是单线程的，一个任务完成之后才能执行另一个任务。<br>\n比如下面这串代码,我们可以思考下输出结果是<code>setTimeout</code>的会穿插到<code>for</code>之间还是说在最后</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> i=<span class=\"number\">0</span>;i&lt;<span class=\"number\">2000</span>;i++)&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"number\">1</span>)</span><br><span class=\"line\">&#125; </span><br><span class=\"line\">setTimeout(<span class=\"function\"><span class=\"params\">()</span>=&gt;</span>&#123;<span class=\"built_in\">console</span>.log(<span class=\"number\">2</span>)&#125;,<span class=\"number\">0</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"number\">3</span>);</span><br></pre></td></tr></table></figure>\n<p>结果是输出了2000个1之后再输出3,再输出2。</p>\n<p>因为JS引擎并不提供事件循环，且关键的一点，JS是单线程语言，所以浏览器<strong>需要有一种机制，让JS能处理异步任务</strong>，于是有了事件循环机制。</p>\n<h2 id=\"调用栈-call-stack\">调用栈 Call Stack</h2>\n<p>在<code>JavaScript</code>运行的时候，主线程会形成一个栈，这个栈主要是解释器用来最终函数执行流的一种机制。通常这个栈被称为<code>调用栈Call Stack</code>，或者<code>执行栈（Execution Context Stack）</code>。</p>\n<ul>\n<li>每调用一个函数，解释器就会把该函数的执行上下文添加到调用栈并开始执行；</li>\n<li>正在调用栈中执行的函数，如果还调用了其他函数，那么新函数也会被添加到调用栈，并立即执行；</li>\n<li>当前函数执行完毕后，解释器会将其执行上下文清除调用栈，继续执行剩余执行上下文中的剩余代码；</li>\n<li>但分配的调用栈空间被占满，会引发”堆栈溢出“的报错。</li>\n</ul>\n<h2 id=\"任务队列\">任务队列</h2>\n<p>由于js是单线程的执行方式，这个时候会衍生出一些问题，就是如果当一个语句需要执行很长一段事件的话，比如请求数据、定时器、读取文件等，后面的语句就一定得等到前面的执行语句结束之后才会执行，显而易见，这是不可取的。</p>\n<p>所以js将所有执行任务分为了<code>同步任务</code>和<code>异步任务</code>。</p>\n<p>其实我们每个任务都是在做两件事情，就是<strong>发起调用</strong>和<strong>得到结果</strong>。<br>\n而同步任务和异步任务最主要的差别就是，同步任务发起调用后，很快就可以得到结果，而异步任务是无法立即得到结果，比如请求接口，每个接口都会有一定的响应时间，根据网速、服务器等等因素决定，再比如定时器，它需要固定时间后才会返回结果。</p>\n<p>因此，对于同步任务和异步任务的执行机制也不同。<br>\n<strong>同步任务的执行</strong>，就是按照代码顺序和调用循序，进入调用栈中并执行，执行结束后就移除调用栈。<br>\n而<strong>异步任务的执行</strong>，首先它依旧会进入调用栈中，并发起调用，然后解析器会<strong>将其响应回调任务</strong>放入一个<strong>任务队列</strong>，接着调用栈会将这个任务一处，当主线程清空后（即所有同步任务结束后）,解析器会读取任务队列，并一次将**已完成的异步任务（事件回调）**加入调用栈中并执行。<br>\n<strong>注： 异步任务不是直接进入任务队列的</strong></p>\n<h3 id=\"宏任务微任务\">宏任务微任务</h3>\n<p>在任务队列中，分为<code>宏任务队列（Task Queue）</code>和<code>微任务队列（Microtask Queue）</code>，对应的里面存放的就是<code>宏任务</code>和<code>微任务</code>。</p>\n<p><strong>宏任务:</strong> <code>Ajax</code> 、<code>setTimeout</code>、<code>setInterval</code>、<code>setImediate</code>（node）、<code>requestAnimationFrame</code>(浏览器)、<code>读取文件</code>，这些任务都是宏任务<br>\n<strong>微任务:</strong> <code>Promise.then/catch/finally</code> 、<code>MutaionObserver</code>（浏览器）、<code>process.nextTick</code>（Node.js），这些任务都是微任务</p>\n<p>首先，<strong>宏任务和微任务都是异步任务</strong>。</p>\n<h3 id=\"任务队列入队\">任务队列入队</h3>\n<p>虽说JS是单线程语言，<strong>但是浏览器是多线程的</strong>。对于不同的线程会对不同的事件进行处理，当事件可以执行的时候，就会放入任务队列之中。</p>\n<ul>\n<li><strong>js引擎线程</strong>：用于解释执行js代码、用户输入、网络请求等；</li>\n<li><strong>GUI渲染线程</strong>：绘制用户界面，与JS主线程互斥（因为js可以操作DOM，进而会影响到GUI的渲染结果）；</li>\n<li><strong>http异步网络请求线程</strong>：处理用户的get、post等请求，等返回结果后将回调函数推入到任务队列；</li>\n<li><strong>定时触发器线程</strong>：setInterval、setTimeout等待时间结束后，会把执行函数推入任务队列中；</li>\n<li><strong>浏览器事件处理线程</strong>：将click、mouse等UI交互事件发生后，将要执行的回调函数放入到事件队列中。</li>\n</ul>\n<p>我们根据下面代码来理解一下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">setTimeout(<span class=\"function\"><span class=\"params\">()</span>=&gt;</span>&#123;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"number\">1</span>)</span><br><span class=\"line\">&#125;,<span class=\"number\">1000</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">setTimeout(<span class=\"function\"><span class=\"params\">()</span>=&gt;</span>&#123;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"number\">2</span>)</span><br><span class=\"line\">&#125;,<span class=\"number\">100</span>)</span><br></pre></td></tr></table></figure>\n<p>按照上面结论<strong>当事件可以执行的时候,就会放入任务队列之中</strong>，第二个定时器的事件比第一个事件先执行，即先放入队列之中，所以是先输出的2再是1.</p>\n<h3 id=\"执行顺序\">执行顺序</h3>\n<ol>\n<li>同步程序</li>\n<li>process.nextTick</li>\n<li>微任务</li>\n<li>宏任务</li>\n<li>setimmediate</li>\n</ol>\n<h2 id=\"事件循环\">事件循环</h2>\n<p><img src=\"https://img.kyootah.com/2022/03/08/97916a96baef2.png\" alt></p>\n<p>从这张图 我们可以得出来一个结论，<strong>同步任务永远先于异步任务执行</strong>。因为执行栈判断出该任务是同步任务，会直接执行，而异步任务会加入到任务队列(一种先进先出的数据结构）后，暂且不会执行。等到执行栈为空后，再看任务队列的首任务有没有事件回调，存在事件回调那就执行，执行完后移出任务队列，依次往复，直到任务队列为空。</p>\n<p>我们来通过一个常见的面试题来理解一下事件循环</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">\"a\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">setTimeout(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">\"b\"</span>);</span><br><span class=\"line\">&#125;, <span class=\"number\">0</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\">(<span class=\"params\">resolve</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">\"c\"</span>);</span><br><span class=\"line\">    resolve();</span><br><span class=\"line\">&#125;).then(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">\"d\"</span>);</span><br><span class=\"line\">&#125;).then(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">\"e\"</span>);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">\"f\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">* 输出结果：a c f d e b</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br></pre></td></tr></table></figure>\n<p>我们来解析一下循环步骤：</p>\n<ol>\n<li>代码执行，先将<strong>整体代码script</strong>推入宏任务队列中，执行该宏任务。</li>\n<li>执行同步代码<code>console.log(&quot;a&quot;)</code>：推入调用栈，执行完成后移出调用栈。</li>\n<li>执行<code>setTimeout()</code>：由于<code>setTimeout()</code>是宏任务，所以进入调用栈中，将它的callback推入宏任务队列后移出调用栈</li>\n<li>接下来是<code>Promise</code>,先将<code>Promise</code>推入调用栈，执行<code>console.log(&quot;c&quot;)</code>…,执行<code>resolve()</code>…。（这里…省略调用栈的入栈出栈</li>\n<li>接下来是<code>new Promise().then()</code>，这是一个微任务，因此推入微任务队列之中<code>new Promise()</code>结束，移出调用栈</li>\n<li>接下来是<code>console.log('f')</code>,执行结束，<code>script</code>宏任务就结束了，移出宏任务队列。</li>\n<li>接下来就开始清空微任务队列。首先执行的是<code>new Promise().then()</code>，推入调用栈，执行并移出调用栈</li>\n<li>结束<code>console.log('d')</code>后检测还有一个<code>then</code>，将其推入微任务队列后将本次then移出微任务队列。</li>\n<li>接着再查一遍微任务队列，发现还有一个<code>then</code>，因此继续执行下一个<code>then</code>,将其推入调用栈，执行并移除，此时微任务队列就清空了，第一个事件循环结束</li>\n<li>接下来执行下一个宏任务，<code>setTimeout callback</code>,执行结束后，它也被移除宏任务队列和调用栈。</li>\n<li>这时候微任务队列里面没有任务，因此第二个事件循环也结束了</li>\n</ol>\n<p>总结：</p>\n<ul>\n<li>从宏任务队列中，按照入队顺序，找到第一个执行的宏任务，放入调用栈，开始执行；</li>\n<li>执行完该宏任务下所有同步任务后，即调用栈清空后，该宏任务被推出宏任务队列，然后微任务队列开始按照入队顺序，依次执行其中的微任务，直至微任务队列清空为止；</li>\n<li>当微任务队列清空后，一个事件循环结束；</li>\n<li>接着从宏任务队列中，找到下一个执行的宏任务，开始第二个事件循环，直至宏任务队列清空为止。</li>\n</ul>\n<p>重点：</p>\n<ul>\n<li>当我们第一次执行的时候，解释器会将整体代码script放入宏任务队列中，因此事件循环是从第一个宏任务开始的；</li>\n<li>如果在执行微任务的过程中，产生新的微任务添加到微任务队列中，也需要一起清空；微任务队列没清空之前，是不会执行下一个宏任务的。</li>\n</ul>\n<h2 id=\"async-await\">async await</h2>\n","site":{"data":{}},"excerpt":"","more":"<h2>事件循环机制并不是js本身的特性</h2>\n<blockquote>\n<p>在谈事件循环的时候，经常会说请说一说JS的事件循环机制。这常常会让人产生一种误解，事件循环好像是JS语言的特性。实际上并不是，简单来说是宿主环境提供事件循环。</p>\n</blockquote>\n<p>浏览器宿主环境包含JS引擎和渲染引擎。最常见的宿主环境就是浏览器提供的环境。</p>\n<ul>\n<li>JS引擎：运行JavaScript代码。最出名的是Chrome的V8引擎。</li>\n<li>渲染引擎：对网页进行排版和显示。最出名的是Webkit引擎。</li>\n</ul>\n<p><strong>除了浏览器</strong>，<code>Node.js</code>也是一个主要的宿主环境，这个环境就不包含渲染引擎了。它也提供了同浏览器稍有不同的事件循环机制。</p>\n<h2>JS是单线程语言</h2>\n<blockquote>\n<p>在浏览器环境中，有JS 引擎线程和渲染线程，且两个线程互斥。<br>\nNode环境中，只有JS 线程。</p>\n</blockquote>\n<p>JS是单线程的，一个任务完成之后才能执行另一个任务。<br>\n比如下面这串代码,我们可以思考下输出结果是<code>setTimeout</code>的会穿插到<code>for</code>之间还是说在最后</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> i=<span class=\"number\">0</span>;i&lt;<span class=\"number\">2000</span>;i++)&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"number\">1</span>)</span><br><span class=\"line\">&#125; </span><br><span class=\"line\">setTimeout(<span class=\"function\"><span class=\"params\">()</span>=&gt;</span>&#123;<span class=\"built_in\">console</span>.log(<span class=\"number\">2</span>)&#125;,<span class=\"number\">0</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"number\">3</span>);</span><br></pre></td></tr></table></figure>\n<p>结果是输出了2000个1之后再输出3,再输出2。</p>\n<p>因为JS引擎并不提供事件循环，且关键的一点，JS是单线程语言，所以浏览器<strong>需要有一种机制，让JS能处理异步任务</strong>，于是有了事件循环机制。</p>\n<h2>调用栈 Call Stack</h2>\n<p>在<code>JavaScript</code>运行的时候，主线程会形成一个栈，这个栈主要是解释器用来最终函数执行流的一种机制。通常这个栈被称为<code>调用栈Call Stack</code>，或者<code>执行栈（Execution Context Stack）</code>。</p>\n<ul>\n<li>每调用一个函数，解释器就会把该函数的执行上下文添加到调用栈并开始执行；</li>\n<li>正在调用栈中执行的函数，如果还调用了其他函数，那么新函数也会被添加到调用栈，并立即执行；</li>\n<li>当前函数执行完毕后，解释器会将其执行上下文清除调用栈，继续执行剩余执行上下文中的剩余代码；</li>\n<li>但分配的调用栈空间被占满，会引发”堆栈溢出“的报错。</li>\n</ul>\n<h2>任务队列</h2>\n<p>由于js是单线程的执行方式，这个时候会衍生出一些问题，就是如果当一个语句需要执行很长一段事件的话，比如请求数据、定时器、读取文件等，后面的语句就一定得等到前面的执行语句结束之后才会执行，显而易见，这是不可取的。</p>\n<p>所以js将所有执行任务分为了<code>同步任务</code>和<code>异步任务</code>。</p>\n<p>其实我们每个任务都是在做两件事情，就是<strong>发起调用</strong>和<strong>得到结果</strong>。<br>\n而同步任务和异步任务最主要的差别就是，同步任务发起调用后，很快就可以得到结果，而异步任务是无法立即得到结果，比如请求接口，每个接口都会有一定的响应时间，根据网速、服务器等等因素决定，再比如定时器，它需要固定时间后才会返回结果。</p>\n<p>因此，对于同步任务和异步任务的执行机制也不同。<br>\n<strong>同步任务的执行</strong>，就是按照代码顺序和调用循序，进入调用栈中并执行，执行结束后就移除调用栈。<br>\n而<strong>异步任务的执行</strong>，首先它依旧会进入调用栈中，并发起调用，然后解析器会<strong>将其响应回调任务</strong>放入一个<strong>任务队列</strong>，接着调用栈会将这个任务一处，当主线程清空后（即所有同步任务结束后）,解析器会读取任务队列，并一次将**已完成的异步任务（事件回调）**加入调用栈中并执行。<br>\n<strong>注： 异步任务不是直接进入任务队列的</strong></p>\n<h3>宏任务微任务</h3>\n<p>在任务队列中，分为<code>宏任务队列（Task Queue）</code>和<code>微任务队列（Microtask Queue）</code>，对应的里面存放的就是<code>宏任务</code>和<code>微任务</code>。</p>\n<p><strong>宏任务:</strong> <code>Ajax</code> 、<code>setTimeout</code>、<code>setInterval</code>、<code>setImediate</code>（node）、<code>requestAnimationFrame</code>(浏览器)、<code>读取文件</code>，这些任务都是宏任务<br>\n<strong>微任务:</strong> <code>Promise.then/catch/finally</code> 、<code>MutaionObserver</code>（浏览器）、<code>process.nextTick</code>（Node.js），这些任务都是微任务</p>\n<p>首先，<strong>宏任务和微任务都是异步任务</strong>。</p>\n<h3>任务队列入队</h3>\n<p>虽说JS是单线程语言，<strong>但是浏览器是多线程的</strong>。对于不同的线程会对不同的事件进行处理，当事件可以执行的时候，就会放入任务队列之中。</p>\n<ul>\n<li><strong>js引擎线程</strong>：用于解释执行js代码、用户输入、网络请求等；</li>\n<li><strong>GUI渲染线程</strong>：绘制用户界面，与JS主线程互斥（因为js可以操作DOM，进而会影响到GUI的渲染结果）；</li>\n<li><strong>http异步网络请求线程</strong>：处理用户的get、post等请求，等返回结果后将回调函数推入到任务队列；</li>\n<li><strong>定时触发器线程</strong>：setInterval、setTimeout等待时间结束后，会把执行函数推入任务队列中；</li>\n<li><strong>浏览器事件处理线程</strong>：将click、mouse等UI交互事件发生后，将要执行的回调函数放入到事件队列中。</li>\n</ul>\n<p>我们根据下面代码来理解一下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">setTimeout(<span class=\"function\"><span class=\"params\">()</span>=&gt;</span>&#123;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"number\">1</span>)</span><br><span class=\"line\">&#125;,<span class=\"number\">1000</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">setTimeout(<span class=\"function\"><span class=\"params\">()</span>=&gt;</span>&#123;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"number\">2</span>)</span><br><span class=\"line\">&#125;,<span class=\"number\">100</span>)</span><br></pre></td></tr></table></figure>\n<p>按照上面结论<strong>当事件可以执行的时候,就会放入任务队列之中</strong>，第二个定时器的事件比第一个事件先执行，即先放入队列之中，所以是先输出的2再是1.</p>\n<h3>执行顺序</h3>\n<ol>\n<li>同步程序</li>\n<li>process.nextTick</li>\n<li>微任务</li>\n<li>宏任务</li>\n<li>setimmediate</li>\n</ol>\n<h2>事件循环</h2>\n<p><img src=\"https://img.kyootah.com/2022/03/08/97916a96baef2.png\" alt></p>\n<p>从这张图 我们可以得出来一个结论，<strong>同步任务永远先于异步任务执行</strong>。因为执行栈判断出该任务是同步任务，会直接执行，而异步任务会加入到任务队列(一种先进先出的数据结构）后，暂且不会执行。等到执行栈为空后，再看任务队列的首任务有没有事件回调，存在事件回调那就执行，执行完后移出任务队列，依次往复，直到任务队列为空。</p>\n<p>我们来通过一个常见的面试题来理解一下事件循环</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">\"a\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">setTimeout(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">\"b\"</span>);</span><br><span class=\"line\">&#125;, <span class=\"number\">0</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\">(<span class=\"params\">resolve</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">\"c\"</span>);</span><br><span class=\"line\">    resolve();</span><br><span class=\"line\">&#125;).then(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">\"d\"</span>);</span><br><span class=\"line\">&#125;).then(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">\"e\"</span>);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">\"f\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">* 输出结果：a c f d e b</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br></pre></td></tr></table></figure>\n<p>我们来解析一下循环步骤：</p>\n<ol>\n<li>代码执行，先将<strong>整体代码script</strong>推入宏任务队列中，执行该宏任务。</li>\n<li>执行同步代码<code>console.log(&quot;a&quot;)</code>：推入调用栈，执行完成后移出调用栈。</li>\n<li>执行<code>setTimeout()</code>：由于<code>setTimeout()</code>是宏任务，所以进入调用栈中，将它的callback推入宏任务队列后移出调用栈</li>\n<li>接下来是<code>Promise</code>,先将<code>Promise</code>推入调用栈，执行<code>console.log(&quot;c&quot;)</code>…,执行<code>resolve()</code>…。（这里…省略调用栈的入栈出栈</li>\n<li>接下来是<code>new Promise().then()</code>，这是一个微任务，因此推入微任务队列之中<code>new Promise()</code>结束，移出调用栈</li>\n<li>接下来是<code>console.log('f')</code>,执行结束，<code>script</code>宏任务就结束了，移出宏任务队列。</li>\n<li>接下来就开始清空微任务队列。首先执行的是<code>new Promise().then()</code>，推入调用栈，执行并移出调用栈</li>\n<li>结束<code>console.log('d')</code>后检测还有一个<code>then</code>，将其推入微任务队列后将本次then移出微任务队列。</li>\n<li>接着再查一遍微任务队列，发现还有一个<code>then</code>，因此继续执行下一个<code>then</code>,将其推入调用栈，执行并移除，此时微任务队列就清空了，第一个事件循环结束</li>\n<li>接下来执行下一个宏任务，<code>setTimeout callback</code>,执行结束后，它也被移除宏任务队列和调用栈。</li>\n<li>这时候微任务队列里面没有任务，因此第二个事件循环也结束了</li>\n</ol>\n<p>总结：</p>\n<ul>\n<li>从宏任务队列中，按照入队顺序，找到第一个执行的宏任务，放入调用栈，开始执行；</li>\n<li>执行完该宏任务下所有同步任务后，即调用栈清空后，该宏任务被推出宏任务队列，然后微任务队列开始按照入队顺序，依次执行其中的微任务，直至微任务队列清空为止；</li>\n<li>当微任务队列清空后，一个事件循环结束；</li>\n<li>接着从宏任务队列中，找到下一个执行的宏任务，开始第二个事件循环，直至宏任务队列清空为止。</li>\n</ul>\n<p>重点：</p>\n<ul>\n<li>当我们第一次执行的时候，解释器会将整体代码script放入宏任务队列中，因此事件循环是从第一个宏任务开始的；</li>\n<li>如果在执行微任务的过程中，产生新的微任务添加到微任务队列中，也需要一起清空；微任务队列没清空之前，是不会执行下一个宏任务的。</li>\n</ul>\n<h2>async await</h2>\n"},{"title":"js深拷贝的应用与封装","catalog":true,"toc_nav_num":true,"date":"2021-12-23T13:42:40.000Z","subtitle":null,"header-img":null,"_content":"\n> 在前端开发中，经常会遇到要对一个对象进行拷贝深拷贝，对于深拷贝我们往往只用JSON.parse(JSON.stringify())来进行深拷贝，但对于为什么需要深拷贝，JSON.parse(JSON.stringify())会有什么不足，可能我们并没有去过多了解，现在我们来详细聊聊。'\n\n\n## 基础知识\n在了解深拷贝之前，我们需要了解一些js的基础知识。\n### js的数据类型\n在`ES6`中，js一共有7种数据类型\n* Undefined\n* Null\n* String\n* Number\n* Boolean\n* Symbol\n* Object(包含Array、Function、Date、RegExp、Error)\n\n前面6种属于`简单数据类型（基本数据类型）`，而Object属于`复杂数据类型(引用数据类型)`，数据类型的不同，在内存中存储的方式也不同\n**基本数据类型：**因为基本数据类型占用空间小、大小固定，通过按值来访问，属于被频繁使用的数据，存储在栈空间中；\n**引用数据类型：**存储在堆空间中，因为引用数据类型占据空间大、大小不固定。 如果存储在栈中，将会影响程序运行的性能，**所以引用数据类型在栈中存储了指针，该指针指向堆中该实体的起始地址**；\n也正是以为存储的方式不同，所以才会出现深拷贝与浅拷贝。\n\n## JSON.stringify\n### 实现深拷贝\n对于Object的深拷贝，最简单的方法就是JSON.stringify()\n```js\nvar obj={\n\tname:'zewen',\n    age:18\n};\nvar obj1=JSON.parse(JSON.stringify(obj));\n```\n在日常开发中，大多数的Object的深拷贝可以通过这种方式来简单实现，但他也有他的缺陷。\n比如下面这段代码\n```js\nvar obj={\n\tname:'zewen',\n    birthday:new Date('1998/08/22'),\n    run:function(){\n        console.log('run')\n    }\n};\nvar obj1=JSON.parse(JSON.stringify(obj));\nconsole.log(obj1);//{name: \"zewen\",birthday: \"1998-08-21T16:00:00.000Z\"}\n```\n是不是发现出了问题，run方法丢失了，birthday的格式也变了\n\n### JSON.stringify深拷贝的弊端\n1. 如果Object中存在`时间对象`，会调用**toJSON(同Date.toISOString)**方法将时间对象转换为**字符串**格式；\n2. 如果Object里有`函数`、`undefined`，则序列化的结果会把函数， undefined**丢失**；\n3. 如果Object里有`RegExp`、`Error`对象，则序列化的结果将**只得到空对象**；\n4. 如果Object里有`NaN`、`Infinity`和`-Infinity`，则序列化的结果会变成**null**；\n5. JSON.stringify()只能序列化对象的可枚举的自有属性。 如果Object中的对象是由`构造函数`生成的， 则使用JSON.parse(JSON.stringify(obj))深拷贝后，**会丢弃对象的constructor**；\n6. 如果对象中存在`循环引用`的情况也无法正确实现深拷贝；\n\n## 通用深拷贝函数的封装\n\n### 获取数据类型函数\n在克隆之前我们先封装一个获取数据类型的方法以便我们针对不同的数据类型，采用不同的拷贝方式\n```js\nexport const getObjType = (obj) => {\n  var toString = Object.prototype.toString;\n  var map = {\n    '[object Boolean]': 'boolean',\n    '[object Number]': 'number',\n    '[object String]': 'string',\n    '[object Function]': 'function',\n    '[object Array]': 'array',\n    '[object Date]': 'date',\n    '[object RegExp]': 'regExp',\n    '[object Undefined]': 'undefined',\n    '[object Null]': 'null',\n    '[object Object]': 'object'\n  };\n  if (obj instanceof Element) {\n    return 'element';\n  }\n  return map[toString.call(obj)];\n\n \n};\n\n```\n\n\n### 深拷贝函数\n```js\n/**\n * 对象深拷贝\n */\nexport const deepClone = (data) => {\n  var type = getObjType(data);//获取数据类型\n  var obj;\n  if (type === 'array') {\n    obj = [];\n  } else if (type === 'object') {\n    obj = {};\n  } else {\n    //不再具有下一层次\n    return data;\n  }\n  if (type === 'array') {\n    for (var i = 0, len = data.length; i < len; i++) {\n      obj.push(deepClone(data[i]));\n    }\n  } else if (type === 'object') {\n    for (var key in data) {\n      obj[key] = deepClone(data[key]); \n    }\n  }\n  return obj;\n};\n\n \n```\n\n\n\n### 循环引用情况补充\n\n循环引用平时基本不会遇到，毕竟循环引用比较容易出现问题，日常开发中都尽量避免。\n在总结跑用例的时候发现之前封装的方法对于循环引用拷贝的情况会出现栈内存溢出的情况，这里补充修改一下方法；\n我们先用上面的方法来跑一下测试用例\n```js\nvar field={\n    field1: 1,\n    field2: undefined,\n    field3: {\n        child: 'child'\n    },\n    field4: [2, 4, 8]\n};\nfield.field = field\nconsole.log(deepClone(field));//报错 Uncaught RangeError: Maximum call stack size exceeded\n```\n可以发现确实进入死循环栈内存溢出了，我们来优化一下\n解决思路：利用map，将拷贝过的数据存储一下，如果再遇到，直接取\n```js\n/**\n * 对象深拷贝，考虑循环引用\n */\nexport const deepClone = (data,map = new WeakMap()) => {\n  var type = getObjType(data);//获取数据类型\n  var obj;\n  if (type === 'array') {\n    obj = [];\n  } else if (type === 'object') {\n    obj = {};\n  } else {\n    //不再具有下一层次\n    return data;\n  }\n  if (type === 'array') { \n    for (var i = 0, len = data.length; i < len; i++) {\n      obj.push(deepClone(data[i]));\n    }\n  } else if (type === 'object') { \n    if (map.get(data)) {\n        return map.get(data);\n    }\n    map.set(data, data); \n    for (var key in data) {\n      obj[key] = deepClone(data[key],map); \n    }\n  }\n  return obj;\n};\n\n \n```\n\n\n\n\n","source":"_posts/js深拷贝的应用与封装.md","raw":"---\ntitle: js深拷贝的应用与封装\ncatalog: true\ntoc_nav_num: true\ndate: 2021-12-23 21:42:40\nsubtitle:\nheader-img:\ntags:\n- 工作中遇到的问题\n- js进阶\n- 深拷贝\n---\n\n> 在前端开发中，经常会遇到要对一个对象进行拷贝深拷贝，对于深拷贝我们往往只用JSON.parse(JSON.stringify())来进行深拷贝，但对于为什么需要深拷贝，JSON.parse(JSON.stringify())会有什么不足，可能我们并没有去过多了解，现在我们来详细聊聊。'\n\n\n## 基础知识\n在了解深拷贝之前，我们需要了解一些js的基础知识。\n### js的数据类型\n在`ES6`中，js一共有7种数据类型\n* Undefined\n* Null\n* String\n* Number\n* Boolean\n* Symbol\n* Object(包含Array、Function、Date、RegExp、Error)\n\n前面6种属于`简单数据类型（基本数据类型）`，而Object属于`复杂数据类型(引用数据类型)`，数据类型的不同，在内存中存储的方式也不同\n**基本数据类型：**因为基本数据类型占用空间小、大小固定，通过按值来访问，属于被频繁使用的数据，存储在栈空间中；\n**引用数据类型：**存储在堆空间中，因为引用数据类型占据空间大、大小不固定。 如果存储在栈中，将会影响程序运行的性能，**所以引用数据类型在栈中存储了指针，该指针指向堆中该实体的起始地址**；\n也正是以为存储的方式不同，所以才会出现深拷贝与浅拷贝。\n\n## JSON.stringify\n### 实现深拷贝\n对于Object的深拷贝，最简单的方法就是JSON.stringify()\n```js\nvar obj={\n\tname:'zewen',\n    age:18\n};\nvar obj1=JSON.parse(JSON.stringify(obj));\n```\n在日常开发中，大多数的Object的深拷贝可以通过这种方式来简单实现，但他也有他的缺陷。\n比如下面这段代码\n```js\nvar obj={\n\tname:'zewen',\n    birthday:new Date('1998/08/22'),\n    run:function(){\n        console.log('run')\n    }\n};\nvar obj1=JSON.parse(JSON.stringify(obj));\nconsole.log(obj1);//{name: \"zewen\",birthday: \"1998-08-21T16:00:00.000Z\"}\n```\n是不是发现出了问题，run方法丢失了，birthday的格式也变了\n\n### JSON.stringify深拷贝的弊端\n1. 如果Object中存在`时间对象`，会调用**toJSON(同Date.toISOString)**方法将时间对象转换为**字符串**格式；\n2. 如果Object里有`函数`、`undefined`，则序列化的结果会把函数， undefined**丢失**；\n3. 如果Object里有`RegExp`、`Error`对象，则序列化的结果将**只得到空对象**；\n4. 如果Object里有`NaN`、`Infinity`和`-Infinity`，则序列化的结果会变成**null**；\n5. JSON.stringify()只能序列化对象的可枚举的自有属性。 如果Object中的对象是由`构造函数`生成的， 则使用JSON.parse(JSON.stringify(obj))深拷贝后，**会丢弃对象的constructor**；\n6. 如果对象中存在`循环引用`的情况也无法正确实现深拷贝；\n\n## 通用深拷贝函数的封装\n\n### 获取数据类型函数\n在克隆之前我们先封装一个获取数据类型的方法以便我们针对不同的数据类型，采用不同的拷贝方式\n```js\nexport const getObjType = (obj) => {\n  var toString = Object.prototype.toString;\n  var map = {\n    '[object Boolean]': 'boolean',\n    '[object Number]': 'number',\n    '[object String]': 'string',\n    '[object Function]': 'function',\n    '[object Array]': 'array',\n    '[object Date]': 'date',\n    '[object RegExp]': 'regExp',\n    '[object Undefined]': 'undefined',\n    '[object Null]': 'null',\n    '[object Object]': 'object'\n  };\n  if (obj instanceof Element) {\n    return 'element';\n  }\n  return map[toString.call(obj)];\n\n \n};\n\n```\n\n\n### 深拷贝函数\n```js\n/**\n * 对象深拷贝\n */\nexport const deepClone = (data) => {\n  var type = getObjType(data);//获取数据类型\n  var obj;\n  if (type === 'array') {\n    obj = [];\n  } else if (type === 'object') {\n    obj = {};\n  } else {\n    //不再具有下一层次\n    return data;\n  }\n  if (type === 'array') {\n    for (var i = 0, len = data.length; i < len; i++) {\n      obj.push(deepClone(data[i]));\n    }\n  } else if (type === 'object') {\n    for (var key in data) {\n      obj[key] = deepClone(data[key]); \n    }\n  }\n  return obj;\n};\n\n \n```\n\n\n\n### 循环引用情况补充\n\n循环引用平时基本不会遇到，毕竟循环引用比较容易出现问题，日常开发中都尽量避免。\n在总结跑用例的时候发现之前封装的方法对于循环引用拷贝的情况会出现栈内存溢出的情况，这里补充修改一下方法；\n我们先用上面的方法来跑一下测试用例\n```js\nvar field={\n    field1: 1,\n    field2: undefined,\n    field3: {\n        child: 'child'\n    },\n    field4: [2, 4, 8]\n};\nfield.field = field\nconsole.log(deepClone(field));//报错 Uncaught RangeError: Maximum call stack size exceeded\n```\n可以发现确实进入死循环栈内存溢出了，我们来优化一下\n解决思路：利用map，将拷贝过的数据存储一下，如果再遇到，直接取\n```js\n/**\n * 对象深拷贝，考虑循环引用\n */\nexport const deepClone = (data,map = new WeakMap()) => {\n  var type = getObjType(data);//获取数据类型\n  var obj;\n  if (type === 'array') {\n    obj = [];\n  } else if (type === 'object') {\n    obj = {};\n  } else {\n    //不再具有下一层次\n    return data;\n  }\n  if (type === 'array') { \n    for (var i = 0, len = data.length; i < len; i++) {\n      obj.push(deepClone(data[i]));\n    }\n  } else if (type === 'object') { \n    if (map.get(data)) {\n        return map.get(data);\n    }\n    map.set(data, data); \n    for (var key in data) {\n      obj[key] = deepClone(data[key],map); \n    }\n  }\n  return obj;\n};\n\n \n```\n\n\n\n\n","slug":"js深拷贝的应用与封装","published":1,"updated":"2022-04-20T17:49:28.105Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl27vhg5h000du8q5zc0r6odm","content":"<blockquote>\n<p>在前端开发中，经常会遇到要对一个对象进行拷贝深拷贝，对于深拷贝我们往往只用JSON.parse(JSON.stringify())来进行深拷贝，但对于为什么需要深拷贝，JSON.parse(JSON.stringify())会有什么不足，可能我们并没有去过多了解，现在我们来详细聊聊。’</p>\n</blockquote>\n<h2 id=\"基础知识\">基础知识</h2>\n<p>在了解深拷贝之前，我们需要了解一些js的基础知识。</p>\n<h3 id=\"js的数据类型\">js的数据类型</h3>\n<p>在<code>ES6</code>中，js一共有7种数据类型</p>\n<ul>\n<li>Undefined</li>\n<li>Null</li>\n<li>String</li>\n<li>Number</li>\n<li>Boolean</li>\n<li>Symbol</li>\n<li>Object(包含Array、Function、Date、RegExp、Error)</li>\n</ul>\n<p>前面6种属于<code>简单数据类型（基本数据类型）</code>，而Object属于<code>复杂数据类型(引用数据类型)</code>，数据类型的不同，在内存中存储的方式也不同<br>\n**基本数据类型：**因为基本数据类型占用空间小、大小固定，通过按值来访问，属于被频繁使用的数据，存储在栈空间中；<br>\n**引用数据类型：**存储在堆空间中，因为引用数据类型占据空间大、大小不固定。 如果存储在栈中，将会影响程序运行的性能，<strong>所以引用数据类型在栈中存储了指针，该指针指向堆中该实体的起始地址</strong>；<br>\n也正是以为存储的方式不同，所以才会出现深拷贝与浅拷贝。</p>\n<h2 id=\"jsonstringify\">JSON.stringify</h2>\n<h3 id=\"实现深拷贝\">实现深拷贝</h3>\n<p>对于Object的深拷贝，最简单的方法就是JSON.stringify()</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> obj=&#123;</span><br><span class=\"line\">\tname:<span class=\"string\">'zewen'</span>,</span><br><span class=\"line\">    age:<span class=\"number\">18</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">var</span> obj1=<span class=\"built_in\">JSON</span>.parse(<span class=\"built_in\">JSON</span>.stringify(obj));</span><br></pre></td></tr></table></figure>\n<p>在日常开发中，大多数的Object的深拷贝可以通过这种方式来简单实现，但他也有他的缺陷。<br>\n比如下面这段代码</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> obj=&#123;</span><br><span class=\"line\">\tname:<span class=\"string\">'zewen'</span>,</span><br><span class=\"line\">    birthday:<span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>(<span class=\"string\">'1998/08/22'</span>),</span><br><span class=\"line\">    run:<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">'run'</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">var</span> obj1=<span class=\"built_in\">JSON</span>.parse(<span class=\"built_in\">JSON</span>.stringify(obj));</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(obj1);<span class=\"comment\">//&#123;name: \"zewen\",birthday: \"1998-08-21T16:00:00.000Z\"&#125;</span></span><br></pre></td></tr></table></figure>\n<p>是不是发现出了问题，run方法丢失了，birthday的格式也变了</p>\n<h3 id=\"jsonstringify深拷贝的弊端\">JSON.stringify深拷贝的弊端</h3>\n<ol>\n<li>如果Object中存在<code>时间对象</code>，会调用<strong>toJSON(同Date.toISOString)<strong>方法将时间对象转换为</strong>字符串</strong>格式；</li>\n<li>如果Object里有<code>函数</code>、<code>undefined</code>，则序列化的结果会把函数， undefined<strong>丢失</strong>；</li>\n<li>如果Object里有<code>RegExp</code>、<code>Error</code>对象，则序列化的结果将<strong>只得到空对象</strong>；</li>\n<li>如果Object里有<code>NaN</code>、<code>Infinity</code>和<code>-Infinity</code>，则序列化的结果会变成<strong>null</strong>；</li>\n<li>JSON.stringify()只能序列化对象的可枚举的自有属性。 如果Object中的对象是由<code>构造函数</code>生成的， 则使用JSON.parse(JSON.stringify(obj))深拷贝后，<strong>会丢弃对象的constructor</strong>；</li>\n<li>如果对象中存在<code>循环引用</code>的情况也无法正确实现深拷贝；</li>\n</ol>\n<h2 id=\"通用深拷贝函数的封装\">通用深拷贝函数的封装</h2>\n<h3 id=\"获取数据类型函数\">获取数据类型函数</h3>\n<p>在克隆之前我们先封装一个获取数据类型的方法以便我们针对不同的数据类型，采用不同的拷贝方式</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> getObjType = <span class=\"function\">(<span class=\"params\">obj</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> toString = <span class=\"built_in\">Object</span>.prototype.toString;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> map = &#123;</span><br><span class=\"line\">    <span class=\"string\">'[object Boolean]'</span>: <span class=\"string\">'boolean'</span>,</span><br><span class=\"line\">    <span class=\"string\">'[object Number]'</span>: <span class=\"string\">'number'</span>,</span><br><span class=\"line\">    <span class=\"string\">'[object String]'</span>: <span class=\"string\">'string'</span>,</span><br><span class=\"line\">    <span class=\"string\">'[object Function]'</span>: <span class=\"string\">'function'</span>,</span><br><span class=\"line\">    <span class=\"string\">'[object Array]'</span>: <span class=\"string\">'array'</span>,</span><br><span class=\"line\">    <span class=\"string\">'[object Date]'</span>: <span class=\"string\">'date'</span>,</span><br><span class=\"line\">    <span class=\"string\">'[object RegExp]'</span>: <span class=\"string\">'regExp'</span>,</span><br><span class=\"line\">    <span class=\"string\">'[object Undefined]'</span>: <span class=\"string\">'undefined'</span>,</span><br><span class=\"line\">    <span class=\"string\">'[object Null]'</span>: <span class=\"string\">'null'</span>,</span><br><span class=\"line\">    <span class=\"string\">'[object Object]'</span>: <span class=\"string\">'object'</span></span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (obj <span class=\"keyword\">instanceof</span> Element) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">'element'</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> map[toString.call(obj)];</span><br><span class=\"line\"></span><br><span class=\"line\"> </span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h3 id=\"深拷贝函数\">深拷贝函数</h3>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 对象深拷贝</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> deepClone = <span class=\"function\">(<span class=\"params\">data</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> type = getObjType(data);<span class=\"comment\">//获取数据类型</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> obj;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (type === <span class=\"string\">'array'</span>) &#123;</span><br><span class=\"line\">    obj = [];</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (type === <span class=\"string\">'object'</span>) &#123;</span><br><span class=\"line\">    obj = &#123;&#125;;</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">//不再具有下一层次</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> data;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (type === <span class=\"string\">'array'</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>, len = data.length; i &lt; len; i++) &#123;</span><br><span class=\"line\">      obj.push(deepClone(data[i]));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (type === <span class=\"string\">'object'</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> key <span class=\"keyword\">in</span> data) &#123;</span><br><span class=\"line\">      obj[key] = deepClone(data[key]); </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> obj;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h3 id=\"循环引用情况补充\">循环引用情况补充</h3>\n<p>循环引用平时基本不会遇到，毕竟循环引用比较容易出现问题，日常开发中都尽量避免。<br>\n在总结跑用例的时候发现之前封装的方法对于循环引用拷贝的情况会出现栈内存溢出的情况，这里补充修改一下方法；<br>\n我们先用上面的方法来跑一下测试用例</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> field=&#123;</span><br><span class=\"line\">    field1: <span class=\"number\">1</span>,</span><br><span class=\"line\">    field2: <span class=\"literal\">undefined</span>,</span><br><span class=\"line\">    field3: &#123;</span><br><span class=\"line\">        child: <span class=\"string\">'child'</span></span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    field4: [<span class=\"number\">2</span>, <span class=\"number\">4</span>, <span class=\"number\">8</span>]</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">field.field = field</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(deepClone(field));<span class=\"comment\">//报错 Uncaught RangeError: Maximum call stack size exceeded</span></span><br></pre></td></tr></table></figure>\n<p>可以发现确实进入死循环栈内存溢出了，我们来优化一下<br>\n解决思路：利用map，将拷贝过的数据存储一下，如果再遇到，直接取</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 对象深拷贝，考虑循环引用</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> deepClone = <span class=\"function\">(<span class=\"params\">data,map = <span class=\"keyword\">new</span> <span class=\"built_in\">WeakMap</span>(</span>)) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> type = getObjType(data);<span class=\"comment\">//获取数据类型</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> obj;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (type === <span class=\"string\">'array'</span>) &#123;</span><br><span class=\"line\">    obj = [];</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (type === <span class=\"string\">'object'</span>) &#123;</span><br><span class=\"line\">    obj = &#123;&#125;;</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">//不再具有下一层次</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> data;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (type === <span class=\"string\">'array'</span>) &#123; </span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>, len = data.length; i &lt; len; i++) &#123;</span><br><span class=\"line\">      obj.push(deepClone(data[i]));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (type === <span class=\"string\">'object'</span>) &#123; </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (map.get(data)) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> map.get(data);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    map.set(data, data); </span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> key <span class=\"keyword\">in</span> data) &#123;</span><br><span class=\"line\">      obj[key] = deepClone(data[key],map); </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> obj;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>在前端开发中，经常会遇到要对一个对象进行拷贝深拷贝，对于深拷贝我们往往只用JSON.parse(JSON.stringify())来进行深拷贝，但对于为什么需要深拷贝，JSON.parse(JSON.stringify())会有什么不足，可能我们并没有去过多了解，现在我们来详细聊聊。’</p>\n</blockquote>\n<h2>基础知识</h2>\n<p>在了解深拷贝之前，我们需要了解一些js的基础知识。</p>\n<h3>js的数据类型</h3>\n<p>在<code>ES6</code>中，js一共有7种数据类型</p>\n<ul>\n<li>Undefined</li>\n<li>Null</li>\n<li>String</li>\n<li>Number</li>\n<li>Boolean</li>\n<li>Symbol</li>\n<li>Object(包含Array、Function、Date、RegExp、Error)</li>\n</ul>\n<p>前面6种属于<code>简单数据类型（基本数据类型）</code>，而Object属于<code>复杂数据类型(引用数据类型)</code>，数据类型的不同，在内存中存储的方式也不同<br>\n**基本数据类型：**因为基本数据类型占用空间小、大小固定，通过按值来访问，属于被频繁使用的数据，存储在栈空间中；<br>\n**引用数据类型：**存储在堆空间中，因为引用数据类型占据空间大、大小不固定。 如果存储在栈中，将会影响程序运行的性能，<strong>所以引用数据类型在栈中存储了指针，该指针指向堆中该实体的起始地址</strong>；<br>\n也正是以为存储的方式不同，所以才会出现深拷贝与浅拷贝。</p>\n<h2>JSON.stringify</h2>\n<h3>实现深拷贝</h3>\n<p>对于Object的深拷贝，最简单的方法就是JSON.stringify()</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> obj=&#123;</span><br><span class=\"line\">\tname:<span class=\"string\">'zewen'</span>,</span><br><span class=\"line\">    age:<span class=\"number\">18</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">var</span> obj1=<span class=\"built_in\">JSON</span>.parse(<span class=\"built_in\">JSON</span>.stringify(obj));</span><br></pre></td></tr></table></figure>\n<p>在日常开发中，大多数的Object的深拷贝可以通过这种方式来简单实现，但他也有他的缺陷。<br>\n比如下面这段代码</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> obj=&#123;</span><br><span class=\"line\">\tname:<span class=\"string\">'zewen'</span>,</span><br><span class=\"line\">    birthday:<span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>(<span class=\"string\">'1998/08/22'</span>),</span><br><span class=\"line\">    run:<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">'run'</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">var</span> obj1=<span class=\"built_in\">JSON</span>.parse(<span class=\"built_in\">JSON</span>.stringify(obj));</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(obj1);<span class=\"comment\">//&#123;name: \"zewen\",birthday: \"1998-08-21T16:00:00.000Z\"&#125;</span></span><br></pre></td></tr></table></figure>\n<p>是不是发现出了问题，run方法丢失了，birthday的格式也变了</p>\n<h3>JSON.stringify深拷贝的弊端</h3>\n<ol>\n<li>如果Object中存在<code>时间对象</code>，会调用<strong>toJSON(同Date.toISOString)<strong>方法将时间对象转换为</strong>字符串</strong>格式；</li>\n<li>如果Object里有<code>函数</code>、<code>undefined</code>，则序列化的结果会把函数， undefined<strong>丢失</strong>；</li>\n<li>如果Object里有<code>RegExp</code>、<code>Error</code>对象，则序列化的结果将<strong>只得到空对象</strong>；</li>\n<li>如果Object里有<code>NaN</code>、<code>Infinity</code>和<code>-Infinity</code>，则序列化的结果会变成<strong>null</strong>；</li>\n<li>JSON.stringify()只能序列化对象的可枚举的自有属性。 如果Object中的对象是由<code>构造函数</code>生成的， 则使用JSON.parse(JSON.stringify(obj))深拷贝后，<strong>会丢弃对象的constructor</strong>；</li>\n<li>如果对象中存在<code>循环引用</code>的情况也无法正确实现深拷贝；</li>\n</ol>\n<h2>通用深拷贝函数的封装</h2>\n<h3>获取数据类型函数</h3>\n<p>在克隆之前我们先封装一个获取数据类型的方法以便我们针对不同的数据类型，采用不同的拷贝方式</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> getObjType = <span class=\"function\">(<span class=\"params\">obj</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> toString = <span class=\"built_in\">Object</span>.prototype.toString;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> map = &#123;</span><br><span class=\"line\">    <span class=\"string\">'[object Boolean]'</span>: <span class=\"string\">'boolean'</span>,</span><br><span class=\"line\">    <span class=\"string\">'[object Number]'</span>: <span class=\"string\">'number'</span>,</span><br><span class=\"line\">    <span class=\"string\">'[object String]'</span>: <span class=\"string\">'string'</span>,</span><br><span class=\"line\">    <span class=\"string\">'[object Function]'</span>: <span class=\"string\">'function'</span>,</span><br><span class=\"line\">    <span class=\"string\">'[object Array]'</span>: <span class=\"string\">'array'</span>,</span><br><span class=\"line\">    <span class=\"string\">'[object Date]'</span>: <span class=\"string\">'date'</span>,</span><br><span class=\"line\">    <span class=\"string\">'[object RegExp]'</span>: <span class=\"string\">'regExp'</span>,</span><br><span class=\"line\">    <span class=\"string\">'[object Undefined]'</span>: <span class=\"string\">'undefined'</span>,</span><br><span class=\"line\">    <span class=\"string\">'[object Null]'</span>: <span class=\"string\">'null'</span>,</span><br><span class=\"line\">    <span class=\"string\">'[object Object]'</span>: <span class=\"string\">'object'</span></span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (obj <span class=\"keyword\">instanceof</span> Element) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">'element'</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> map[toString.call(obj)];</span><br><span class=\"line\"></span><br><span class=\"line\"> </span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h3>深拷贝函数</h3>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 对象深拷贝</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> deepClone = <span class=\"function\">(<span class=\"params\">data</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> type = getObjType(data);<span class=\"comment\">//获取数据类型</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> obj;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (type === <span class=\"string\">'array'</span>) &#123;</span><br><span class=\"line\">    obj = [];</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (type === <span class=\"string\">'object'</span>) &#123;</span><br><span class=\"line\">    obj = &#123;&#125;;</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">//不再具有下一层次</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> data;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (type === <span class=\"string\">'array'</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>, len = data.length; i &lt; len; i++) &#123;</span><br><span class=\"line\">      obj.push(deepClone(data[i]));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (type === <span class=\"string\">'object'</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> key <span class=\"keyword\">in</span> data) &#123;</span><br><span class=\"line\">      obj[key] = deepClone(data[key]); </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> obj;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h3>循环引用情况补充</h3>\n<p>循环引用平时基本不会遇到，毕竟循环引用比较容易出现问题，日常开发中都尽量避免。<br>\n在总结跑用例的时候发现之前封装的方法对于循环引用拷贝的情况会出现栈内存溢出的情况，这里补充修改一下方法；<br>\n我们先用上面的方法来跑一下测试用例</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> field=&#123;</span><br><span class=\"line\">    field1: <span class=\"number\">1</span>,</span><br><span class=\"line\">    field2: <span class=\"literal\">undefined</span>,</span><br><span class=\"line\">    field3: &#123;</span><br><span class=\"line\">        child: <span class=\"string\">'child'</span></span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    field4: [<span class=\"number\">2</span>, <span class=\"number\">4</span>, <span class=\"number\">8</span>]</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">field.field = field</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(deepClone(field));<span class=\"comment\">//报错 Uncaught RangeError: Maximum call stack size exceeded</span></span><br></pre></td></tr></table></figure>\n<p>可以发现确实进入死循环栈内存溢出了，我们来优化一下<br>\n解决思路：利用map，将拷贝过的数据存储一下，如果再遇到，直接取</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 对象深拷贝，考虑循环引用</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> deepClone = <span class=\"function\">(<span class=\"params\">data,map = <span class=\"keyword\">new</span> <span class=\"built_in\">WeakMap</span>(</span>)) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> type = getObjType(data);<span class=\"comment\">//获取数据类型</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> obj;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (type === <span class=\"string\">'array'</span>) &#123;</span><br><span class=\"line\">    obj = [];</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (type === <span class=\"string\">'object'</span>) &#123;</span><br><span class=\"line\">    obj = &#123;&#125;;</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">//不再具有下一层次</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> data;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (type === <span class=\"string\">'array'</span>) &#123; </span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>, len = data.length; i &lt; len; i++) &#123;</span><br><span class=\"line\">      obj.push(deepClone(data[i]));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (type === <span class=\"string\">'object'</span>) &#123; </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (map.get(data)) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> map.get(data);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    map.set(data, data); </span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> key <span class=\"keyword\">in</span> data) &#123;</span><br><span class=\"line\">      obj[key] = deepClone(data[key],map); </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> obj;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n"},{"title":"封装一个uniapp列表拖拽排序组件","catalog":true,"toc_nav_num":true,"date":"2021-09-04T13:46:27.000Z","_content":"\n### 封装思路\n1. 渲染列表使用`absolute`布局，然后拖拽时对各个项目的高度进行动态变更;\n2. 利用`longtap`事件，监听开启对某个项目的拖拽状态;\n3. 利用`touchmove`事件，对拖拽的高度进行实时监听;\n4. 利用`touchend`事件，对原数组进行重排并输出;\n \n\n### 代码实现 \n直接贴代码，注释讲解\n```html\n<template>\n\t<view class=\"drag-box\" :style=\"{ height: list.length * itemHeight + 'rpx' }\">\n\t\t<view\n\t\t\tv-for=\"(item, index) in dataList\"\n\t\t\t:key=\"index\"\n\t\t\t:style=\"{ top: item.top + 'px', height: itemHeight - 1 + 'rpx' }\"\n\t\t\tclass=\"drag-item\"\n\t\t\t:class=\"{ 'drag-active': item.isActive }\"\n\t\t\t@longtap=\"longtap(item)\"\n\t\t\t@touchstart=\"touchstart\"\n\t\t\t@touchmove.stop.prevent=\"touchmove\"\n\t\t\t@touchend=\"touchend(item)\"\n\t\t>\n\t\t\t<slot :item=\"item\"></slot>\n\t\t</view>\n\t</view>\n</template>\n```\njs\n```js\nexport default {\n\tprops: {\n\t\tlist: {//项目数组\n\t\t\ttype: Array,\n\t\t\tdefault: () => []\n\t\t},\n\t\titemHeight: { //项目高度 为了方便拖拽计算，对列表的每一项使用了固定高度。\n\t\t\ttype: [Number],\n\t\t\tdefault: 70\n\t\t}\n\t},\n\tdata() {\n\t\treturn {\n\t\t\tactiveItem: null,//当前拖拽中的项目\n\t\t\tisDrag: false,\n\t\t\tdragTargetY: 0,//拖拽开始时记录第一次点击高度\n\t\t\tdataList: [],\n\t\t\tsortIndexList: []\n\t\t};\n\t},\n\twatch: {\n\t\tlist: {\n\t\t\timmediate: true,\n\t\t\tdeep: true,\n\t\t\thandler(list) {\n\t\t\t\tthis.setList(list);\n\t\t\t}\n\t\t}\n\t},\n\tmethods: {\n        // 拖拽前记录一下高度\n\t\ttouchstart(e) {\n\t\t\tconsole.log('touchstart', e);\n\t\t\tthis.dragTargetY = e.touches[0].pageY;//记录点击的屏幕位置\n\t\t},\n        //长按项目开启拖拽\n\t\tlongtap(item) {\n\t\t\tthis.activeItem = item;\n\t\t\tthis.isDrag = true;\n\t\t\titem.isActive = true;\n\t\t},\n\n        //拖拽过程event\n\t\ttouchmove(e) {\n\t\t\tif (!this.isDrag) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tlet newY = e.touches[0].pageY;\n\t\t\tlet d = newY - this.dragTargetY;//计算偏移高度\n\t\t\tthis.activeItem.top += d; //对拖拽项目的top进行变更实现跟手效果\n\n\t\t\tlet prevIndex = this.sortIndexList[this.activeItem.index] - 1;//找出上一个项目\n\t\t\tlet nextIndex = this.sortIndexList[this.activeItem.index] + 1;//找出下一个项目\n\t\t\tif (prevIndex >= 0 && d < 0) {\n\t\t\t\tlet item = this.getItemByIndex(prevIndex);//\n\t\t\t\tif (this.activeItem.top < item.top) {//如果拖拽往上的距离超过了上一个项目的top，则进行换位逻辑\n\t\t\t\t\tthis.swapArray(item);//换位\n\t\t\t\t}\n\t\t\t} else if (nextIndex < this.list.length && d > 0) {\n\t\t\t\tlet item = this.getItemByIndex(nextIndex);\n\t\t\t\tif (this.activeItem.top > item.top) {\n\t\t\t\t\tthis.swapArray(item);\n\t\t\t\t}\n\t\t\t} \n\t\t\tthis.dragTargetY = newY;\n\t\t},\n\n        //拖拽结束，根据每个项目的结果index重排处理数据输出新列表\n\t\ttouchend(item) {\n\t\t\tif (!this.isDrag) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tthis.isDrag = false;\n\t\t\titem.isActive = false;\n\t\t\tthis.activeItem.top = this.sortIndexList[this.activeItem.index] * this.rowHeight;\n\t\t\tlet sortList = [];\n\t\t\tArray(this.dataList.length)\n\t\t\t\t.fill(0)\n\t\t\t\t.forEach((v, index) => {\n\t\t\t\t\tlet tempObj = this.deepClone(this.getItemByIndex(index));\n\t\t\t\t\tdelete tempObj.isActive;\n\t\t\t\t\tdelete tempObj.top;\n\t\t\t\t\tdelete tempObj.index;\n\t\t\t\t\tsortList.push(tempObj);\n\t\t\t\t});\n\t\t\tthis.$emit('change', sortList);\n\t\t},\n\t\tgetItemByIndex(index) {\n\t\t\tfor (let i = 0; i < this.sortIndexList.length; i++) {\n\t\t\t\tif (this.sortIndexList[i] === index) {\n\t\t\t\t\treturn this.dataList[i];\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn null;\n\t\t},\n        //换位操作\n\t\tswapArray(item) { \n\t\t\t//列表中两个元素交换位置\n\t\t\tlet index = this.sortIndexList[this.activeItem.index];\n\t\t\tthis.sortIndexList[this.activeItem.index] = this.sortIndexList[item.index];\n\t\t\tthis.sortIndexList[item.index] = index;\n\t\t\titem.top = index * this.rowHeight;//对换位的项目高度进行变更实现移动效果\n\t\t\tthis.count = 0;\n\t\t},\n\n        //初始化数据\n\t\tsetList(list) {\n\t\t\tthis.dataList = list.map((item, index) => {\n\t\t\t\tthis.sortIndexList.push(index);\n\t\t\t\treturn {\n\t\t\t\t\t...item,\n\t\t\t\t\tisActive: false,\n\t\t\t\t\ttop: index * this.rowHeight,\n\t\t\t\t\tindex: index\n\t\t\t\t};\n\t\t\t});\n\t\t},\n        //简单深拷贝\n\t\tdeepClone(obj) {\n\t\t\tlet result = {},\n\t\t\t\toClass = this.isClass(obj);\n\t\t\tconsole.log(oClass);\n\t\t\tfor (let key in obj) {\n\t\t\t\tlet copy = obj[key];\n\t\t\t\tif (this.isClass(copy) == 'Object') {\n\t\t\t\t\tresult[key] = arguments.callee(copy);\n\t\t\t\t} else if (this.isClass(copy) == 'Array') {\n\t\t\t\t\tresult[key] = arguments.callee(copy);\n\t\t\t\t} else {\n\t\t\t\t\tresult[key] = obj[key];\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn result;\n\t\t},\n\t\tisClass(o) {\n\t\t\tif (o === null) return 'Null';\n\t\t\tif (o === undefined) return 'Undefined';\n\t\t\treturn Object.prototype.toString.call(o).slice(8, -1);\n\t\t}\n\t},\n\tmounted() {},\n\tcomputed: {\n\t\trowHeight() {\n\t\t\tconst res = uni.getSystemInfoSync();\n\t\t\tlet screenWidth = res.screenWidth;\n\t\t\tif (this.itemHeight) {\n\t\t\t\treturn (this.itemHeight * screenWidth) / 750;\n\t\t\t} else {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t}\n};\n```\n```css\n.drag-box {\n\twidth: 100%;\n\theight: 100%;\n\tposition: relative;\n\t.drag-item {\n\t\twidth: 100%;\n\t\ttext-align: center;\n\t\ttransition: all 0.5s;\n\t\tbackground-color: #fff;\n\t\tz-index: 1;\n\t\tborder-bottom: 1rpx solid #f5f5f5;\n\t\tposition: absolute;\n\t}\n}\n.drag-active {\n\tbox-shadow: 0 8px 20px 0 #e6e6e6;\n\ttransform: scale(1.1);\n\tz-index: 9 !important;\n\ttransition: box-shadow 0.5s, transform 0.5s, top 0s !important;\n}\n```\n","source":"_posts/封装一个uniapp列表拖拽排序组件.md","raw":"---\ntitle: 封装一个uniapp列表拖拽排序组件\ncatalog: true\ntoc_nav_num: true\ndate: 2021-09-04 21:46:27\ncategories:\n- 微信小程序\ntags:\n- 工作中遇到的问题\n- 拖拽排序\n- uniapp\n---\n\n### 封装思路\n1. 渲染列表使用`absolute`布局，然后拖拽时对各个项目的高度进行动态变更;\n2. 利用`longtap`事件，监听开启对某个项目的拖拽状态;\n3. 利用`touchmove`事件，对拖拽的高度进行实时监听;\n4. 利用`touchend`事件，对原数组进行重排并输出;\n \n\n### 代码实现 \n直接贴代码，注释讲解\n```html\n<template>\n\t<view class=\"drag-box\" :style=\"{ height: list.length * itemHeight + 'rpx' }\">\n\t\t<view\n\t\t\tv-for=\"(item, index) in dataList\"\n\t\t\t:key=\"index\"\n\t\t\t:style=\"{ top: item.top + 'px', height: itemHeight - 1 + 'rpx' }\"\n\t\t\tclass=\"drag-item\"\n\t\t\t:class=\"{ 'drag-active': item.isActive }\"\n\t\t\t@longtap=\"longtap(item)\"\n\t\t\t@touchstart=\"touchstart\"\n\t\t\t@touchmove.stop.prevent=\"touchmove\"\n\t\t\t@touchend=\"touchend(item)\"\n\t\t>\n\t\t\t<slot :item=\"item\"></slot>\n\t\t</view>\n\t</view>\n</template>\n```\njs\n```js\nexport default {\n\tprops: {\n\t\tlist: {//项目数组\n\t\t\ttype: Array,\n\t\t\tdefault: () => []\n\t\t},\n\t\titemHeight: { //项目高度 为了方便拖拽计算，对列表的每一项使用了固定高度。\n\t\t\ttype: [Number],\n\t\t\tdefault: 70\n\t\t}\n\t},\n\tdata() {\n\t\treturn {\n\t\t\tactiveItem: null,//当前拖拽中的项目\n\t\t\tisDrag: false,\n\t\t\tdragTargetY: 0,//拖拽开始时记录第一次点击高度\n\t\t\tdataList: [],\n\t\t\tsortIndexList: []\n\t\t};\n\t},\n\twatch: {\n\t\tlist: {\n\t\t\timmediate: true,\n\t\t\tdeep: true,\n\t\t\thandler(list) {\n\t\t\t\tthis.setList(list);\n\t\t\t}\n\t\t}\n\t},\n\tmethods: {\n        // 拖拽前记录一下高度\n\t\ttouchstart(e) {\n\t\t\tconsole.log('touchstart', e);\n\t\t\tthis.dragTargetY = e.touches[0].pageY;//记录点击的屏幕位置\n\t\t},\n        //长按项目开启拖拽\n\t\tlongtap(item) {\n\t\t\tthis.activeItem = item;\n\t\t\tthis.isDrag = true;\n\t\t\titem.isActive = true;\n\t\t},\n\n        //拖拽过程event\n\t\ttouchmove(e) {\n\t\t\tif (!this.isDrag) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tlet newY = e.touches[0].pageY;\n\t\t\tlet d = newY - this.dragTargetY;//计算偏移高度\n\t\t\tthis.activeItem.top += d; //对拖拽项目的top进行变更实现跟手效果\n\n\t\t\tlet prevIndex = this.sortIndexList[this.activeItem.index] - 1;//找出上一个项目\n\t\t\tlet nextIndex = this.sortIndexList[this.activeItem.index] + 1;//找出下一个项目\n\t\t\tif (prevIndex >= 0 && d < 0) {\n\t\t\t\tlet item = this.getItemByIndex(prevIndex);//\n\t\t\t\tif (this.activeItem.top < item.top) {//如果拖拽往上的距离超过了上一个项目的top，则进行换位逻辑\n\t\t\t\t\tthis.swapArray(item);//换位\n\t\t\t\t}\n\t\t\t} else if (nextIndex < this.list.length && d > 0) {\n\t\t\t\tlet item = this.getItemByIndex(nextIndex);\n\t\t\t\tif (this.activeItem.top > item.top) {\n\t\t\t\t\tthis.swapArray(item);\n\t\t\t\t}\n\t\t\t} \n\t\t\tthis.dragTargetY = newY;\n\t\t},\n\n        //拖拽结束，根据每个项目的结果index重排处理数据输出新列表\n\t\ttouchend(item) {\n\t\t\tif (!this.isDrag) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tthis.isDrag = false;\n\t\t\titem.isActive = false;\n\t\t\tthis.activeItem.top = this.sortIndexList[this.activeItem.index] * this.rowHeight;\n\t\t\tlet sortList = [];\n\t\t\tArray(this.dataList.length)\n\t\t\t\t.fill(0)\n\t\t\t\t.forEach((v, index) => {\n\t\t\t\t\tlet tempObj = this.deepClone(this.getItemByIndex(index));\n\t\t\t\t\tdelete tempObj.isActive;\n\t\t\t\t\tdelete tempObj.top;\n\t\t\t\t\tdelete tempObj.index;\n\t\t\t\t\tsortList.push(tempObj);\n\t\t\t\t});\n\t\t\tthis.$emit('change', sortList);\n\t\t},\n\t\tgetItemByIndex(index) {\n\t\t\tfor (let i = 0; i < this.sortIndexList.length; i++) {\n\t\t\t\tif (this.sortIndexList[i] === index) {\n\t\t\t\t\treturn this.dataList[i];\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn null;\n\t\t},\n        //换位操作\n\t\tswapArray(item) { \n\t\t\t//列表中两个元素交换位置\n\t\t\tlet index = this.sortIndexList[this.activeItem.index];\n\t\t\tthis.sortIndexList[this.activeItem.index] = this.sortIndexList[item.index];\n\t\t\tthis.sortIndexList[item.index] = index;\n\t\t\titem.top = index * this.rowHeight;//对换位的项目高度进行变更实现移动效果\n\t\t\tthis.count = 0;\n\t\t},\n\n        //初始化数据\n\t\tsetList(list) {\n\t\t\tthis.dataList = list.map((item, index) => {\n\t\t\t\tthis.sortIndexList.push(index);\n\t\t\t\treturn {\n\t\t\t\t\t...item,\n\t\t\t\t\tisActive: false,\n\t\t\t\t\ttop: index * this.rowHeight,\n\t\t\t\t\tindex: index\n\t\t\t\t};\n\t\t\t});\n\t\t},\n        //简单深拷贝\n\t\tdeepClone(obj) {\n\t\t\tlet result = {},\n\t\t\t\toClass = this.isClass(obj);\n\t\t\tconsole.log(oClass);\n\t\t\tfor (let key in obj) {\n\t\t\t\tlet copy = obj[key];\n\t\t\t\tif (this.isClass(copy) == 'Object') {\n\t\t\t\t\tresult[key] = arguments.callee(copy);\n\t\t\t\t} else if (this.isClass(copy) == 'Array') {\n\t\t\t\t\tresult[key] = arguments.callee(copy);\n\t\t\t\t} else {\n\t\t\t\t\tresult[key] = obj[key];\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn result;\n\t\t},\n\t\tisClass(o) {\n\t\t\tif (o === null) return 'Null';\n\t\t\tif (o === undefined) return 'Undefined';\n\t\t\treturn Object.prototype.toString.call(o).slice(8, -1);\n\t\t}\n\t},\n\tmounted() {},\n\tcomputed: {\n\t\trowHeight() {\n\t\t\tconst res = uni.getSystemInfoSync();\n\t\t\tlet screenWidth = res.screenWidth;\n\t\t\tif (this.itemHeight) {\n\t\t\t\treturn (this.itemHeight * screenWidth) / 750;\n\t\t\t} else {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t}\n};\n```\n```css\n.drag-box {\n\twidth: 100%;\n\theight: 100%;\n\tposition: relative;\n\t.drag-item {\n\t\twidth: 100%;\n\t\ttext-align: center;\n\t\ttransition: all 0.5s;\n\t\tbackground-color: #fff;\n\t\tz-index: 1;\n\t\tborder-bottom: 1rpx solid #f5f5f5;\n\t\tposition: absolute;\n\t}\n}\n.drag-active {\n\tbox-shadow: 0 8px 20px 0 #e6e6e6;\n\ttransform: scale(1.1);\n\tz-index: 9 !important;\n\ttransition: box-shadow 0.5s, transform 0.5s, top 0s !important;\n}\n```\n","slug":"封装一个uniapp列表拖拽排序组件","published":1,"updated":"2022-04-20T16:07:49.756Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl27vhg5k000eu8q5wu3aehgs","content":"<h3 id=\"封装思路\">封装思路</h3>\n<ol>\n<li>渲染列表使用<code>absolute</code>布局，然后拖拽时对各个项目的高度进行动态变更;</li>\n<li>利用<code>longtap</code>事件，监听开启对某个项目的拖拽状态;</li>\n<li>利用<code>touchmove</code>事件，对拖拽的高度进行实时监听;</li>\n<li>利用<code>touchend</code>事件，对原数组进行重排并输出;</li>\n</ol>\n<h3 id=\"代码实现\">代码实现</h3>\n<p>直接贴代码，注释讲解</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">template</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">view</span> <span class=\"attr\">class</span>=<span class=\"string\">\"drag-box\"</span> <span class=\"attr\">:style</span>=<span class=\"string\">\"&#123; height: list.length * itemHeight + 'rpx' &#125;\"</span>&gt;</span></span><br><span class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">view</span></span></span><br><span class=\"line\"><span class=\"tag\">\t\t\t<span class=\"attr\">v-for</span>=<span class=\"string\">\"(item, index) in dataList\"</span></span></span><br><span class=\"line\"><span class=\"tag\">\t\t\t<span class=\"attr\">:key</span>=<span class=\"string\">\"index\"</span></span></span><br><span class=\"line\"><span class=\"tag\">\t\t\t<span class=\"attr\">:style</span>=<span class=\"string\">\"&#123; top: item.top + 'px', height: itemHeight - 1 + 'rpx' &#125;\"</span></span></span><br><span class=\"line\"><span class=\"tag\">\t\t\t<span class=\"attr\">class</span>=<span class=\"string\">\"drag-item\"</span></span></span><br><span class=\"line\"><span class=\"tag\">\t\t\t<span class=\"attr\">:class</span>=<span class=\"string\">\"&#123; 'drag-active': item.isActive &#125;\"</span></span></span><br><span class=\"line\"><span class=\"tag\">\t\t\t@<span class=\"attr\">longtap</span>=<span class=\"string\">\"longtap(item)\"</span></span></span><br><span class=\"line\"><span class=\"tag\">\t\t\t@<span class=\"attr\">touchstart</span>=<span class=\"string\">\"touchstart\"</span></span></span><br><span class=\"line\"><span class=\"tag\">\t\t\t@<span class=\"attr\">touchmove.stop.prevent</span>=<span class=\"string\">\"touchmove\"</span></span></span><br><span class=\"line\"><span class=\"tag\">\t\t\t@<span class=\"attr\">touchend</span>=<span class=\"string\">\"touchend(item)\"</span></span></span><br><span class=\"line\"><span class=\"tag\">\t\t&gt;</span></span><br><span class=\"line\">\t\t\t<span class=\"tag\">&lt;<span class=\"name\">slot</span> <span class=\"attr\">:item</span>=<span class=\"string\">\"item\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">slot</span>&gt;</span></span><br><span class=\"line\">\t\t<span class=\"tag\">&lt;/<span class=\"name\">view</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;/<span class=\"name\">view</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">template</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>js</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> &#123;</span><br><span class=\"line\">\tprops: &#123;</span><br><span class=\"line\">\t\tlist: &#123;<span class=\"comment\">//项目数组</span></span><br><span class=\"line\">\t\t\ttype: <span class=\"built_in\">Array</span>,</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">default</span>: <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> []</span><br><span class=\"line\">\t\t&#125;,</span><br><span class=\"line\">\t\titemHeight: &#123; <span class=\"comment\">//项目高度 为了方便拖拽计算，对列表的每一项使用了固定高度。</span></span><br><span class=\"line\">\t\t\ttype: [<span class=\"built_in\">Number</span>],</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">default</span>: <span class=\"number\">70</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;,</span><br><span class=\"line\">\tdata() &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">\t\t\tactiveItem: <span class=\"literal\">null</span>,<span class=\"comment\">//当前拖拽中的项目</span></span><br><span class=\"line\">\t\t\tisDrag: <span class=\"literal\">false</span>,</span><br><span class=\"line\">\t\t\tdragTargetY: <span class=\"number\">0</span>,<span class=\"comment\">//拖拽开始时记录第一次点击高度</span></span><br><span class=\"line\">\t\t\tdataList: [],</span><br><span class=\"line\">\t\t\tsortIndexList: []</span><br><span class=\"line\">\t\t&#125;;</span><br><span class=\"line\">\t&#125;,</span><br><span class=\"line\">\twatch: &#123;</span><br><span class=\"line\">\t\tlist: &#123;</span><br><span class=\"line\">\t\t\timmediate: <span class=\"literal\">true</span>,</span><br><span class=\"line\">\t\t\tdeep: <span class=\"literal\">true</span>,</span><br><span class=\"line\">\t\t\thandler(list) &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">this</span>.setList(list);</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;,</span><br><span class=\"line\">\tmethods: &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 拖拽前记录一下高度</span></span><br><span class=\"line\">\t\ttouchstart(e) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">console</span>.log(<span class=\"string\">'touchstart'</span>, e);</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">this</span>.dragTargetY = e.touches[<span class=\"number\">0</span>].pageY;<span class=\"comment\">//记录点击的屏幕位置</span></span><br><span class=\"line\">\t\t&#125;,</span><br><span class=\"line\">        <span class=\"comment\">//长按项目开启拖拽</span></span><br><span class=\"line\">\t\tlongtap(item) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">this</span>.activeItem = item;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">this</span>.isDrag = <span class=\"literal\">true</span>;</span><br><span class=\"line\">\t\t\titem.isActive = <span class=\"literal\">true</span>;</span><br><span class=\"line\">\t\t&#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//拖拽过程event</span></span><br><span class=\"line\">\t\ttouchmove(e) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (!<span class=\"keyword\">this</span>.isDrag) &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">return</span>;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">let</span> newY = e.touches[<span class=\"number\">0</span>].pageY;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">let</span> d = newY - <span class=\"keyword\">this</span>.dragTargetY;<span class=\"comment\">//计算偏移高度</span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">this</span>.activeItem.top += d; <span class=\"comment\">//对拖拽项目的top进行变更实现跟手效果</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">let</span> prevIndex = <span class=\"keyword\">this</span>.sortIndexList[<span class=\"keyword\">this</span>.activeItem.index] - <span class=\"number\">1</span>;<span class=\"comment\">//找出上一个项目</span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">let</span> nextIndex = <span class=\"keyword\">this</span>.sortIndexList[<span class=\"keyword\">this</span>.activeItem.index] + <span class=\"number\">1</span>;<span class=\"comment\">//找出下一个项目</span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (prevIndex &gt;= <span class=\"number\">0</span> &amp;&amp; d &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">let</span> item = <span class=\"keyword\">this</span>.getItemByIndex(prevIndex);<span class=\"comment\">//</span></span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.activeItem.top &lt; item.top) &#123;<span class=\"comment\">//如果拖拽往上的距离超过了上一个项目的top，则进行换位逻辑</span></span><br><span class=\"line\">\t\t\t\t\t<span class=\"keyword\">this</span>.swapArray(item);<span class=\"comment\">//换位</span></span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t&#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (nextIndex &lt; <span class=\"keyword\">this</span>.list.length &amp;&amp; d &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">let</span> item = <span class=\"keyword\">this</span>.getItemByIndex(nextIndex);</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.activeItem.top &gt; item.top) &#123;</span><br><span class=\"line\">\t\t\t\t\t<span class=\"keyword\">this</span>.swapArray(item);</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t&#125; </span><br><span class=\"line\">\t\t\t<span class=\"keyword\">this</span>.dragTargetY = newY;</span><br><span class=\"line\">\t\t&#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//拖拽结束，根据每个项目的结果index重排处理数据输出新列表</span></span><br><span class=\"line\">\t\ttouchend(item) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (!<span class=\"keyword\">this</span>.isDrag) &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">return</span>;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">this</span>.isDrag = <span class=\"literal\">false</span>;</span><br><span class=\"line\">\t\t\titem.isActive = <span class=\"literal\">false</span>;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">this</span>.activeItem.top = <span class=\"keyword\">this</span>.sortIndexList[<span class=\"keyword\">this</span>.activeItem.index] * <span class=\"keyword\">this</span>.rowHeight;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">let</span> sortList = [];</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">Array</span>(<span class=\"keyword\">this</span>.dataList.length)</span><br><span class=\"line\">\t\t\t\t.fill(<span class=\"number\">0</span>)</span><br><span class=\"line\">\t\t\t\t.forEach(<span class=\"function\">(<span class=\"params\">v, index</span>) =&gt;</span> &#123;</span><br><span class=\"line\">\t\t\t\t\t<span class=\"keyword\">let</span> tempObj = <span class=\"keyword\">this</span>.deepClone(<span class=\"keyword\">this</span>.getItemByIndex(index));</span><br><span class=\"line\">\t\t\t\t\t<span class=\"keyword\">delete</span> tempObj.isActive;</span><br><span class=\"line\">\t\t\t\t\t<span class=\"keyword\">delete</span> tempObj.top;</span><br><span class=\"line\">\t\t\t\t\t<span class=\"keyword\">delete</span> tempObj.index;</span><br><span class=\"line\">\t\t\t\t\tsortList.push(tempObj);</span><br><span class=\"line\">\t\t\t\t&#125;);</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">this</span>.$emit(<span class=\"string\">'change'</span>, sortList);</span><br><span class=\"line\">\t\t&#125;,</span><br><span class=\"line\">\t\tgetItemByIndex(index) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"keyword\">this</span>.sortIndexList.length; i++) &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.sortIndexList[i] === index) &#123;</span><br><span class=\"line\">\t\t\t\t\t<span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.dataList[i];</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">\t\t&#125;,</span><br><span class=\"line\">        <span class=\"comment\">//换位操作</span></span><br><span class=\"line\">\t\tswapArray(item) &#123; </span><br><span class=\"line\">\t\t\t<span class=\"comment\">//列表中两个元素交换位置</span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">let</span> index = <span class=\"keyword\">this</span>.sortIndexList[<span class=\"keyword\">this</span>.activeItem.index];</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">this</span>.sortIndexList[<span class=\"keyword\">this</span>.activeItem.index] = <span class=\"keyword\">this</span>.sortIndexList[item.index];</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">this</span>.sortIndexList[item.index] = index;</span><br><span class=\"line\">\t\t\titem.top = index * <span class=\"keyword\">this</span>.rowHeight;<span class=\"comment\">//对换位的项目高度进行变更实现移动效果</span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">this</span>.count = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\t&#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//初始化数据</span></span><br><span class=\"line\">\t\tsetList(list) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">this</span>.dataList = list.map(<span class=\"function\">(<span class=\"params\">item, index</span>) =&gt;</span> &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">this</span>.sortIndexList.push(index);</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">\t\t\t\t\t...item,</span><br><span class=\"line\">\t\t\t\t\tisActive: <span class=\"literal\">false</span>,</span><br><span class=\"line\">\t\t\t\t\ttop: index * <span class=\"keyword\">this</span>.rowHeight,</span><br><span class=\"line\">\t\t\t\t\tindex: index</span><br><span class=\"line\">\t\t\t\t&#125;;</span><br><span class=\"line\">\t\t\t&#125;);</span><br><span class=\"line\">\t\t&#125;,</span><br><span class=\"line\">        <span class=\"comment\">//简单深拷贝</span></span><br><span class=\"line\">\t\tdeepClone(obj) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">let</span> result = &#123;&#125;,</span><br><span class=\"line\">\t\t\t\toClass = <span class=\"keyword\">this</span>.isClass(obj);</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">console</span>.log(oClass);</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> key <span class=\"keyword\">in</span> obj) &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">let</span> copy = obj[key];</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.isClass(copy) == <span class=\"string\">'Object'</span>) &#123;</span><br><span class=\"line\">\t\t\t\t\tresult[key] = <span class=\"built_in\">arguments</span>.callee(copy);</span><br><span class=\"line\">\t\t\t\t&#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.isClass(copy) == <span class=\"string\">'Array'</span>) &#123;</span><br><span class=\"line\">\t\t\t\t\tresult[key] = <span class=\"built_in\">arguments</span>.callee(copy);</span><br><span class=\"line\">\t\t\t\t&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t\t\t\tresult[key] = obj[key];</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> result;</span><br><span class=\"line\">\t\t&#125;,</span><br><span class=\"line\">\t\tisClass(o) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (o === <span class=\"literal\">null</span>) <span class=\"keyword\">return</span> <span class=\"string\">'Null'</span>;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (o === <span class=\"literal\">undefined</span>) <span class=\"keyword\">return</span> <span class=\"string\">'Undefined'</span>;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> <span class=\"built_in\">Object</span>.prototype.toString.call(o).slice(<span class=\"number\">8</span>, <span class=\"number\">-1</span>);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;,</span><br><span class=\"line\">\tmounted() &#123;&#125;,</span><br><span class=\"line\">\tcomputed: &#123;</span><br><span class=\"line\">\t\trowHeight() &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">const</span> res = uni.getSystemInfoSync();</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">let</span> screenWidth = res.screenWidth;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.itemHeight) &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">return</span> (<span class=\"keyword\">this</span>.itemHeight * screenWidth) / <span class=\"number\">750</span>;</span><br><span class=\"line\">\t\t\t&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.drag-box</span> &#123;</span><br><span class=\"line\">\t<span class=\"attribute\">width</span>: <span class=\"number\">100%</span>;</span><br><span class=\"line\">\t<span class=\"attribute\">height</span>: <span class=\"number\">100%</span>;</span><br><span class=\"line\">\t<span class=\"attribute\">position</span>: relative;</span><br><span class=\"line\">\t.drag-item &#123;</span><br><span class=\"line\">\t\t<span class=\"selector-tag\">width</span>: 100%;</span><br><span class=\"line\">\t\t<span class=\"selector-tag\">text-align</span>: <span class=\"selector-tag\">center</span>;</span><br><span class=\"line\">\t\t<span class=\"selector-tag\">transition</span>: <span class=\"selector-tag\">all</span> 0<span class=\"selector-class\">.5s</span>;</span><br><span class=\"line\">\t\t<span class=\"selector-tag\">background-color</span>: <span class=\"selector-id\">#fff</span>;</span><br><span class=\"line\">\t\t<span class=\"selector-tag\">z-index</span>: 1;</span><br><span class=\"line\">\t\t<span class=\"selector-tag\">border-bottom</span>: 1<span class=\"selector-tag\">rpx</span> <span class=\"selector-tag\">solid</span> <span class=\"selector-id\">#f5f5f5</span>;</span><br><span class=\"line\">\t\t<span class=\"selector-tag\">position</span>: <span class=\"selector-tag\">absolute</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-class\">.drag-active</span> &#123;</span><br><span class=\"line\">\t<span class=\"attribute\">box-shadow</span>: <span class=\"number\">0</span> <span class=\"number\">8px</span> <span class=\"number\">20px</span> <span class=\"number\">0</span> <span class=\"number\">#e6e6e6</span>;</span><br><span class=\"line\">\t<span class=\"attribute\">transform</span>: <span class=\"built_in\">scale</span>(<span class=\"number\">1.1</span>);</span><br><span class=\"line\">\t<span class=\"attribute\">z-index</span>: <span class=\"number\">9</span> <span class=\"meta\">!important</span>;</span><br><span class=\"line\">\t<span class=\"attribute\">transition</span>: box-shadow <span class=\"number\">0.5s</span>, transform <span class=\"number\">0.5s</span>, top <span class=\"number\">0s</span> <span class=\"meta\">!important</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<h3>封装思路</h3>\n<ol>\n<li>渲染列表使用<code>absolute</code>布局，然后拖拽时对各个项目的高度进行动态变更;</li>\n<li>利用<code>longtap</code>事件，监听开启对某个项目的拖拽状态;</li>\n<li>利用<code>touchmove</code>事件，对拖拽的高度进行实时监听;</li>\n<li>利用<code>touchend</code>事件，对原数组进行重排并输出;</li>\n</ol>\n<h3>代码实现</h3>\n<p>直接贴代码，注释讲解</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">template</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">view</span> <span class=\"attr\">class</span>=<span class=\"string\">\"drag-box\"</span> <span class=\"attr\">:style</span>=<span class=\"string\">\"&#123; height: list.length * itemHeight + 'rpx' &#125;\"</span>&gt;</span></span><br><span class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">view</span></span></span><br><span class=\"line\"><span class=\"tag\">\t\t\t<span class=\"attr\">v-for</span>=<span class=\"string\">\"(item, index) in dataList\"</span></span></span><br><span class=\"line\"><span class=\"tag\">\t\t\t<span class=\"attr\">:key</span>=<span class=\"string\">\"index\"</span></span></span><br><span class=\"line\"><span class=\"tag\">\t\t\t<span class=\"attr\">:style</span>=<span class=\"string\">\"&#123; top: item.top + 'px', height: itemHeight - 1 + 'rpx' &#125;\"</span></span></span><br><span class=\"line\"><span class=\"tag\">\t\t\t<span class=\"attr\">class</span>=<span class=\"string\">\"drag-item\"</span></span></span><br><span class=\"line\"><span class=\"tag\">\t\t\t<span class=\"attr\">:class</span>=<span class=\"string\">\"&#123; 'drag-active': item.isActive &#125;\"</span></span></span><br><span class=\"line\"><span class=\"tag\">\t\t\t@<span class=\"attr\">longtap</span>=<span class=\"string\">\"longtap(item)\"</span></span></span><br><span class=\"line\"><span class=\"tag\">\t\t\t@<span class=\"attr\">touchstart</span>=<span class=\"string\">\"touchstart\"</span></span></span><br><span class=\"line\"><span class=\"tag\">\t\t\t@<span class=\"attr\">touchmove.stop.prevent</span>=<span class=\"string\">\"touchmove\"</span></span></span><br><span class=\"line\"><span class=\"tag\">\t\t\t@<span class=\"attr\">touchend</span>=<span class=\"string\">\"touchend(item)\"</span></span></span><br><span class=\"line\"><span class=\"tag\">\t\t&gt;</span></span><br><span class=\"line\">\t\t\t<span class=\"tag\">&lt;<span class=\"name\">slot</span> <span class=\"attr\">:item</span>=<span class=\"string\">\"item\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">slot</span>&gt;</span></span><br><span class=\"line\">\t\t<span class=\"tag\">&lt;/<span class=\"name\">view</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;/<span class=\"name\">view</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">template</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>js</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> &#123;</span><br><span class=\"line\">\tprops: &#123;</span><br><span class=\"line\">\t\tlist: &#123;<span class=\"comment\">//项目数组</span></span><br><span class=\"line\">\t\t\ttype: <span class=\"built_in\">Array</span>,</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">default</span>: <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> []</span><br><span class=\"line\">\t\t&#125;,</span><br><span class=\"line\">\t\titemHeight: &#123; <span class=\"comment\">//项目高度 为了方便拖拽计算，对列表的每一项使用了固定高度。</span></span><br><span class=\"line\">\t\t\ttype: [<span class=\"built_in\">Number</span>],</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">default</span>: <span class=\"number\">70</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;,</span><br><span class=\"line\">\tdata() &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">\t\t\tactiveItem: <span class=\"literal\">null</span>,<span class=\"comment\">//当前拖拽中的项目</span></span><br><span class=\"line\">\t\t\tisDrag: <span class=\"literal\">false</span>,</span><br><span class=\"line\">\t\t\tdragTargetY: <span class=\"number\">0</span>,<span class=\"comment\">//拖拽开始时记录第一次点击高度</span></span><br><span class=\"line\">\t\t\tdataList: [],</span><br><span class=\"line\">\t\t\tsortIndexList: []</span><br><span class=\"line\">\t\t&#125;;</span><br><span class=\"line\">\t&#125;,</span><br><span class=\"line\">\twatch: &#123;</span><br><span class=\"line\">\t\tlist: &#123;</span><br><span class=\"line\">\t\t\timmediate: <span class=\"literal\">true</span>,</span><br><span class=\"line\">\t\t\tdeep: <span class=\"literal\">true</span>,</span><br><span class=\"line\">\t\t\thandler(list) &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">this</span>.setList(list);</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;,</span><br><span class=\"line\">\tmethods: &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 拖拽前记录一下高度</span></span><br><span class=\"line\">\t\ttouchstart(e) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">console</span>.log(<span class=\"string\">'touchstart'</span>, e);</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">this</span>.dragTargetY = e.touches[<span class=\"number\">0</span>].pageY;<span class=\"comment\">//记录点击的屏幕位置</span></span><br><span class=\"line\">\t\t&#125;,</span><br><span class=\"line\">        <span class=\"comment\">//长按项目开启拖拽</span></span><br><span class=\"line\">\t\tlongtap(item) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">this</span>.activeItem = item;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">this</span>.isDrag = <span class=\"literal\">true</span>;</span><br><span class=\"line\">\t\t\titem.isActive = <span class=\"literal\">true</span>;</span><br><span class=\"line\">\t\t&#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//拖拽过程event</span></span><br><span class=\"line\">\t\ttouchmove(e) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (!<span class=\"keyword\">this</span>.isDrag) &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">return</span>;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">let</span> newY = e.touches[<span class=\"number\">0</span>].pageY;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">let</span> d = newY - <span class=\"keyword\">this</span>.dragTargetY;<span class=\"comment\">//计算偏移高度</span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">this</span>.activeItem.top += d; <span class=\"comment\">//对拖拽项目的top进行变更实现跟手效果</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">let</span> prevIndex = <span class=\"keyword\">this</span>.sortIndexList[<span class=\"keyword\">this</span>.activeItem.index] - <span class=\"number\">1</span>;<span class=\"comment\">//找出上一个项目</span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">let</span> nextIndex = <span class=\"keyword\">this</span>.sortIndexList[<span class=\"keyword\">this</span>.activeItem.index] + <span class=\"number\">1</span>;<span class=\"comment\">//找出下一个项目</span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (prevIndex &gt;= <span class=\"number\">0</span> &amp;&amp; d &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">let</span> item = <span class=\"keyword\">this</span>.getItemByIndex(prevIndex);<span class=\"comment\">//</span></span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.activeItem.top &lt; item.top) &#123;<span class=\"comment\">//如果拖拽往上的距离超过了上一个项目的top，则进行换位逻辑</span></span><br><span class=\"line\">\t\t\t\t\t<span class=\"keyword\">this</span>.swapArray(item);<span class=\"comment\">//换位</span></span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t&#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (nextIndex &lt; <span class=\"keyword\">this</span>.list.length &amp;&amp; d &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">let</span> item = <span class=\"keyword\">this</span>.getItemByIndex(nextIndex);</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.activeItem.top &gt; item.top) &#123;</span><br><span class=\"line\">\t\t\t\t\t<span class=\"keyword\">this</span>.swapArray(item);</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t&#125; </span><br><span class=\"line\">\t\t\t<span class=\"keyword\">this</span>.dragTargetY = newY;</span><br><span class=\"line\">\t\t&#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//拖拽结束，根据每个项目的结果index重排处理数据输出新列表</span></span><br><span class=\"line\">\t\ttouchend(item) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (!<span class=\"keyword\">this</span>.isDrag) &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">return</span>;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">this</span>.isDrag = <span class=\"literal\">false</span>;</span><br><span class=\"line\">\t\t\titem.isActive = <span class=\"literal\">false</span>;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">this</span>.activeItem.top = <span class=\"keyword\">this</span>.sortIndexList[<span class=\"keyword\">this</span>.activeItem.index] * <span class=\"keyword\">this</span>.rowHeight;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">let</span> sortList = [];</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">Array</span>(<span class=\"keyword\">this</span>.dataList.length)</span><br><span class=\"line\">\t\t\t\t.fill(<span class=\"number\">0</span>)</span><br><span class=\"line\">\t\t\t\t.forEach(<span class=\"function\">(<span class=\"params\">v, index</span>) =&gt;</span> &#123;</span><br><span class=\"line\">\t\t\t\t\t<span class=\"keyword\">let</span> tempObj = <span class=\"keyword\">this</span>.deepClone(<span class=\"keyword\">this</span>.getItemByIndex(index));</span><br><span class=\"line\">\t\t\t\t\t<span class=\"keyword\">delete</span> tempObj.isActive;</span><br><span class=\"line\">\t\t\t\t\t<span class=\"keyword\">delete</span> tempObj.top;</span><br><span class=\"line\">\t\t\t\t\t<span class=\"keyword\">delete</span> tempObj.index;</span><br><span class=\"line\">\t\t\t\t\tsortList.push(tempObj);</span><br><span class=\"line\">\t\t\t\t&#125;);</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">this</span>.$emit(<span class=\"string\">'change'</span>, sortList);</span><br><span class=\"line\">\t\t&#125;,</span><br><span class=\"line\">\t\tgetItemByIndex(index) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"keyword\">this</span>.sortIndexList.length; i++) &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.sortIndexList[i] === index) &#123;</span><br><span class=\"line\">\t\t\t\t\t<span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.dataList[i];</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">\t\t&#125;,</span><br><span class=\"line\">        <span class=\"comment\">//换位操作</span></span><br><span class=\"line\">\t\tswapArray(item) &#123; </span><br><span class=\"line\">\t\t\t<span class=\"comment\">//列表中两个元素交换位置</span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">let</span> index = <span class=\"keyword\">this</span>.sortIndexList[<span class=\"keyword\">this</span>.activeItem.index];</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">this</span>.sortIndexList[<span class=\"keyword\">this</span>.activeItem.index] = <span class=\"keyword\">this</span>.sortIndexList[item.index];</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">this</span>.sortIndexList[item.index] = index;</span><br><span class=\"line\">\t\t\titem.top = index * <span class=\"keyword\">this</span>.rowHeight;<span class=\"comment\">//对换位的项目高度进行变更实现移动效果</span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">this</span>.count = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\t&#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//初始化数据</span></span><br><span class=\"line\">\t\tsetList(list) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">this</span>.dataList = list.map(<span class=\"function\">(<span class=\"params\">item, index</span>) =&gt;</span> &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">this</span>.sortIndexList.push(index);</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">\t\t\t\t\t...item,</span><br><span class=\"line\">\t\t\t\t\tisActive: <span class=\"literal\">false</span>,</span><br><span class=\"line\">\t\t\t\t\ttop: index * <span class=\"keyword\">this</span>.rowHeight,</span><br><span class=\"line\">\t\t\t\t\tindex: index</span><br><span class=\"line\">\t\t\t\t&#125;;</span><br><span class=\"line\">\t\t\t&#125;);</span><br><span class=\"line\">\t\t&#125;,</span><br><span class=\"line\">        <span class=\"comment\">//简单深拷贝</span></span><br><span class=\"line\">\t\tdeepClone(obj) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">let</span> result = &#123;&#125;,</span><br><span class=\"line\">\t\t\t\toClass = <span class=\"keyword\">this</span>.isClass(obj);</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">console</span>.log(oClass);</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> key <span class=\"keyword\">in</span> obj) &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">let</span> copy = obj[key];</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.isClass(copy) == <span class=\"string\">'Object'</span>) &#123;</span><br><span class=\"line\">\t\t\t\t\tresult[key] = <span class=\"built_in\">arguments</span>.callee(copy);</span><br><span class=\"line\">\t\t\t\t&#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.isClass(copy) == <span class=\"string\">'Array'</span>) &#123;</span><br><span class=\"line\">\t\t\t\t\tresult[key] = <span class=\"built_in\">arguments</span>.callee(copy);</span><br><span class=\"line\">\t\t\t\t&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t\t\t\tresult[key] = obj[key];</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> result;</span><br><span class=\"line\">\t\t&#125;,</span><br><span class=\"line\">\t\tisClass(o) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (o === <span class=\"literal\">null</span>) <span class=\"keyword\">return</span> <span class=\"string\">'Null'</span>;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (o === <span class=\"literal\">undefined</span>) <span class=\"keyword\">return</span> <span class=\"string\">'Undefined'</span>;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> <span class=\"built_in\">Object</span>.prototype.toString.call(o).slice(<span class=\"number\">8</span>, <span class=\"number\">-1</span>);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;,</span><br><span class=\"line\">\tmounted() &#123;&#125;,</span><br><span class=\"line\">\tcomputed: &#123;</span><br><span class=\"line\">\t\trowHeight() &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">const</span> res = uni.getSystemInfoSync();</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">let</span> screenWidth = res.screenWidth;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.itemHeight) &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">return</span> (<span class=\"keyword\">this</span>.itemHeight * screenWidth) / <span class=\"number\">750</span>;</span><br><span class=\"line\">\t\t\t&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.drag-box</span> &#123;</span><br><span class=\"line\">\t<span class=\"attribute\">width</span>: <span class=\"number\">100%</span>;</span><br><span class=\"line\">\t<span class=\"attribute\">height</span>: <span class=\"number\">100%</span>;</span><br><span class=\"line\">\t<span class=\"attribute\">position</span>: relative;</span><br><span class=\"line\">\t.drag-item &#123;</span><br><span class=\"line\">\t\t<span class=\"selector-tag\">width</span>: 100%;</span><br><span class=\"line\">\t\t<span class=\"selector-tag\">text-align</span>: <span class=\"selector-tag\">center</span>;</span><br><span class=\"line\">\t\t<span class=\"selector-tag\">transition</span>: <span class=\"selector-tag\">all</span> 0<span class=\"selector-class\">.5s</span>;</span><br><span class=\"line\">\t\t<span class=\"selector-tag\">background-color</span>: <span class=\"selector-id\">#fff</span>;</span><br><span class=\"line\">\t\t<span class=\"selector-tag\">z-index</span>: 1;</span><br><span class=\"line\">\t\t<span class=\"selector-tag\">border-bottom</span>: 1<span class=\"selector-tag\">rpx</span> <span class=\"selector-tag\">solid</span> <span class=\"selector-id\">#f5f5f5</span>;</span><br><span class=\"line\">\t\t<span class=\"selector-tag\">position</span>: <span class=\"selector-tag\">absolute</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-class\">.drag-active</span> &#123;</span><br><span class=\"line\">\t<span class=\"attribute\">box-shadow</span>: <span class=\"number\">0</span> <span class=\"number\">8px</span> <span class=\"number\">20px</span> <span class=\"number\">0</span> <span class=\"number\">#e6e6e6</span>;</span><br><span class=\"line\">\t<span class=\"attribute\">transform</span>: <span class=\"built_in\">scale</span>(<span class=\"number\">1.1</span>);</span><br><span class=\"line\">\t<span class=\"attribute\">z-index</span>: <span class=\"number\">9</span> <span class=\"meta\">!important</span>;</span><br><span class=\"line\">\t<span class=\"attribute\">transition</span>: box-shadow <span class=\"number\">0.5s</span>, transform <span class=\"number\">0.5s</span>, top <span class=\"number\">0s</span> <span class=\"meta\">!important</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n"},{"title":"从URL输入到页面展现到底发生什么？","catalog":true,"date":"2021-04-22T13:31:20.000Z","subtitle":null,"header-img":null,"_content":" \n## 概述\n从开发&运维角度方面来看，可以分为下几个过程： \n> 解析出协议、主机、端口、路径等信息，并构造一个HTTP请求\n> DNS 解析:将域名解析成 IP 地址\n> TCP 连接：TCP 三次握手\n> 发送 HTTP 请求\n> 服务器处理请求并返回 HTTP 报文\n> 浏览器解析渲染页面\n> 断开连接：TCP 四次挥手\n\n## 前置内容\n浏览器是多进程的，主要分为：\n* 浏览器主进程：只有一个，主要控制页面的创建、销毁、网络资源管理、下载等。\n* 第三方插件进程：每一种类型的插件对应一个进程，仅当使用该插件时才创建。\n* GPU进程：最多一个，用于3D绘制等。\n* 浏览器渲染进程(浏览器内核)：每个Tab页对应一个进程，互不影响。\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6bc05b033f444b4198f0ce6084cc7b52~tplv-k3u1fbpfcp-watermark.awebp)\n\n## 将域名解析成 IP 地址\n### 什么是URL\n\n**URL**（Uniform Resource Locator），统一资源定位符，用于定位互联网上资源，俗称网址。\n\nscheme: // host.domain:port / path / filename ? abc = 123 # 456789\n```\nscheme       - 定义因特网服务的类型。常见的协议有 http、https、ftp、file，\n               其中最常见的类型是 http，而 https 则是进行加密的网络传输。\nhost         - 定义域主机（http 的默认主机是 www）\ndomain       - 定义因特网域名，比如 baidu.com\nport         - 定义主机上的端口号（http 的默认端口号是 80）\npath         - 定义服务器上的路径（如果省略，则文档必须位于网站的根目录中）。\nfilename     - 定义文档/资源的名称\nquery        - 即查询参数\nfragment     - 即 # 后的hash值，一般用来定位到某个位置 (锚点)\n```\n\n### 解析URL\n输入URL后，浏览器会解析出协议、主机、端口、路径等信息，并构造一个HTTP请求\n* 浏览器发送请求前，根据请求头的`expires`和`cache-control`判断是否命中（包括是否过期）`强缓存`策略，如果命中，直接从缓存获取资源，并不会发送请求。如果没有命中，则进入下一步。\n* 没有命中`强缓存`规则，浏览器会发送请求，根据请求头的`If-Modified-Since`和`If-None-Match`判断是否命中`协商缓存`，如果命中，直接从缓存获取资源。如果没有命中，则进入下一步。\n* 如果前两步都没有命中，则直接从服务端获取资源。\n[理解浏览器缓存](http://www.kyootah.com/article/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BC%93%E5%AD%98/)\n\n### DNS域名解析过程\n在浏览器输入网址后，首先要经过域名解析，因为浏览器并不能直接通过域名找到对应的服务器，而是要通过 IP 地址。\n\n**什么是IP地址**\n```\nIP 地址是指互联网协议地址，是 IP Address 的缩写。IP 地址是 IP 协议提供的一种统一的地址格式，\n它为互联网上的每一个网络和每一台主机分配一个逻辑地址，以此来屏蔽物理地址的差异。\n```\n\n**什么是域名解析**\n```\nDNS 协议提供通过域名查找 IP 地址，或逆向从 IP 地址反查域名的服务。\nDNS 是一个网络服务器，我们的域名解析简单来说就是在 DNS 上记录一条信息记录。\n```\n\n**什么是DNS**\n```\nDNS 是：\n一个由分层的 DNS 服务器实现的分布式数据库 \n一个使得主机能够查询分布式数据库的应用层协议 \n```\n\n**浏览器如何通过域名去查询 URL 对应的 IP**\n```\nDNS域名解析分为递归查询和迭代查询两种方式，现一般为迭代查询。\n```\n![](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/2/27/1692e385403c39ab~tplv-t2oaga2asx-watermark.awebp)\n\n### DNS的优化与应用\n1. `DNS缓存` DNS存在着多级缓存，从离浏览器的距离排序的话，有以下几种: **浏览器缓存，系统缓存，路由器缓存，IPS服务器缓存，根域名服务器缓存，顶级域名服务器缓存，主域名服务器缓存**。\n2. `DNS负载均衡(DNS重定向)` DNS负载均衡技术的实现原理是在DNS服务器中为同一个主机名配置多个IP地址，在应答DNS查询时， DNS服务器对每个查询将以DNS文件中主机记录的IP地址按顺序返回不同的解析结果，将客户端的访问 引导到不同的机器上去，使得不同的客户端访问不同的服务器，从而达到负载均衡的目的。\n   **CDN(Content Delivery Network)就是利用DNS的重定向技术，DNS服务器会返回一个跟 用户最接近的点的IP地址给用户，CDN节点的服务器负责响应用户的请求，提供所需的内容**\n3. `dns-prefetch` DNS Prefetch 是一种 DNS 预解析技术。当你浏览网页时，浏览器会在加载网页时对网页中的域名进行解析缓存，这样在你单击当前网页中的连接时就无需进行 DNS 的解析，减少用户等待时间，提高用户体验。\n\n\n## 网络协议分层\n`OSI参考模型`分为7层，`TCP`(Transmission Control Protocol)传输控制协议。 `TCP/IP`**协议将应用层、表示层、会话层合并为应用层，物理层和数据链路层合并为网络接口层。**\n![](http://img.kyootah.com/2022/02/28/ed6068caf7634.png)\n\n## TCP三次握手\n\n```\nSYN(synchronous建立联机)\nACK(acknowledgement 确认)\nPSH(push传送)\nFIN(finish结束)\nRST(reset重置)\nURG(urgent紧急)\n```\n![](http://img.kyootah.com/2022/02/28/a49b152d8390b.png)\n* **第一次握手：由浏览器发起，告诉服务器我要发送请求了**\n`主机A`发送位码为`SYN＝1`，**随机**产生Seq  number=1234567的数据包到服务器，`主机B`由`SYN=1`知道，A要求建立联机；\n* **第二次握手：由服务器发起，告诉浏览器我准备接受了，你赶紧发送吧**\n`主机B`收到请求后要确认联机信息，向A发送ack number=(主机A的seq+1)，SUN=1，ACK=1234567 + 1，**随机**产生Seq=7654321的包；\n* **第三次握手：由浏览器发送，告诉服务器，我马上就发了，准备接受吧**\n`主机A`收到后检查ack number是否正确，即第一次发送的seq number+1，以及位码SYN是否为1，若正确，主机A会再发送ack number=(主机B的seq+1)，ack=7654321 + 1，主机B收到后确认Seq值与ACK=7654321+ 1则连接建立成功；\n\n翻译成大白话就是：\n\n* 客户端：你能接收到我的消息吗？\n* 服务端：可以的，那你能接收到我的回复吗？\n* 客户端：可以，那我们开始聊正事吧。\n为什么是3次？：避免历史连接，确认客户端发来的请求是这次通信的人。\n为什么不是4次？：3次够了第四次浪费\n\n### SYN攻击是什么？\n服务器端的资源分配是在二次握手时分配的，而客户端的资源是在完成三次握手时分配的，所以服务器容易受到`SYN洪泛攻击`。SYN攻击就是Client在短时间内**伪造大量不存在的IP地址**，**并向Server不断地发送SYN包**，Server则回复确认包，并等待Client确认，由于源地址不存在，因此Server需要不断重发直至超时，这些伪造的SYN包将长时间占用未连接队列，导致正常的SYN请求因为队列满而被丢弃，从而引起网络拥塞甚至系统瘫痪。**SYN 攻击是一种典型的 `DoS/DDoS` 攻击**。\n检测 SYN 攻击非常的方便，当你在服务器上看到大量的半连接状态时，特别是源IP地址是随机的，基本上可以断定这是一次SYN攻击。在 Linux/Unix 上可以使用系统自带的 netstats 命令来检测 SYN 攻击。\n```\nnetstat -n -p TCP | grep SYN_RECV\n```\n常见的防御 SYN 攻击的方法有如下几种：\n\n* 缩短超时（SYN Timeout）时间\n* 增加最大半连接数\n* 过滤网关防护\n* SYN cookies技术\n\n\n## 发送 HTTP 请求\nTCP 三次握手结束后，开始发送 HTTP 请求报文。 \n这里客户端将请求行，请求头、请求正问等发送给服务端\n\n## 服务器处理请求并返回http报文\n它会对TCP连接进行处理，对HTTP协议进行解析，并按照报文格式进一步封装成HTTP Request对象，供上层使用。这一部分工作一般是由Web服务器去进行，常见的web server产品有apache、nginx、IIS、Lighttpd等。\nHTTP报文也分成三份，**状态码** **，响应报头**和**响应报文**\n\n### 状态码\n状态码是由3位数组成，第一个数字定义了响应的类别，且有五种可能取值:\n \n* 1xx：指示信息–表示请求已接收，继续处理。 \n* 2xx：成功–表示请求已被成功接收、理解、接受。 \n* 3xx：重定向–要完成请求必须进行更进一步的操作。 \n* 4xx：客户端错误–请求有语法错误或请求无法实现。 \n* 5xx：服务器端错误–服务器未能实现合法的请求。 \n\n平时遇到比较常见的状态码有:200, 204, 301, 302, 304, 400, 401, 403, 404, 422, 500\n \n**200 成功**\n请求成功，通常服务器提供了需要的资源。\n**204 无内容**\n服务器成功处理了请求，但没有返回任何内容。\n**301 永久移动**\n请求的网页已永久移动到新位置。 服务器返回此响应（对 GET 或 HEAD 请求的响应）时，会自动将请求者转到新位置。\n**302 临时移动**\n服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求。\n**304 未修改**\n自从上次请求后，请求的网页未修改过。 服务器返回此响应时，不会返回网页内容。\n**400 错误请求**\n服务器不理解请求的语法。\n**401 未授权**\n请求要求身份验证。 对于需要登录的网页，服务器可能返回此响应。\n**403 禁止**\n服务器拒绝请求。\n**404 未找到**\n服务器找不到请求的网页。\n**422 无法处理**\n请求格式正确，但是由于含有语义错误，无法响应\n**500 服务器内部错误**\n服务器遇到错误，无法完成请求。\n\n\n## 浏览器解析渲染页面\n \n![](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/4/28/16a634c92a7439dc~tplv-t2oaga2asx-watermark.awebp)\n\n上图就是`Webkit`(谷歌内核)解析渲染页面的过程。\n\n* 解析HTML形成`DOM Tree`(DOM树)\n* 解析CSS形成`CSSOM Tree`(CSSOM树)\n* 合并`DOM Tree`和`CSSOM Tree`形成`Render Tree`(渲染树)\n* 浏览器开始渲染并绘制页面 \n\n这个过程涉及两个比较重要的概念回流和重绘，DOM结点都是以盒模型形式存在，需要浏览器去计算位置和宽度等，这个过程就是回流。等到页面的宽高，大小，颜色等属性确定下来后，浏览器开始绘制内容，这个过程叫做重绘。浏览器刚打开页面一定要经过这两个过程的，但是这个过程非常非常非常消耗性能，所以我们应该尽量减少页面的回流和重绘\n\n### 回流\n当Render Tree中部分或全部元素的尺寸、结构、或某些属性发生改变时，浏览器重新渲染部分或全部文档的过程称为回流。\n\n**会导致回流的操作：**\n\n* 页面首次渲染\n* 浏览器窗口大小发生改变\n* 元素尺寸或位置发生改变\n* 元素内容变化（文字数量或图片大小等等）\n* 元素字体大小变化\n* 添加或者删除可见的DOM元素\n* 激活CSS伪类（例如：:hover）\n* 查询某些属性或调用某些方法\n\n**一些常用且会导致回流的属性和方法：**\n\n* clientWidth、clientHeight、clientTop、clientLeft\n* offsetWidth、offsetHeight、offsetTop、offsetLeft\n* scrollWidth、scrollHeight、scrollTop、scrollLeft\n* scrollIntoView()、scrollIntoViewIfNeeded()\n* getComputedStyle()\n* getBoundingClientRect()\n* scrollTo()\n\n### 重绘\n当页面中元素样式的改变并不影响它在文档流中的位置时（例如：color、background-color、visibility等），浏览器会将新样式赋予给元素并重新绘制它，这个过程称为重绘。\n### 针对回流与重绘优化\n\n**CSS**\n* 避免使用table布局。\n* 尽可能在DOM树的最末端改变class。\n* 避免设置多层内联样式。\n* 将动画效果应用到position属性为absolute或fixed的元素上。\n* 避免使用CSS表达式（例如：calc()）。\n\n**JS**\n* 避免频繁操作样式，最好一次性重写style属性，或者将样式列表定义为class并一次性更改class属性。\n* 避免频繁操作DOM，创建一个documentFragment，在它上面应用所有DOM操作，最后再把它添加到文档中。\n* 也可以先为元素设置display: none，操作结束后再把它显示出来。因为在display属性为none的元素上进行的DOM操作不会引发回流和重绘。\n* 避免频繁读取会引发回流/重绘的属性，如果确实需要多次使用，就用一个变量缓存起来。\n* 对具有复杂动画的元素使用绝对定位，使它脱离文档流，否则会引起父元素及后续元素频繁回流。\n\n\n\n## 断开连接：TCP 四次挥手\n\n 当数据传送完毕，需要断开 tcp 连接，此时发起 tcp 四次挥手。\n ![四次挥手](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/2/27/1692f41b21b32870~tplv-t2oaga2asx-watermark.awebp)\n \n1. **发起方向被动方发送报文，`Fin`、`Ack`、`Seq`，表示已经没有数据传输了。并进入 `FIN_WAIT_1` 状态。**\n   (第一次挥手：由浏览器发起的，发送给服务器，我请求报文发送完了，你准备关闭吧)\n2. **被动方发送报文，`Ack`、`Seq`，表示同意关闭请求进入`CLOSE_WAIT`状态。此时主机发起方进入 `FIN_WAIT_2` 状态。**\n   (第二次挥手：由服务器发起的，告诉浏览器，我请求报文接受完了，我准备关闭了，你也准备吧)\n3. **被动方向发起方发送报文段，`Fin`、`Ack`、`Seq`，请求关闭连接。并进入 `LAST_ACK` 状态。**\n   (第三次挥手：由服务器发起，告诉浏览器，我响应报文发送完了，你准备关闭吧)\n4. **发起方向被动方发送报文段，`Ack`、`Seq`。然后进入等待 `TIME_WAIT` 状态。被动方收到发起方的报文段以后关闭连接。发起方等待一定时间未收到回复，则正常关闭。**\n   (第四次挥手：由浏览器发起，告诉服务器，我响应报文接受完了，我准备关闭了，你也准备吧)\n\n### 挥手为什么需要四次?\n 因为当服务端收到客户端的SYN连接请求报文后，可以直接发送SYN+ACK报文。其中ACK报文是用来应答的，SYN报文是用来同步的。**但是关闭连接时，当服务端收到FIN报文时，很可能并不会立即关闭SOCKET，所以只能先回复一个ACK报文，告诉客户端，“你发的FIN报文我收到了”。只有等到我服务端所有的报文都发送完了，我才能发送FIN报文**，因此不能一起发送。故需要四次挥手 \n \n\n\n\n ","source":"_posts/从URL输入到页面展现到底发生什么？.md","raw":"---\ntitle: 从URL输入到页面展现到底发生什么？\ncatalog: true\ndate: 2021-04-22 21:31:20\nsubtitle:\nheader-img:\ntags:\n- 前端基础 \n- 浏览器基础\n---\n \n## 概述\n从开发&运维角度方面来看，可以分为下几个过程： \n> 解析出协议、主机、端口、路径等信息，并构造一个HTTP请求\n> DNS 解析:将域名解析成 IP 地址\n> TCP 连接：TCP 三次握手\n> 发送 HTTP 请求\n> 服务器处理请求并返回 HTTP 报文\n> 浏览器解析渲染页面\n> 断开连接：TCP 四次挥手\n\n## 前置内容\n浏览器是多进程的，主要分为：\n* 浏览器主进程：只有一个，主要控制页面的创建、销毁、网络资源管理、下载等。\n* 第三方插件进程：每一种类型的插件对应一个进程，仅当使用该插件时才创建。\n* GPU进程：最多一个，用于3D绘制等。\n* 浏览器渲染进程(浏览器内核)：每个Tab页对应一个进程，互不影响。\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6bc05b033f444b4198f0ce6084cc7b52~tplv-k3u1fbpfcp-watermark.awebp)\n\n## 将域名解析成 IP 地址\n### 什么是URL\n\n**URL**（Uniform Resource Locator），统一资源定位符，用于定位互联网上资源，俗称网址。\n\nscheme: // host.domain:port / path / filename ? abc = 123 # 456789\n```\nscheme       - 定义因特网服务的类型。常见的协议有 http、https、ftp、file，\n               其中最常见的类型是 http，而 https 则是进行加密的网络传输。\nhost         - 定义域主机（http 的默认主机是 www）\ndomain       - 定义因特网域名，比如 baidu.com\nport         - 定义主机上的端口号（http 的默认端口号是 80）\npath         - 定义服务器上的路径（如果省略，则文档必须位于网站的根目录中）。\nfilename     - 定义文档/资源的名称\nquery        - 即查询参数\nfragment     - 即 # 后的hash值，一般用来定位到某个位置 (锚点)\n```\n\n### 解析URL\n输入URL后，浏览器会解析出协议、主机、端口、路径等信息，并构造一个HTTP请求\n* 浏览器发送请求前，根据请求头的`expires`和`cache-control`判断是否命中（包括是否过期）`强缓存`策略，如果命中，直接从缓存获取资源，并不会发送请求。如果没有命中，则进入下一步。\n* 没有命中`强缓存`规则，浏览器会发送请求，根据请求头的`If-Modified-Since`和`If-None-Match`判断是否命中`协商缓存`，如果命中，直接从缓存获取资源。如果没有命中，则进入下一步。\n* 如果前两步都没有命中，则直接从服务端获取资源。\n[理解浏览器缓存](http://www.kyootah.com/article/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BC%93%E5%AD%98/)\n\n### DNS域名解析过程\n在浏览器输入网址后，首先要经过域名解析，因为浏览器并不能直接通过域名找到对应的服务器，而是要通过 IP 地址。\n\n**什么是IP地址**\n```\nIP 地址是指互联网协议地址，是 IP Address 的缩写。IP 地址是 IP 协议提供的一种统一的地址格式，\n它为互联网上的每一个网络和每一台主机分配一个逻辑地址，以此来屏蔽物理地址的差异。\n```\n\n**什么是域名解析**\n```\nDNS 协议提供通过域名查找 IP 地址，或逆向从 IP 地址反查域名的服务。\nDNS 是一个网络服务器，我们的域名解析简单来说就是在 DNS 上记录一条信息记录。\n```\n\n**什么是DNS**\n```\nDNS 是：\n一个由分层的 DNS 服务器实现的分布式数据库 \n一个使得主机能够查询分布式数据库的应用层协议 \n```\n\n**浏览器如何通过域名去查询 URL 对应的 IP**\n```\nDNS域名解析分为递归查询和迭代查询两种方式，现一般为迭代查询。\n```\n![](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/2/27/1692e385403c39ab~tplv-t2oaga2asx-watermark.awebp)\n\n### DNS的优化与应用\n1. `DNS缓存` DNS存在着多级缓存，从离浏览器的距离排序的话，有以下几种: **浏览器缓存，系统缓存，路由器缓存，IPS服务器缓存，根域名服务器缓存，顶级域名服务器缓存，主域名服务器缓存**。\n2. `DNS负载均衡(DNS重定向)` DNS负载均衡技术的实现原理是在DNS服务器中为同一个主机名配置多个IP地址，在应答DNS查询时， DNS服务器对每个查询将以DNS文件中主机记录的IP地址按顺序返回不同的解析结果，将客户端的访问 引导到不同的机器上去，使得不同的客户端访问不同的服务器，从而达到负载均衡的目的。\n   **CDN(Content Delivery Network)就是利用DNS的重定向技术，DNS服务器会返回一个跟 用户最接近的点的IP地址给用户，CDN节点的服务器负责响应用户的请求，提供所需的内容**\n3. `dns-prefetch` DNS Prefetch 是一种 DNS 预解析技术。当你浏览网页时，浏览器会在加载网页时对网页中的域名进行解析缓存，这样在你单击当前网页中的连接时就无需进行 DNS 的解析，减少用户等待时间，提高用户体验。\n\n\n## 网络协议分层\n`OSI参考模型`分为7层，`TCP`(Transmission Control Protocol)传输控制协议。 `TCP/IP`**协议将应用层、表示层、会话层合并为应用层，物理层和数据链路层合并为网络接口层。**\n![](http://img.kyootah.com/2022/02/28/ed6068caf7634.png)\n\n## TCP三次握手\n\n```\nSYN(synchronous建立联机)\nACK(acknowledgement 确认)\nPSH(push传送)\nFIN(finish结束)\nRST(reset重置)\nURG(urgent紧急)\n```\n![](http://img.kyootah.com/2022/02/28/a49b152d8390b.png)\n* **第一次握手：由浏览器发起，告诉服务器我要发送请求了**\n`主机A`发送位码为`SYN＝1`，**随机**产生Seq  number=1234567的数据包到服务器，`主机B`由`SYN=1`知道，A要求建立联机；\n* **第二次握手：由服务器发起，告诉浏览器我准备接受了，你赶紧发送吧**\n`主机B`收到请求后要确认联机信息，向A发送ack number=(主机A的seq+1)，SUN=1，ACK=1234567 + 1，**随机**产生Seq=7654321的包；\n* **第三次握手：由浏览器发送，告诉服务器，我马上就发了，准备接受吧**\n`主机A`收到后检查ack number是否正确，即第一次发送的seq number+1，以及位码SYN是否为1，若正确，主机A会再发送ack number=(主机B的seq+1)，ack=7654321 + 1，主机B收到后确认Seq值与ACK=7654321+ 1则连接建立成功；\n\n翻译成大白话就是：\n\n* 客户端：你能接收到我的消息吗？\n* 服务端：可以的，那你能接收到我的回复吗？\n* 客户端：可以，那我们开始聊正事吧。\n为什么是3次？：避免历史连接，确认客户端发来的请求是这次通信的人。\n为什么不是4次？：3次够了第四次浪费\n\n### SYN攻击是什么？\n服务器端的资源分配是在二次握手时分配的，而客户端的资源是在完成三次握手时分配的，所以服务器容易受到`SYN洪泛攻击`。SYN攻击就是Client在短时间内**伪造大量不存在的IP地址**，**并向Server不断地发送SYN包**，Server则回复确认包，并等待Client确认，由于源地址不存在，因此Server需要不断重发直至超时，这些伪造的SYN包将长时间占用未连接队列，导致正常的SYN请求因为队列满而被丢弃，从而引起网络拥塞甚至系统瘫痪。**SYN 攻击是一种典型的 `DoS/DDoS` 攻击**。\n检测 SYN 攻击非常的方便，当你在服务器上看到大量的半连接状态时，特别是源IP地址是随机的，基本上可以断定这是一次SYN攻击。在 Linux/Unix 上可以使用系统自带的 netstats 命令来检测 SYN 攻击。\n```\nnetstat -n -p TCP | grep SYN_RECV\n```\n常见的防御 SYN 攻击的方法有如下几种：\n\n* 缩短超时（SYN Timeout）时间\n* 增加最大半连接数\n* 过滤网关防护\n* SYN cookies技术\n\n\n## 发送 HTTP 请求\nTCP 三次握手结束后，开始发送 HTTP 请求报文。 \n这里客户端将请求行，请求头、请求正问等发送给服务端\n\n## 服务器处理请求并返回http报文\n它会对TCP连接进行处理，对HTTP协议进行解析，并按照报文格式进一步封装成HTTP Request对象，供上层使用。这一部分工作一般是由Web服务器去进行，常见的web server产品有apache、nginx、IIS、Lighttpd等。\nHTTP报文也分成三份，**状态码** **，响应报头**和**响应报文**\n\n### 状态码\n状态码是由3位数组成，第一个数字定义了响应的类别，且有五种可能取值:\n \n* 1xx：指示信息–表示请求已接收，继续处理。 \n* 2xx：成功–表示请求已被成功接收、理解、接受。 \n* 3xx：重定向–要完成请求必须进行更进一步的操作。 \n* 4xx：客户端错误–请求有语法错误或请求无法实现。 \n* 5xx：服务器端错误–服务器未能实现合法的请求。 \n\n平时遇到比较常见的状态码有:200, 204, 301, 302, 304, 400, 401, 403, 404, 422, 500\n \n**200 成功**\n请求成功，通常服务器提供了需要的资源。\n**204 无内容**\n服务器成功处理了请求，但没有返回任何内容。\n**301 永久移动**\n请求的网页已永久移动到新位置。 服务器返回此响应（对 GET 或 HEAD 请求的响应）时，会自动将请求者转到新位置。\n**302 临时移动**\n服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求。\n**304 未修改**\n自从上次请求后，请求的网页未修改过。 服务器返回此响应时，不会返回网页内容。\n**400 错误请求**\n服务器不理解请求的语法。\n**401 未授权**\n请求要求身份验证。 对于需要登录的网页，服务器可能返回此响应。\n**403 禁止**\n服务器拒绝请求。\n**404 未找到**\n服务器找不到请求的网页。\n**422 无法处理**\n请求格式正确，但是由于含有语义错误，无法响应\n**500 服务器内部错误**\n服务器遇到错误，无法完成请求。\n\n\n## 浏览器解析渲染页面\n \n![](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/4/28/16a634c92a7439dc~tplv-t2oaga2asx-watermark.awebp)\n\n上图就是`Webkit`(谷歌内核)解析渲染页面的过程。\n\n* 解析HTML形成`DOM Tree`(DOM树)\n* 解析CSS形成`CSSOM Tree`(CSSOM树)\n* 合并`DOM Tree`和`CSSOM Tree`形成`Render Tree`(渲染树)\n* 浏览器开始渲染并绘制页面 \n\n这个过程涉及两个比较重要的概念回流和重绘，DOM结点都是以盒模型形式存在，需要浏览器去计算位置和宽度等，这个过程就是回流。等到页面的宽高，大小，颜色等属性确定下来后，浏览器开始绘制内容，这个过程叫做重绘。浏览器刚打开页面一定要经过这两个过程的，但是这个过程非常非常非常消耗性能，所以我们应该尽量减少页面的回流和重绘\n\n### 回流\n当Render Tree中部分或全部元素的尺寸、结构、或某些属性发生改变时，浏览器重新渲染部分或全部文档的过程称为回流。\n\n**会导致回流的操作：**\n\n* 页面首次渲染\n* 浏览器窗口大小发生改变\n* 元素尺寸或位置发生改变\n* 元素内容变化（文字数量或图片大小等等）\n* 元素字体大小变化\n* 添加或者删除可见的DOM元素\n* 激活CSS伪类（例如：:hover）\n* 查询某些属性或调用某些方法\n\n**一些常用且会导致回流的属性和方法：**\n\n* clientWidth、clientHeight、clientTop、clientLeft\n* offsetWidth、offsetHeight、offsetTop、offsetLeft\n* scrollWidth、scrollHeight、scrollTop、scrollLeft\n* scrollIntoView()、scrollIntoViewIfNeeded()\n* getComputedStyle()\n* getBoundingClientRect()\n* scrollTo()\n\n### 重绘\n当页面中元素样式的改变并不影响它在文档流中的位置时（例如：color、background-color、visibility等），浏览器会将新样式赋予给元素并重新绘制它，这个过程称为重绘。\n### 针对回流与重绘优化\n\n**CSS**\n* 避免使用table布局。\n* 尽可能在DOM树的最末端改变class。\n* 避免设置多层内联样式。\n* 将动画效果应用到position属性为absolute或fixed的元素上。\n* 避免使用CSS表达式（例如：calc()）。\n\n**JS**\n* 避免频繁操作样式，最好一次性重写style属性，或者将样式列表定义为class并一次性更改class属性。\n* 避免频繁操作DOM，创建一个documentFragment，在它上面应用所有DOM操作，最后再把它添加到文档中。\n* 也可以先为元素设置display: none，操作结束后再把它显示出来。因为在display属性为none的元素上进行的DOM操作不会引发回流和重绘。\n* 避免频繁读取会引发回流/重绘的属性，如果确实需要多次使用，就用一个变量缓存起来。\n* 对具有复杂动画的元素使用绝对定位，使它脱离文档流，否则会引起父元素及后续元素频繁回流。\n\n\n\n## 断开连接：TCP 四次挥手\n\n 当数据传送完毕，需要断开 tcp 连接，此时发起 tcp 四次挥手。\n ![四次挥手](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/2/27/1692f41b21b32870~tplv-t2oaga2asx-watermark.awebp)\n \n1. **发起方向被动方发送报文，`Fin`、`Ack`、`Seq`，表示已经没有数据传输了。并进入 `FIN_WAIT_1` 状态。**\n   (第一次挥手：由浏览器发起的，发送给服务器，我请求报文发送完了，你准备关闭吧)\n2. **被动方发送报文，`Ack`、`Seq`，表示同意关闭请求进入`CLOSE_WAIT`状态。此时主机发起方进入 `FIN_WAIT_2` 状态。**\n   (第二次挥手：由服务器发起的，告诉浏览器，我请求报文接受完了，我准备关闭了，你也准备吧)\n3. **被动方向发起方发送报文段，`Fin`、`Ack`、`Seq`，请求关闭连接。并进入 `LAST_ACK` 状态。**\n   (第三次挥手：由服务器发起，告诉浏览器，我响应报文发送完了，你准备关闭吧)\n4. **发起方向被动方发送报文段，`Ack`、`Seq`。然后进入等待 `TIME_WAIT` 状态。被动方收到发起方的报文段以后关闭连接。发起方等待一定时间未收到回复，则正常关闭。**\n   (第四次挥手：由浏览器发起，告诉服务器，我响应报文接受完了，我准备关闭了，你也准备吧)\n\n### 挥手为什么需要四次?\n 因为当服务端收到客户端的SYN连接请求报文后，可以直接发送SYN+ACK报文。其中ACK报文是用来应答的，SYN报文是用来同步的。**但是关闭连接时，当服务端收到FIN报文时，很可能并不会立即关闭SOCKET，所以只能先回复一个ACK报文，告诉客户端，“你发的FIN报文我收到了”。只有等到我服务端所有的报文都发送完了，我才能发送FIN报文**，因此不能一起发送。故需要四次挥手 \n \n\n\n\n ","slug":"从URL输入到页面展现到底发生什么？","published":1,"updated":"2022-03-03T08:23:58.411Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl27vhg5l000gu8q561a3vu8l","content":"<h2 id=\"概述\">概述</h2>\n<p>从开发&amp;运维角度方面来看，可以分为下几个过程：</p>\n<blockquote>\n<p>解析出协议、主机、端口、路径等信息，并构造一个HTTP请求<br>\nDNS 解析:将域名解析成 IP 地址<br>\nTCP 连接：TCP 三次握手<br>\n发送 HTTP 请求<br>\n服务器处理请求并返回 HTTP 报文<br>\n浏览器解析渲染页面<br>\n断开连接：TCP 四次挥手</p>\n</blockquote>\n<h2 id=\"前置内容\">前置内容</h2>\n<p>浏览器是多进程的，主要分为：</p>\n<ul>\n<li>浏览器主进程：只有一个，主要控制页面的创建、销毁、网络资源管理、下载等。</li>\n<li>第三方插件进程：每一种类型的插件对应一个进程，仅当使用该插件时才创建。</li>\n<li>GPU进程：最多一个，用于3D绘制等。</li>\n<li>浏览器渲染进程(浏览器内核)：每个Tab页对应一个进程，互不影响。<br>\n<img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6bc05b033f444b4198f0ce6084cc7b52~tplv-k3u1fbpfcp-watermark.awebp\" alt></li>\n</ul>\n<h2 id=\"将域名解析成-ip-地址\">将域名解析成 IP 地址</h2>\n<h3 id=\"什么是url\">什么是URL</h3>\n<p><strong>URL</strong>（Uniform Resource Locator），统一资源定位符，用于定位互联网上资源，俗称网址。</p>\n<p>scheme: // host.domain:port / path / filename ? abc = 123 # 456789</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">scheme       - 定义因特网服务的类型。常见的协议有 http、https、ftp、file，</span><br><span class=\"line\">               其中最常见的类型是 http，而 https 则是进行加密的网络传输。</span><br><span class=\"line\">host         - 定义域主机（http 的默认主机是 www）</span><br><span class=\"line\">domain       - 定义因特网域名，比如 baidu.com</span><br><span class=\"line\">port         - 定义主机上的端口号（http 的默认端口号是 80）</span><br><span class=\"line\">path         - 定义服务器上的路径（如果省略，则文档必须位于网站的根目录中）。</span><br><span class=\"line\">filename     - 定义文档/资源的名称</span><br><span class=\"line\">query        - 即查询参数</span><br><span class=\"line\">fragment     - 即 # 后的hash值，一般用来定位到某个位置 (锚点)</span><br></pre></td></tr></table></figure>\n<h3 id=\"解析url\">解析URL</h3>\n<p>输入URL后，浏览器会解析出协议、主机、端口、路径等信息，并构造一个HTTP请求</p>\n<ul>\n<li>浏览器发送请求前，根据请求头的<code>expires</code>和<code>cache-control</code>判断是否命中（包括是否过期）<code>强缓存</code>策略，如果命中，直接从缓存获取资源，并不会发送请求。如果没有命中，则进入下一步。</li>\n<li>没有命中<code>强缓存</code>规则，浏览器会发送请求，根据请求头的<code>If-Modified-Since</code>和<code>If-None-Match</code>判断是否命中<code>协商缓存</code>，如果命中，直接从缓存获取资源。如果没有命中，则进入下一步。</li>\n<li>如果前两步都没有命中，则直接从服务端获取资源。<br>\n<a href=\"http://www.kyootah.com/article/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BC%93%E5%AD%98/\">理解浏览器缓存</a></li>\n</ul>\n<h3 id=\"dns域名解析过程\">DNS域名解析过程</h3>\n<p>在浏览器输入网址后，首先要经过域名解析，因为浏览器并不能直接通过域名找到对应的服务器，而是要通过 IP 地址。</p>\n<p><strong>什么是IP地址</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">IP 地址是指互联网协议地址，是 IP Address 的缩写。IP 地址是 IP 协议提供的一种统一的地址格式，</span><br><span class=\"line\">它为互联网上的每一个网络和每一台主机分配一个逻辑地址，以此来屏蔽物理地址的差异。</span><br></pre></td></tr></table></figure>\n<p><strong>什么是域名解析</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">DNS 协议提供通过域名查找 IP 地址，或逆向从 IP 地址反查域名的服务。</span><br><span class=\"line\">DNS 是一个网络服务器，我们的域名解析简单来说就是在 DNS 上记录一条信息记录。</span><br></pre></td></tr></table></figure>\n<p><strong>什么是DNS</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">DNS 是：</span><br><span class=\"line\">一个由分层的 DNS 服务器实现的分布式数据库 </span><br><span class=\"line\">一个使得主机能够查询分布式数据库的应用层协议</span><br></pre></td></tr></table></figure>\n<p><strong>浏览器如何通过域名去查询 URL 对应的 IP</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">DNS域名解析分为递归查询和迭代查询两种方式，现一般为迭代查询。</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/2/27/1692e385403c39ab~tplv-t2oaga2asx-watermark.awebp\" alt></p>\n<h3 id=\"dns的优化与应用\">DNS的优化与应用</h3>\n<ol>\n<li><code>DNS缓存</code> DNS存在着多级缓存，从离浏览器的距离排序的话，有以下几种: <strong>浏览器缓存，系统缓存，路由器缓存，IPS服务器缓存，根域名服务器缓存，顶级域名服务器缓存，主域名服务器缓存</strong>。</li>\n<li><code>DNS负载均衡(DNS重定向)</code> DNS负载均衡技术的实现原理是在DNS服务器中为同一个主机名配置多个IP地址，在应答DNS查询时， DNS服务器对每个查询将以DNS文件中主机记录的IP地址按顺序返回不同的解析结果，将客户端的访问 引导到不同的机器上去，使得不同的客户端访问不同的服务器，从而达到负载均衡的目的。<br>\n<strong>CDN(Content Delivery Network)就是利用DNS的重定向技术，DNS服务器会返回一个跟 用户最接近的点的IP地址给用户，CDN节点的服务器负责响应用户的请求，提供所需的内容</strong></li>\n<li><code>dns-prefetch</code> DNS Prefetch 是一种 DNS 预解析技术。当你浏览网页时，浏览器会在加载网页时对网页中的域名进行解析缓存，这样在你单击当前网页中的连接时就无需进行 DNS 的解析，减少用户等待时间，提高用户体验。</li>\n</ol>\n<h2 id=\"网络协议分层\">网络协议分层</h2>\n<p><code>OSI参考模型</code>分为7层，<code>TCP</code>(Transmission Control Protocol)传输控制协议。 <code>TCP/IP</code><strong>协议将应用层、表示层、会话层合并为应用层，物理层和数据链路层合并为网络接口层。</strong><br>\n<img src=\"http://img.kyootah.com/2022/02/28/ed6068caf7634.png\" alt></p>\n<h2 id=\"tcp三次握手\">TCP三次握手</h2>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SYN(synchronous建立联机)</span><br><span class=\"line\">ACK(acknowledgement 确认)</span><br><span class=\"line\">PSH(push传送)</span><br><span class=\"line\">FIN(finish结束)</span><br><span class=\"line\">RST(reset重置)</span><br><span class=\"line\">URG(urgent紧急)</span><br></pre></td></tr></table></figure>\n<p><img src=\"http://img.kyootah.com/2022/02/28/a49b152d8390b.png\" alt></p>\n<ul>\n<li><strong>第一次握手：由浏览器发起，告诉服务器我要发送请求了</strong><br>\n<code>主机A</code>发送位码为<code>SYN＝1</code>，<strong>随机</strong>产生Seq  number=1234567的数据包到服务器，<code>主机B</code>由<code>SYN=1</code>知道，A要求建立联机；</li>\n<li><strong>第二次握手：由服务器发起，告诉浏览器我准备接受了，你赶紧发送吧</strong><br>\n<code>主机B</code>收到请求后要确认联机信息，向A发送ack number=(主机A的seq+1)，SUN=1，ACK=1234567 + 1，<strong>随机</strong>产生Seq=7654321的包；</li>\n<li><strong>第三次握手：由浏览器发送，告诉服务器，我马上就发了，准备接受吧</strong><br>\n<code>主机A</code>收到后检查ack number是否正确，即第一次发送的seq number+1，以及位码SYN是否为1，若正确，主机A会再发送ack number=(主机B的seq+1)，ack=7654321 + 1，主机B收到后确认Seq值与ACK=7654321+ 1则连接建立成功；</li>\n</ul>\n<p>翻译成大白话就是：</p>\n<ul>\n<li>客户端：你能接收到我的消息吗？</li>\n<li>服务端：可以的，那你能接收到我的回复吗？</li>\n<li>客户端：可以，那我们开始聊正事吧。<br>\n为什么是3次？：避免历史连接，确认客户端发来的请求是这次通信的人。<br>\n为什么不是4次？：3次够了第四次浪费</li>\n</ul>\n<h3 id=\"syn攻击是什么\">SYN攻击是什么？</h3>\n<p>服务器端的资源分配是在二次握手时分配的，而客户端的资源是在完成三次握手时分配的，所以服务器容易受到<code>SYN洪泛攻击</code>。SYN攻击就是Client在短时间内<strong>伪造大量不存在的IP地址</strong>，<strong>并向Server不断地发送SYN包</strong>，Server则回复确认包，并等待Client确认，由于源地址不存在，因此Server需要不断重发直至超时，这些伪造的SYN包将长时间占用未连接队列，导致正常的SYN请求因为队列满而被丢弃，从而引起网络拥塞甚至系统瘫痪。<strong>SYN 攻击是一种典型的 <code>DoS/DDoS</code> 攻击</strong>。<br>\n检测 SYN 攻击非常的方便，当你在服务器上看到大量的半连接状态时，特别是源IP地址是随机的，基本上可以断定这是一次SYN攻击。在 Linux/Unix 上可以使用系统自带的 netstats 命令来检测 SYN 攻击。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">netstat -n -p TCP | grep SYN_RECV</span><br></pre></td></tr></table></figure>\n<p>常见的防御 SYN 攻击的方法有如下几种：</p>\n<ul>\n<li>缩短超时（SYN Timeout）时间</li>\n<li>增加最大半连接数</li>\n<li>过滤网关防护</li>\n<li>SYN cookies技术</li>\n</ul>\n<h2 id=\"发送-http-请求\">发送 HTTP 请求</h2>\n<p>TCP 三次握手结束后，开始发送 HTTP 请求报文。<br>\n这里客户端将请求行，请求头、请求正问等发送给服务端</p>\n<h2 id=\"服务器处理请求并返回http报文\">服务器处理请求并返回http报文</h2>\n<p>它会对TCP连接进行处理，对HTTP协议进行解析，并按照报文格式进一步封装成HTTP Request对象，供上层使用。这一部分工作一般是由Web服务器去进行，常见的web server产品有apache、nginx、IIS、Lighttpd等。<br>\nHTTP报文也分成三份，<strong>状态码</strong> <strong>，响应报头</strong>和<strong>响应报文</strong></p>\n<h3 id=\"状态码\">状态码</h3>\n<p>状态码是由3位数组成，第一个数字定义了响应的类别，且有五种可能取值:</p>\n<ul>\n<li>1xx：指示信息–表示请求已接收，继续处理。</li>\n<li>2xx：成功–表示请求已被成功接收、理解、接受。</li>\n<li>3xx：重定向–要完成请求必须进行更进一步的操作。</li>\n<li>4xx：客户端错误–请求有语法错误或请求无法实现。</li>\n<li>5xx：服务器端错误–服务器未能实现合法的请求。</li>\n</ul>\n<p>平时遇到比较常见的状态码有:200, 204, 301, 302, 304, 400, 401, 403, 404, 422, 500</p>\n<p><strong>200 成功</strong><br>\n请求成功，通常服务器提供了需要的资源。<br>\n<strong>204 无内容</strong><br>\n服务器成功处理了请求，但没有返回任何内容。<br>\n<strong>301 永久移动</strong><br>\n请求的网页已永久移动到新位置。 服务器返回此响应（对 GET 或 HEAD 请求的响应）时，会自动将请求者转到新位置。<br>\n<strong>302 临时移动</strong><br>\n服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求。<br>\n<strong>304 未修改</strong><br>\n自从上次请求后，请求的网页未修改过。 服务器返回此响应时，不会返回网页内容。<br>\n<strong>400 错误请求</strong><br>\n服务器不理解请求的语法。<br>\n<strong>401 未授权</strong><br>\n请求要求身份验证。 对于需要登录的网页，服务器可能返回此响应。<br>\n<strong>403 禁止</strong><br>\n服务器拒绝请求。<br>\n<strong>404 未找到</strong><br>\n服务器找不到请求的网页。<br>\n<strong>422 无法处理</strong><br>\n请求格式正确，但是由于含有语义错误，无法响应<br>\n<strong>500 服务器内部错误</strong><br>\n服务器遇到错误，无法完成请求。</p>\n<h2 id=\"浏览器解析渲染页面\">浏览器解析渲染页面</h2>\n<p><img src=\"https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/4/28/16a634c92a7439dc~tplv-t2oaga2asx-watermark.awebp\" alt></p>\n<p>上图就是<code>Webkit</code>(谷歌内核)解析渲染页面的过程。</p>\n<ul>\n<li>解析HTML形成<code>DOM Tree</code>(DOM树)</li>\n<li>解析CSS形成<code>CSSOM Tree</code>(CSSOM树)</li>\n<li>合并<code>DOM Tree</code>和<code>CSSOM Tree</code>形成<code>Render Tree</code>(渲染树)</li>\n<li>浏览器开始渲染并绘制页面</li>\n</ul>\n<p>这个过程涉及两个比较重要的概念回流和重绘，DOM结点都是以盒模型形式存在，需要浏览器去计算位置和宽度等，这个过程就是回流。等到页面的宽高，大小，颜色等属性确定下来后，浏览器开始绘制内容，这个过程叫做重绘。浏览器刚打开页面一定要经过这两个过程的，但是这个过程非常非常非常消耗性能，所以我们应该尽量减少页面的回流和重绘</p>\n<h3 id=\"回流\">回流</h3>\n<p>当Render Tree中部分或全部元素的尺寸、结构、或某些属性发生改变时，浏览器重新渲染部分或全部文档的过程称为回流。</p>\n<p><strong>会导致回流的操作：</strong></p>\n<ul>\n<li>页面首次渲染</li>\n<li>浏览器窗口大小发生改变</li>\n<li>元素尺寸或位置发生改变</li>\n<li>元素内容变化（文字数量或图片大小等等）</li>\n<li>元素字体大小变化</li>\n<li>添加或者删除可见的DOM元素</li>\n<li>激活CSS伪类（例如：:hover）</li>\n<li>查询某些属性或调用某些方法</li>\n</ul>\n<p><strong>一些常用且会导致回流的属性和方法：</strong></p>\n<ul>\n<li>clientWidth、clientHeight、clientTop、clientLeft</li>\n<li>offsetWidth、offsetHeight、offsetTop、offsetLeft</li>\n<li>scrollWidth、scrollHeight、scrollTop、scrollLeft</li>\n<li>scrollIntoView()、scrollIntoViewIfNeeded()</li>\n<li>getComputedStyle()</li>\n<li>getBoundingClientRect()</li>\n<li>scrollTo()</li>\n</ul>\n<h3 id=\"重绘\">重绘</h3>\n<p>当页面中元素样式的改变并不影响它在文档流中的位置时（例如：color、background-color、visibility等），浏览器会将新样式赋予给元素并重新绘制它，这个过程称为重绘。</p>\n<h3 id=\"针对回流与重绘优化\">针对回流与重绘优化</h3>\n<p><strong>CSS</strong></p>\n<ul>\n<li>避免使用table布局。</li>\n<li>尽可能在DOM树的最末端改变class。</li>\n<li>避免设置多层内联样式。</li>\n<li>将动画效果应用到position属性为absolute或fixed的元素上。</li>\n<li>避免使用CSS表达式（例如：calc()）。</li>\n</ul>\n<p><strong>JS</strong></p>\n<ul>\n<li>避免频繁操作样式，最好一次性重写style属性，或者将样式列表定义为class并一次性更改class属性。</li>\n<li>避免频繁操作DOM，创建一个documentFragment，在它上面应用所有DOM操作，最后再把它添加到文档中。</li>\n<li>也可以先为元素设置display: none，操作结束后再把它显示出来。因为在display属性为none的元素上进行的DOM操作不会引发回流和重绘。</li>\n<li>避免频繁读取会引发回流/重绘的属性，如果确实需要多次使用，就用一个变量缓存起来。</li>\n<li>对具有复杂动画的元素使用绝对定位，使它脱离文档流，否则会引起父元素及后续元素频繁回流。</li>\n</ul>\n<h2 id=\"断开连接tcp-四次挥手\">断开连接：TCP 四次挥手</h2>\n<p>当数据传送完毕，需要断开 tcp 连接，此时发起 tcp 四次挥手。<br>\n<img src=\"https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/2/27/1692f41b21b32870~tplv-t2oaga2asx-watermark.awebp\" alt=\"四次挥手\"></p>\n<ol>\n<li><strong>发起方向被动方发送报文，<code>Fin</code>、<code>Ack</code>、<code>Seq</code>，表示已经没有数据传输了。并进入 <code>FIN_WAIT_1</code> 状态。</strong><br>\n(第一次挥手：由浏览器发起的，发送给服务器，我请求报文发送完了，你准备关闭吧)</li>\n<li><strong>被动方发送报文，<code>Ack</code>、<code>Seq</code>，表示同意关闭请求进入<code>CLOSE_WAIT</code>状态。此时主机发起方进入 <code>FIN_WAIT_2</code> 状态。</strong><br>\n(第二次挥手：由服务器发起的，告诉浏览器，我请求报文接受完了，我准备关闭了，你也准备吧)</li>\n<li><strong>被动方向发起方发送报文段，<code>Fin</code>、<code>Ack</code>、<code>Seq</code>，请求关闭连接。并进入 <code>LAST_ACK</code> 状态。</strong><br>\n(第三次挥手：由服务器发起，告诉浏览器，我响应报文发送完了，你准备关闭吧)</li>\n<li><strong>发起方向被动方发送报文段，<code>Ack</code>、<code>Seq</code>。然后进入等待 <code>TIME_WAIT</code> 状态。被动方收到发起方的报文段以后关闭连接。发起方等待一定时间未收到回复，则正常关闭。</strong><br>\n(第四次挥手：由浏览器发起，告诉服务器，我响应报文接受完了，我准备关闭了，你也准备吧)</li>\n</ol>\n<h3 id=\"挥手为什么需要四次\">挥手为什么需要四次?</h3>\n<p>因为当服务端收到客户端的SYN连接请求报文后，可以直接发送SYN+ACK报文。其中ACK报文是用来应答的，SYN报文是用来同步的。<strong>但是关闭连接时，当服务端收到FIN报文时，很可能并不会立即关闭SOCKET，所以只能先回复一个ACK报文，告诉客户端，“你发的FIN报文我收到了”。只有等到我服务端所有的报文都发送完了，我才能发送FIN报文</strong>，因此不能一起发送。故需要四次挥手</p>\n","site":{"data":{}},"excerpt":"","more":"<h2>概述</h2>\n<p>从开发&amp;运维角度方面来看，可以分为下几个过程：</p>\n<blockquote>\n<p>解析出协议、主机、端口、路径等信息，并构造一个HTTP请求<br>\nDNS 解析:将域名解析成 IP 地址<br>\nTCP 连接：TCP 三次握手<br>\n发送 HTTP 请求<br>\n服务器处理请求并返回 HTTP 报文<br>\n浏览器解析渲染页面<br>\n断开连接：TCP 四次挥手</p>\n</blockquote>\n<h2>前置内容</h2>\n<p>浏览器是多进程的，主要分为：</p>\n<ul>\n<li>浏览器主进程：只有一个，主要控制页面的创建、销毁、网络资源管理、下载等。</li>\n<li>第三方插件进程：每一种类型的插件对应一个进程，仅当使用该插件时才创建。</li>\n<li>GPU进程：最多一个，用于3D绘制等。</li>\n<li>浏览器渲染进程(浏览器内核)：每个Tab页对应一个进程，互不影响。<br>\n<img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6bc05b033f444b4198f0ce6084cc7b52~tplv-k3u1fbpfcp-watermark.awebp\" alt></li>\n</ul>\n<h2>将域名解析成 IP 地址</h2>\n<h3>什么是URL</h3>\n<p><strong>URL</strong>（Uniform Resource Locator），统一资源定位符，用于定位互联网上资源，俗称网址。</p>\n<p>scheme: // host.domain:port / path / filename ? abc = 123 # 456789</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">scheme       - 定义因特网服务的类型。常见的协议有 http、https、ftp、file，</span><br><span class=\"line\">               其中最常见的类型是 http，而 https 则是进行加密的网络传输。</span><br><span class=\"line\">host         - 定义域主机（http 的默认主机是 www）</span><br><span class=\"line\">domain       - 定义因特网域名，比如 baidu.com</span><br><span class=\"line\">port         - 定义主机上的端口号（http 的默认端口号是 80）</span><br><span class=\"line\">path         - 定义服务器上的路径（如果省略，则文档必须位于网站的根目录中）。</span><br><span class=\"line\">filename     - 定义文档/资源的名称</span><br><span class=\"line\">query        - 即查询参数</span><br><span class=\"line\">fragment     - 即 # 后的hash值，一般用来定位到某个位置 (锚点)</span><br></pre></td></tr></table></figure>\n<h3>解析URL</h3>\n<p>输入URL后，浏览器会解析出协议、主机、端口、路径等信息，并构造一个HTTP请求</p>\n<ul>\n<li>浏览器发送请求前，根据请求头的<code>expires</code>和<code>cache-control</code>判断是否命中（包括是否过期）<code>强缓存</code>策略，如果命中，直接从缓存获取资源，并不会发送请求。如果没有命中，则进入下一步。</li>\n<li>没有命中<code>强缓存</code>规则，浏览器会发送请求，根据请求头的<code>If-Modified-Since</code>和<code>If-None-Match</code>判断是否命中<code>协商缓存</code>，如果命中，直接从缓存获取资源。如果没有命中，则进入下一步。</li>\n<li>如果前两步都没有命中，则直接从服务端获取资源。<br>\n<a href=\"http://www.kyootah.com/article/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BC%93%E5%AD%98/\">理解浏览器缓存</a></li>\n</ul>\n<h3>DNS域名解析过程</h3>\n<p>在浏览器输入网址后，首先要经过域名解析，因为浏览器并不能直接通过域名找到对应的服务器，而是要通过 IP 地址。</p>\n<p><strong>什么是IP地址</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">IP 地址是指互联网协议地址，是 IP Address 的缩写。IP 地址是 IP 协议提供的一种统一的地址格式，</span><br><span class=\"line\">它为互联网上的每一个网络和每一台主机分配一个逻辑地址，以此来屏蔽物理地址的差异。</span><br></pre></td></tr></table></figure>\n<p><strong>什么是域名解析</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">DNS 协议提供通过域名查找 IP 地址，或逆向从 IP 地址反查域名的服务。</span><br><span class=\"line\">DNS 是一个网络服务器，我们的域名解析简单来说就是在 DNS 上记录一条信息记录。</span><br></pre></td></tr></table></figure>\n<p><strong>什么是DNS</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">DNS 是：</span><br><span class=\"line\">一个由分层的 DNS 服务器实现的分布式数据库 </span><br><span class=\"line\">一个使得主机能够查询分布式数据库的应用层协议</span><br></pre></td></tr></table></figure>\n<p><strong>浏览器如何通过域名去查询 URL 对应的 IP</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">DNS域名解析分为递归查询和迭代查询两种方式，现一般为迭代查询。</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/2/27/1692e385403c39ab~tplv-t2oaga2asx-watermark.awebp\" alt></p>\n<h3>DNS的优化与应用</h3>\n<ol>\n<li><code>DNS缓存</code> DNS存在着多级缓存，从离浏览器的距离排序的话，有以下几种: <strong>浏览器缓存，系统缓存，路由器缓存，IPS服务器缓存，根域名服务器缓存，顶级域名服务器缓存，主域名服务器缓存</strong>。</li>\n<li><code>DNS负载均衡(DNS重定向)</code> DNS负载均衡技术的实现原理是在DNS服务器中为同一个主机名配置多个IP地址，在应答DNS查询时， DNS服务器对每个查询将以DNS文件中主机记录的IP地址按顺序返回不同的解析结果，将客户端的访问 引导到不同的机器上去，使得不同的客户端访问不同的服务器，从而达到负载均衡的目的。<br>\n<strong>CDN(Content Delivery Network)就是利用DNS的重定向技术，DNS服务器会返回一个跟 用户最接近的点的IP地址给用户，CDN节点的服务器负责响应用户的请求，提供所需的内容</strong></li>\n<li><code>dns-prefetch</code> DNS Prefetch 是一种 DNS 预解析技术。当你浏览网页时，浏览器会在加载网页时对网页中的域名进行解析缓存，这样在你单击当前网页中的连接时就无需进行 DNS 的解析，减少用户等待时间，提高用户体验。</li>\n</ol>\n<h2>网络协议分层</h2>\n<p><code>OSI参考模型</code>分为7层，<code>TCP</code>(Transmission Control Protocol)传输控制协议。 <code>TCP/IP</code><strong>协议将应用层、表示层、会话层合并为应用层，物理层和数据链路层合并为网络接口层。</strong><br>\n<img src=\"http://img.kyootah.com/2022/02/28/ed6068caf7634.png\" alt></p>\n<h2>TCP三次握手</h2>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SYN(synchronous建立联机)</span><br><span class=\"line\">ACK(acknowledgement 确认)</span><br><span class=\"line\">PSH(push传送)</span><br><span class=\"line\">FIN(finish结束)</span><br><span class=\"line\">RST(reset重置)</span><br><span class=\"line\">URG(urgent紧急)</span><br></pre></td></tr></table></figure>\n<p><img src=\"http://img.kyootah.com/2022/02/28/a49b152d8390b.png\" alt></p>\n<ul>\n<li><strong>第一次握手：由浏览器发起，告诉服务器我要发送请求了</strong><br>\n<code>主机A</code>发送位码为<code>SYN＝1</code>，<strong>随机</strong>产生Seq  number=1234567的数据包到服务器，<code>主机B</code>由<code>SYN=1</code>知道，A要求建立联机；</li>\n<li><strong>第二次握手：由服务器发起，告诉浏览器我准备接受了，你赶紧发送吧</strong><br>\n<code>主机B</code>收到请求后要确认联机信息，向A发送ack number=(主机A的seq+1)，SUN=1，ACK=1234567 + 1，<strong>随机</strong>产生Seq=7654321的包；</li>\n<li><strong>第三次握手：由浏览器发送，告诉服务器，我马上就发了，准备接受吧</strong><br>\n<code>主机A</code>收到后检查ack number是否正确，即第一次发送的seq number+1，以及位码SYN是否为1，若正确，主机A会再发送ack number=(主机B的seq+1)，ack=7654321 + 1，主机B收到后确认Seq值与ACK=7654321+ 1则连接建立成功；</li>\n</ul>\n<p>翻译成大白话就是：</p>\n<ul>\n<li>客户端：你能接收到我的消息吗？</li>\n<li>服务端：可以的，那你能接收到我的回复吗？</li>\n<li>客户端：可以，那我们开始聊正事吧。<br>\n为什么是3次？：避免历史连接，确认客户端发来的请求是这次通信的人。<br>\n为什么不是4次？：3次够了第四次浪费</li>\n</ul>\n<h3>SYN攻击是什么？</h3>\n<p>服务器端的资源分配是在二次握手时分配的，而客户端的资源是在完成三次握手时分配的，所以服务器容易受到<code>SYN洪泛攻击</code>。SYN攻击就是Client在短时间内<strong>伪造大量不存在的IP地址</strong>，<strong>并向Server不断地发送SYN包</strong>，Server则回复确认包，并等待Client确认，由于源地址不存在，因此Server需要不断重发直至超时，这些伪造的SYN包将长时间占用未连接队列，导致正常的SYN请求因为队列满而被丢弃，从而引起网络拥塞甚至系统瘫痪。<strong>SYN 攻击是一种典型的 <code>DoS/DDoS</code> 攻击</strong>。<br>\n检测 SYN 攻击非常的方便，当你在服务器上看到大量的半连接状态时，特别是源IP地址是随机的，基本上可以断定这是一次SYN攻击。在 Linux/Unix 上可以使用系统自带的 netstats 命令来检测 SYN 攻击。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">netstat -n -p TCP | grep SYN_RECV</span><br></pre></td></tr></table></figure>\n<p>常见的防御 SYN 攻击的方法有如下几种：</p>\n<ul>\n<li>缩短超时（SYN Timeout）时间</li>\n<li>增加最大半连接数</li>\n<li>过滤网关防护</li>\n<li>SYN cookies技术</li>\n</ul>\n<h2>发送 HTTP 请求</h2>\n<p>TCP 三次握手结束后，开始发送 HTTP 请求报文。<br>\n这里客户端将请求行，请求头、请求正问等发送给服务端</p>\n<h2>服务器处理请求并返回http报文</h2>\n<p>它会对TCP连接进行处理，对HTTP协议进行解析，并按照报文格式进一步封装成HTTP Request对象，供上层使用。这一部分工作一般是由Web服务器去进行，常见的web server产品有apache、nginx、IIS、Lighttpd等。<br>\nHTTP报文也分成三份，<strong>状态码</strong> <strong>，响应报头</strong>和<strong>响应报文</strong></p>\n<h3>状态码</h3>\n<p>状态码是由3位数组成，第一个数字定义了响应的类别，且有五种可能取值:</p>\n<ul>\n<li>1xx：指示信息–表示请求已接收，继续处理。</li>\n<li>2xx：成功–表示请求已被成功接收、理解、接受。</li>\n<li>3xx：重定向–要完成请求必须进行更进一步的操作。</li>\n<li>4xx：客户端错误–请求有语法错误或请求无法实现。</li>\n<li>5xx：服务器端错误–服务器未能实现合法的请求。</li>\n</ul>\n<p>平时遇到比较常见的状态码有:200, 204, 301, 302, 304, 400, 401, 403, 404, 422, 500</p>\n<p><strong>200 成功</strong><br>\n请求成功，通常服务器提供了需要的资源。<br>\n<strong>204 无内容</strong><br>\n服务器成功处理了请求，但没有返回任何内容。<br>\n<strong>301 永久移动</strong><br>\n请求的网页已永久移动到新位置。 服务器返回此响应（对 GET 或 HEAD 请求的响应）时，会自动将请求者转到新位置。<br>\n<strong>302 临时移动</strong><br>\n服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求。<br>\n<strong>304 未修改</strong><br>\n自从上次请求后，请求的网页未修改过。 服务器返回此响应时，不会返回网页内容。<br>\n<strong>400 错误请求</strong><br>\n服务器不理解请求的语法。<br>\n<strong>401 未授权</strong><br>\n请求要求身份验证。 对于需要登录的网页，服务器可能返回此响应。<br>\n<strong>403 禁止</strong><br>\n服务器拒绝请求。<br>\n<strong>404 未找到</strong><br>\n服务器找不到请求的网页。<br>\n<strong>422 无法处理</strong><br>\n请求格式正确，但是由于含有语义错误，无法响应<br>\n<strong>500 服务器内部错误</strong><br>\n服务器遇到错误，无法完成请求。</p>\n<h2>浏览器解析渲染页面</h2>\n<p><img src=\"https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/4/28/16a634c92a7439dc~tplv-t2oaga2asx-watermark.awebp\" alt></p>\n<p>上图就是<code>Webkit</code>(谷歌内核)解析渲染页面的过程。</p>\n<ul>\n<li>解析HTML形成<code>DOM Tree</code>(DOM树)</li>\n<li>解析CSS形成<code>CSSOM Tree</code>(CSSOM树)</li>\n<li>合并<code>DOM Tree</code>和<code>CSSOM Tree</code>形成<code>Render Tree</code>(渲染树)</li>\n<li>浏览器开始渲染并绘制页面</li>\n</ul>\n<p>这个过程涉及两个比较重要的概念回流和重绘，DOM结点都是以盒模型形式存在，需要浏览器去计算位置和宽度等，这个过程就是回流。等到页面的宽高，大小，颜色等属性确定下来后，浏览器开始绘制内容，这个过程叫做重绘。浏览器刚打开页面一定要经过这两个过程的，但是这个过程非常非常非常消耗性能，所以我们应该尽量减少页面的回流和重绘</p>\n<h3>回流</h3>\n<p>当Render Tree中部分或全部元素的尺寸、结构、或某些属性发生改变时，浏览器重新渲染部分或全部文档的过程称为回流。</p>\n<p><strong>会导致回流的操作：</strong></p>\n<ul>\n<li>页面首次渲染</li>\n<li>浏览器窗口大小发生改变</li>\n<li>元素尺寸或位置发生改变</li>\n<li>元素内容变化（文字数量或图片大小等等）</li>\n<li>元素字体大小变化</li>\n<li>添加或者删除可见的DOM元素</li>\n<li>激活CSS伪类（例如：:hover）</li>\n<li>查询某些属性或调用某些方法</li>\n</ul>\n<p><strong>一些常用且会导致回流的属性和方法：</strong></p>\n<ul>\n<li>clientWidth、clientHeight、clientTop、clientLeft</li>\n<li>offsetWidth、offsetHeight、offsetTop、offsetLeft</li>\n<li>scrollWidth、scrollHeight、scrollTop、scrollLeft</li>\n<li>scrollIntoView()、scrollIntoViewIfNeeded()</li>\n<li>getComputedStyle()</li>\n<li>getBoundingClientRect()</li>\n<li>scrollTo()</li>\n</ul>\n<h3>重绘</h3>\n<p>当页面中元素样式的改变并不影响它在文档流中的位置时（例如：color、background-color、visibility等），浏览器会将新样式赋予给元素并重新绘制它，这个过程称为重绘。</p>\n<h3>针对回流与重绘优化</h3>\n<p><strong>CSS</strong></p>\n<ul>\n<li>避免使用table布局。</li>\n<li>尽可能在DOM树的最末端改变class。</li>\n<li>避免设置多层内联样式。</li>\n<li>将动画效果应用到position属性为absolute或fixed的元素上。</li>\n<li>避免使用CSS表达式（例如：calc()）。</li>\n</ul>\n<p><strong>JS</strong></p>\n<ul>\n<li>避免频繁操作样式，最好一次性重写style属性，或者将样式列表定义为class并一次性更改class属性。</li>\n<li>避免频繁操作DOM，创建一个documentFragment，在它上面应用所有DOM操作，最后再把它添加到文档中。</li>\n<li>也可以先为元素设置display: none，操作结束后再把它显示出来。因为在display属性为none的元素上进行的DOM操作不会引发回流和重绘。</li>\n<li>避免频繁读取会引发回流/重绘的属性，如果确实需要多次使用，就用一个变量缓存起来。</li>\n<li>对具有复杂动画的元素使用绝对定位，使它脱离文档流，否则会引起父元素及后续元素频繁回流。</li>\n</ul>\n<h2>断开连接：TCP 四次挥手</h2>\n<p>当数据传送完毕，需要断开 tcp 连接，此时发起 tcp 四次挥手。<br>\n<img src=\"https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/2/27/1692f41b21b32870~tplv-t2oaga2asx-watermark.awebp\" alt=\"四次挥手\"></p>\n<ol>\n<li><strong>发起方向被动方发送报文，<code>Fin</code>、<code>Ack</code>、<code>Seq</code>，表示已经没有数据传输了。并进入 <code>FIN_WAIT_1</code> 状态。</strong><br>\n(第一次挥手：由浏览器发起的，发送给服务器，我请求报文发送完了，你准备关闭吧)</li>\n<li><strong>被动方发送报文，<code>Ack</code>、<code>Seq</code>，表示同意关闭请求进入<code>CLOSE_WAIT</code>状态。此时主机发起方进入 <code>FIN_WAIT_2</code> 状态。</strong><br>\n(第二次挥手：由服务器发起的，告诉浏览器，我请求报文接受完了，我准备关闭了，你也准备吧)</li>\n<li><strong>被动方向发起方发送报文段，<code>Fin</code>、<code>Ack</code>、<code>Seq</code>，请求关闭连接。并进入 <code>LAST_ACK</code> 状态。</strong><br>\n(第三次挥手：由服务器发起，告诉浏览器，我响应报文发送完了，你准备关闭吧)</li>\n<li><strong>发起方向被动方发送报文段，<code>Ack</code>、<code>Seq</code>。然后进入等待 <code>TIME_WAIT</code> 状态。被动方收到发起方的报文段以后关闭连接。发起方等待一定时间未收到回复，则正常关闭。</strong><br>\n(第四次挥手：由浏览器发起，告诉服务器，我响应报文接受完了，我准备关闭了，你也准备吧)</li>\n</ol>\n<h3>挥手为什么需要四次?</h3>\n<p>因为当服务端收到客户端的SYN连接请求报文后，可以直接发送SYN+ACK报文。其中ACK报文是用来应答的，SYN报文是用来同步的。<strong>但是关闭连接时，当服务端收到FIN报文时，很可能并不会立即关闭SOCKET，所以只能先回复一个ACK报文，告诉客户端，“你发的FIN报文我收到了”。只有等到我服务端所有的报文都发送完了，我才能发送FIN报文</strong>，因此不能一起发送。故需要四次挥手</p>\n"},{"title":"解决在scroll-view中使用sticky无效","date":"2020-10-16T01:52:26.000Z","_content":"\n>在小程序的scroll-view使用直接sticky粘性定位会出现无效问题。解决方法：用一个view包住所有子项。\n\n<!-- more -->\n\n```css\n.container{\n  width: 100%;\n  height: 800rpx;\n}\n.header {\n  position: sticky;\n  position: -webkit-sticky;\n  top: 0;\n  width: 100%;\n  height: 120rpx;\n  background-color: black;\n}\n.content {\n  width: 100%;\n  height: 3000rpx;\n  background-color: red;\n} \n```\n```xml\n<scroll-view class=\"container\">\n  <view>\n    <view class=\"header\"></view>  \n    <view class=\"content\"></view>\n  </view>\n</scroll-view>\n```\n","source":"_posts/在scroll-view中使用sticky.md","raw":"---\ntitle: 解决在scroll-view中使用sticky无效\ndate: 2020-10-16 09:52:26\ncategories:\n- 微信小程序\ntags:\n- 工作中遇到的问题\n# thumbnail:\n---\n\n>在小程序的scroll-view使用直接sticky粘性定位会出现无效问题。解决方法：用一个view包住所有子项。\n\n<!-- more -->\n\n```css\n.container{\n  width: 100%;\n  height: 800rpx;\n}\n.header {\n  position: sticky;\n  position: -webkit-sticky;\n  top: 0;\n  width: 100%;\n  height: 120rpx;\n  background-color: black;\n}\n.content {\n  width: 100%;\n  height: 3000rpx;\n  background-color: red;\n} \n```\n```xml\n<scroll-view class=\"container\">\n  <view>\n    <view class=\"header\"></view>  \n    <view class=\"content\"></view>\n  </view>\n</scroll-view>\n```\n","slug":"在scroll-view中使用sticky","published":1,"updated":"2021-05-08T09:35:04.767Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl27vhg5n000ku8q5jy6vuqlj","content":"<blockquote>\n<p>在小程序的scroll-view使用直接sticky粘性定位会出现无效问题。解决方法：用一个view包住所有子项。</p>\n</blockquote>\n<a id=\"more\"></a>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.container</span>&#123;</span><br><span class=\"line\">  <span class=\"attribute\">width</span>: <span class=\"number\">100%</span>;</span><br><span class=\"line\">  <span class=\"attribute\">height</span>: <span class=\"number\">800</span>rpx;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-class\">.header</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">position</span>: sticky;</span><br><span class=\"line\">  <span class=\"attribute\">position</span>: -webkit-sticky;</span><br><span class=\"line\">  <span class=\"attribute\">top</span>: <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"attribute\">width</span>: <span class=\"number\">100%</span>;</span><br><span class=\"line\">  <span class=\"attribute\">height</span>: <span class=\"number\">120</span>rpx;</span><br><span class=\"line\">  <span class=\"attribute\">background-color</span>: black;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-class\">.content</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">width</span>: <span class=\"number\">100%</span>;</span><br><span class=\"line\">  <span class=\"attribute\">height</span>: <span class=\"number\">3000</span>rpx;</span><br><span class=\"line\">  <span class=\"attribute\">background-color</span>: red;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">scroll-view</span> <span class=\"attr\">class</span>=<span class=\"string\">\"container\"</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">view</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">view</span> <span class=\"attr\">class</span>=<span class=\"string\">\"header\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">view</span>&gt;</span>  </span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">view</span> <span class=\"attr\">class</span>=<span class=\"string\">\"content\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">view</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">view</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">scroll-view</span>&gt;</span></span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p>在小程序的scroll-view使用直接sticky粘性定位会出现无效问题。解决方法：用一个view包住所有子项。</p>\n</blockquote>","more":"<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.container</span>&#123;</span><br><span class=\"line\">  <span class=\"attribute\">width</span>: <span class=\"number\">100%</span>;</span><br><span class=\"line\">  <span class=\"attribute\">height</span>: <span class=\"number\">800</span>rpx;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-class\">.header</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">position</span>: sticky;</span><br><span class=\"line\">  <span class=\"attribute\">position</span>: -webkit-sticky;</span><br><span class=\"line\">  <span class=\"attribute\">top</span>: <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"attribute\">width</span>: <span class=\"number\">100%</span>;</span><br><span class=\"line\">  <span class=\"attribute\">height</span>: <span class=\"number\">120</span>rpx;</span><br><span class=\"line\">  <span class=\"attribute\">background-color</span>: black;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-class\">.content</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">width</span>: <span class=\"number\">100%</span>;</span><br><span class=\"line\">  <span class=\"attribute\">height</span>: <span class=\"number\">3000</span>rpx;</span><br><span class=\"line\">  <span class=\"attribute\">background-color</span>: red;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">scroll-view</span> <span class=\"attr\">class</span>=<span class=\"string\">\"container\"</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">view</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">view</span> <span class=\"attr\">class</span>=<span class=\"string\">\"header\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">view</span>&gt;</span>  </span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">view</span> <span class=\"attr\">class</span>=<span class=\"string\">\"content\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">view</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">view</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">scroll-view</span>&gt;</span></span><br></pre></td></tr></table></figure>"},{"title":"小程序原生组件页面层级问题","catalog":false,"date":"2020-03-27T08:33:54.000Z","subtitle":null,"header-img":null,"_content":"\n>为什么小程序 map、canvas、video、textarea  组件总是在最上层？\n\nmap、canvas、video、textarea 是由客户端创建的原生组件，原生组件的层级是最高的，所以页面中的其他组件无论设置 z-index 为多少，都无法盖在原生组件上。 原生组件暂时还无法放在 scroll-view 上，也无法对原生组件设置 css 动画,这个是小程序的设计问题。\n\n## 解决方法\n使用小程序提供的原生组件```cover-view```与```cover-image```替换需要置顶的```view```与```image```\n\n## 缺点\n```cover-view```与```cover-image```有很多缺陷，待官方更新\n[官方文档](https://developers.weixin.qq.com/miniprogram/dev/component/cover-view.html)","source":"_posts/小程序原生组件页面层级问题.md","raw":"---\ntitle: 小程序原生组件页面层级问题\ncatalog: false\ndate: 2020-03-27 16:33:54\nsubtitle:\nheader-img:\ncategories:\n- 微信小程序\ntags:\n- 工作中遇到的问题\n---\n\n>为什么小程序 map、canvas、video、textarea  组件总是在最上层？\n\nmap、canvas、video、textarea 是由客户端创建的原生组件，原生组件的层级是最高的，所以页面中的其他组件无论设置 z-index 为多少，都无法盖在原生组件上。 原生组件暂时还无法放在 scroll-view 上，也无法对原生组件设置 css 动画,这个是小程序的设计问题。\n\n## 解决方法\n使用小程序提供的原生组件```cover-view```与```cover-image```替换需要置顶的```view```与```image```\n\n## 缺点\n```cover-view```与```cover-image```有很多缺陷，待官方更新\n[官方文档](https://developers.weixin.qq.com/miniprogram/dev/component/cover-view.html)","slug":"小程序原生组件页面层级问题","published":1,"updated":"2021-07-27T08:46:25.883Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl27vhg5p000nu8q55obzn2ad","content":"<blockquote>\n<p>为什么小程序 map、canvas、video、textarea  组件总是在最上层？</p>\n</blockquote>\n<p>map、canvas、video、textarea 是由客户端创建的原生组件，原生组件的层级是最高的，所以页面中的其他组件无论设置 z-index 为多少，都无法盖在原生组件上。 原生组件暂时还无法放在 scroll-view 上，也无法对原生组件设置 css 动画,这个是小程序的设计问题。</p>\n<h2 id=\"解决方法\">解决方法</h2>\n<p>使用小程序提供的原生组件<code>cover-view</code>与<code>cover-image</code>替换需要置顶的<code>view</code>与<code>image</code></p>\n<h2 id=\"缺点\">缺点</h2>\n<p><code>cover-view</code>与<code>cover-image</code>有很多缺陷，待官方更新<br>\n<a href=\"https://developers.weixin.qq.com/miniprogram/dev/component/cover-view.html\" target=\"_blank\" rel=\"noopener\">官方文档</a></p>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>为什么小程序 map、canvas、video、textarea  组件总是在最上层？</p>\n</blockquote>\n<p>map、canvas、video、textarea 是由客户端创建的原生组件，原生组件的层级是最高的，所以页面中的其他组件无论设置 z-index 为多少，都无法盖在原生组件上。 原生组件暂时还无法放在 scroll-view 上，也无法对原生组件设置 css 动画,这个是小程序的设计问题。</p>\n<h2>解决方法</h2>\n<p>使用小程序提供的原生组件<code>cover-view</code>与<code>cover-image</code>替换需要置顶的<code>view</code>与<code>image</code></p>\n<h2>缺点</h2>\n<p><code>cover-view</code>与<code>cover-image</code>有很多缺陷，待官方更新<br>\n<a href=\"https://developers.weixin.qq.com/miniprogram/dev/component/cover-view.html\" target=\"_blank\" rel=\"noopener\">官方文档</a></p>\n"},{"title":"微信小程序后台播放音频","catalog":true,"toc_nav_num":true,"date":"2020-11-02T02:46:27.000Z","_content":"\n微信小程序播放音频途中息屏继续播放，或者后台接收消息提醒功能配置。\n\n<!-- more -->\n\n### 全局配置\n实现后台播放须在`app.js`中做出声明，[官方文档](https://developers.weixin.qq.com/miniprogram/dev/reference/configuration/app.html#requiredBackgroundModes)。\n\n```js\n\"requiredBackgroundModes\": [\n    \"audio\"\n  ],\n```\n\n### 播放音频方法改动\n要后台播放音频不能用`audio`组件，须换成[api](https://developers.weixin.qq.com/miniprogram/dev/api/media/background-audio/BackgroundAudioManager.html)形式播放音频。\n```js\nconst backgroundAudioManager = wx.getBackgroundAudioManager()\n\nbackgroundAudioManager.title = '标题'\nbackgroundAudioManager.epname = '此时此刻'\nbackgroundAudioManager.singer = '作者'\nbackgroundAudioManager.coverImgUrl = 'http://y.gtimg.cn/music/photo_new/T002R300x300M000003rsKF44GyaSk.jpg?max_age=2592000'\n// 设置了 src 之后会自动播放\nbackgroundAudioManager.src = 'http://ws.stream.qqmusic.qq.com/M500001VfvsJ21xFqb.mp3?guid=ffffffff82def4af4b12b3cd9337d5e7&uin=346897220&vkey=6292F51E1E384E061FF02C31F716658E5C81F5594D561F2E88B854E81CAAB7806D5E4F103E55D33C16F3FAC506D1AB172DE8600B37E43FAD&fromtag=46'\n```\n\n### 监听息屏或切后台\n使用`onHide`方法来监听切后台，使用`play()`方法继续播放。\n```js\nonHide(){\n    backgroundAudioManager.play()\n}\n```\n\n### 附注：uniapp开发全局设置\nuniapp小程序项目可以到`manifest.json`配置文件中的源码视图添加`\"requiredBackgroundModes\": [\"audio\"]`。\n```js\n   /* 小程序特有相关 */\n    \"mp-weixin\" : {\n        \"appid\" : \"******\",\n        \"usingComponents\" : true,\n\t\t \"requiredBackgroundModes\": [\"audio\"],\n        \"permission\" : {\n\t\t\t\"requiredBackgroundModes\" : [ \"audio\" ],\n            \"scope.userLocation\" : {\n                \"desc\" : \"获取地理位置信息\"\n            }\n        },\n        \"setting\" : {\n            \"urlCheck\" : false,\n            \"es6\" : true,\n            \"minified\" : true\n        }\n    },\n```","source":"_posts/微信小程序后台播放音频.md","raw":"---\ntitle: 微信小程序后台播放音频\ncatalog: true\ntoc_nav_num: true\ndate: 2020-11-02 10:46:27\ncategories:\n- 微信小程序\ntags:\n- 工作中遇到的问题\n---\n\n微信小程序播放音频途中息屏继续播放，或者后台接收消息提醒功能配置。\n\n<!-- more -->\n\n### 全局配置\n实现后台播放须在`app.js`中做出声明，[官方文档](https://developers.weixin.qq.com/miniprogram/dev/reference/configuration/app.html#requiredBackgroundModes)。\n\n```js\n\"requiredBackgroundModes\": [\n    \"audio\"\n  ],\n```\n\n### 播放音频方法改动\n要后台播放音频不能用`audio`组件，须换成[api](https://developers.weixin.qq.com/miniprogram/dev/api/media/background-audio/BackgroundAudioManager.html)形式播放音频。\n```js\nconst backgroundAudioManager = wx.getBackgroundAudioManager()\n\nbackgroundAudioManager.title = '标题'\nbackgroundAudioManager.epname = '此时此刻'\nbackgroundAudioManager.singer = '作者'\nbackgroundAudioManager.coverImgUrl = 'http://y.gtimg.cn/music/photo_new/T002R300x300M000003rsKF44GyaSk.jpg?max_age=2592000'\n// 设置了 src 之后会自动播放\nbackgroundAudioManager.src = 'http://ws.stream.qqmusic.qq.com/M500001VfvsJ21xFqb.mp3?guid=ffffffff82def4af4b12b3cd9337d5e7&uin=346897220&vkey=6292F51E1E384E061FF02C31F716658E5C81F5594D561F2E88B854E81CAAB7806D5E4F103E55D33C16F3FAC506D1AB172DE8600B37E43FAD&fromtag=46'\n```\n\n### 监听息屏或切后台\n使用`onHide`方法来监听切后台，使用`play()`方法继续播放。\n```js\nonHide(){\n    backgroundAudioManager.play()\n}\n```\n\n### 附注：uniapp开发全局设置\nuniapp小程序项目可以到`manifest.json`配置文件中的源码视图添加`\"requiredBackgroundModes\": [\"audio\"]`。\n```js\n   /* 小程序特有相关 */\n    \"mp-weixin\" : {\n        \"appid\" : \"******\",\n        \"usingComponents\" : true,\n\t\t \"requiredBackgroundModes\": [\"audio\"],\n        \"permission\" : {\n\t\t\t\"requiredBackgroundModes\" : [ \"audio\" ],\n            \"scope.userLocation\" : {\n                \"desc\" : \"获取地理位置信息\"\n            }\n        },\n        \"setting\" : {\n            \"urlCheck\" : false,\n            \"es6\" : true,\n            \"minified\" : true\n        }\n    },\n```","slug":"微信小程序后台播放音频","published":1,"updated":"2021-05-06T07:00:59.492Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl27vhg5q000pu8q5y6it75k7","content":"<p>微信小程序播放音频途中息屏继续播放，或者后台接收消息提醒功能配置。</p>\n<a id=\"more\"></a>\n<h3 id=\"全局配置\">全局配置</h3>\n<p>实现后台播放须在<code>app.js</code>中做出声明，<a href=\"https://developers.weixin.qq.com/miniprogram/dev/reference/configuration/app.html#requiredBackgroundModes\" target=\"_blank\" rel=\"noopener\">官方文档</a>。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">\"requiredBackgroundModes\"</span>: [</span><br><span class=\"line\">    <span class=\"string\">\"audio\"</span></span><br><span class=\"line\">  ],</span><br></pre></td></tr></table></figure>\n<h3 id=\"播放音频方法改动\">播放音频方法改动</h3>\n<p>要后台播放音频不能用<code>audio</code>组件，须换成<a href=\"https://developers.weixin.qq.com/miniprogram/dev/api/media/background-audio/BackgroundAudioManager.html\" target=\"_blank\" rel=\"noopener\">api</a>形式播放音频。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> backgroundAudioManager = wx.getBackgroundAudioManager()</span><br><span class=\"line\"></span><br><span class=\"line\">backgroundAudioManager.title = <span class=\"string\">'标题'</span></span><br><span class=\"line\">backgroundAudioManager.epname = <span class=\"string\">'此时此刻'</span></span><br><span class=\"line\">backgroundAudioManager.singer = <span class=\"string\">'作者'</span></span><br><span class=\"line\">backgroundAudioManager.coverImgUrl = <span class=\"string\">'http://y.gtimg.cn/music/photo_new/T002R300x300M000003rsKF44GyaSk.jpg?max_age=2592000'</span></span><br><span class=\"line\"><span class=\"comment\">// 设置了 src 之后会自动播放</span></span><br><span class=\"line\">backgroundAudioManager.src = <span class=\"string\">'http://ws.stream.qqmusic.qq.com/M500001VfvsJ21xFqb.mp3?guid=ffffffff82def4af4b12b3cd9337d5e7&amp;uin=346897220&amp;vkey=6292F51E1E384E061FF02C31F716658E5C81F5594D561F2E88B854E81CAAB7806D5E4F103E55D33C16F3FAC506D1AB172DE8600B37E43FAD&amp;fromtag=46'</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"监听息屏或切后台\">监听息屏或切后台</h3>\n<p>使用<code>onHide</code>方法来监听切后台，使用<code>play()</code>方法继续播放。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">onHide()&#123;</span><br><span class=\"line\">    backgroundAudioManager.play()</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"附注uniapp开发全局设置\">附注：uniapp开发全局设置</h3>\n<p>uniapp小程序项目可以到<code>manifest.json</code>配置文件中的源码视图添加<code>&quot;requiredBackgroundModes&quot;: [&quot;audio&quot;]</code>。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* 小程序特有相关 */</span></span><br><span class=\"line\"> <span class=\"string\">\"mp-weixin\"</span> : &#123;</span><br><span class=\"line\">     <span class=\"string\">\"appid\"</span> : <span class=\"string\">\"******\"</span>,</span><br><span class=\"line\">     <span class=\"string\">\"usingComponents\"</span> : <span class=\"literal\">true</span>,</span><br><span class=\"line\"><span class=\"string\">\"requiredBackgroundModes\"</span>: [<span class=\"string\">\"audio\"</span>],</span><br><span class=\"line\">     <span class=\"string\">\"permission\"</span> : &#123;</span><br><span class=\"line\"><span class=\"string\">\"requiredBackgroundModes\"</span> : [ <span class=\"string\">\"audio\"</span> ],</span><br><span class=\"line\">         <span class=\"string\">\"scope.userLocation\"</span> : &#123;</span><br><span class=\"line\">             <span class=\"string\">\"desc\"</span> : <span class=\"string\">\"获取地理位置信息\"</span></span><br><span class=\"line\">         &#125;</span><br><span class=\"line\">     &#125;,</span><br><span class=\"line\">     <span class=\"string\">\"setting\"</span> : &#123;</span><br><span class=\"line\">         <span class=\"string\">\"urlCheck\"</span> : <span class=\"literal\">false</span>,</span><br><span class=\"line\">         <span class=\"string\">\"es6\"</span> : <span class=\"literal\">true</span>,</span><br><span class=\"line\">         <span class=\"string\">\"minified\"</span> : <span class=\"literal\">true</span></span><br><span class=\"line\">     &#125;</span><br><span class=\"line\"> &#125;,</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"<p>微信小程序播放音频途中息屏继续播放，或者后台接收消息提醒功能配置。</p>","more":"<h3>全局配置</h3>\n<p>实现后台播放须在<code>app.js</code>中做出声明，<a href=\"https://developers.weixin.qq.com/miniprogram/dev/reference/configuration/app.html#requiredBackgroundModes\" target=\"_blank\" rel=\"noopener\">官方文档</a>。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">\"requiredBackgroundModes\"</span>: [</span><br><span class=\"line\">    <span class=\"string\">\"audio\"</span></span><br><span class=\"line\">  ],</span><br></pre></td></tr></table></figure>\n<h3>播放音频方法改动</h3>\n<p>要后台播放音频不能用<code>audio</code>组件，须换成<a href=\"https://developers.weixin.qq.com/miniprogram/dev/api/media/background-audio/BackgroundAudioManager.html\" target=\"_blank\" rel=\"noopener\">api</a>形式播放音频。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> backgroundAudioManager = wx.getBackgroundAudioManager()</span><br><span class=\"line\"></span><br><span class=\"line\">backgroundAudioManager.title = <span class=\"string\">'标题'</span></span><br><span class=\"line\">backgroundAudioManager.epname = <span class=\"string\">'此时此刻'</span></span><br><span class=\"line\">backgroundAudioManager.singer = <span class=\"string\">'作者'</span></span><br><span class=\"line\">backgroundAudioManager.coverImgUrl = <span class=\"string\">'http://y.gtimg.cn/music/photo_new/T002R300x300M000003rsKF44GyaSk.jpg?max_age=2592000'</span></span><br><span class=\"line\"><span class=\"comment\">// 设置了 src 之后会自动播放</span></span><br><span class=\"line\">backgroundAudioManager.src = <span class=\"string\">'http://ws.stream.qqmusic.qq.com/M500001VfvsJ21xFqb.mp3?guid=ffffffff82def4af4b12b3cd9337d5e7&amp;uin=346897220&amp;vkey=6292F51E1E384E061FF02C31F716658E5C81F5594D561F2E88B854E81CAAB7806D5E4F103E55D33C16F3FAC506D1AB172DE8600B37E43FAD&amp;fromtag=46'</span></span><br></pre></td></tr></table></figure>\n<h3>监听息屏或切后台</h3>\n<p>使用<code>onHide</code>方法来监听切后台，使用<code>play()</code>方法继续播放。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">onHide()&#123;</span><br><span class=\"line\">    backgroundAudioManager.play()</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3>附注：uniapp开发全局设置</h3>\n<p>uniapp小程序项目可以到<code>manifest.json</code>配置文件中的源码视图添加<code>&quot;requiredBackgroundModes&quot;: [&quot;audio&quot;]</code>。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* 小程序特有相关 */</span></span><br><span class=\"line\"> <span class=\"string\">\"mp-weixin\"</span> : &#123;</span><br><span class=\"line\">     <span class=\"string\">\"appid\"</span> : <span class=\"string\">\"******\"</span>,</span><br><span class=\"line\">     <span class=\"string\">\"usingComponents\"</span> : <span class=\"literal\">true</span>,</span><br><span class=\"line\"><span class=\"string\">\"requiredBackgroundModes\"</span>: [<span class=\"string\">\"audio\"</span>],</span><br><span class=\"line\">     <span class=\"string\">\"permission\"</span> : &#123;</span><br><span class=\"line\"><span class=\"string\">\"requiredBackgroundModes\"</span> : [ <span class=\"string\">\"audio\"</span> ],</span><br><span class=\"line\">         <span class=\"string\">\"scope.userLocation\"</span> : &#123;</span><br><span class=\"line\">             <span class=\"string\">\"desc\"</span> : <span class=\"string\">\"获取地理位置信息\"</span></span><br><span class=\"line\">         &#125;</span><br><span class=\"line\">     &#125;,</span><br><span class=\"line\">     <span class=\"string\">\"setting\"</span> : &#123;</span><br><span class=\"line\">         <span class=\"string\">\"urlCheck\"</span> : <span class=\"literal\">false</span>,</span><br><span class=\"line\">         <span class=\"string\">\"es6\"</span> : <span class=\"literal\">true</span>,</span><br><span class=\"line\">         <span class=\"string\">\"minified\"</span> : <span class=\"literal\">true</span></span><br><span class=\"line\">     &#125;</span><br><span class=\"line\"> &#125;,</span><br></pre></td></tr></table></figure>"},{"title":"弹性布局flex详解","subtitle":"flex学习详细记录，理解各个属性的特性及用法。","header-img":"/img/article_header/article_header.png","catalog":true,"toc_nav_num":true,"date":"2020-05-11T13:17:04.000Z","updateDate":"2021-05-05T13:17:04.000Z","toc":true,"_content":" \n\n## 背景\nFlex是`Flexible Box`的缩写，意为”**弹性布局**”，用来为盒状模型提供最大的灵活性,旨在提供一个更有效地布局、对齐方式，并且能够使容器中的子元素大小未知或动态变化情况下仍然能够分配好子元素之间的空间。\n\nFlex 布局的主要思想是使父容器能够调节子元素的宽度/高度（和排列顺序），从而能够最好地填充可用空间 **（主要是为了适应所有类型的显示设备和屏幕尺寸）** flex布容器能够放大子元素使之尽可能填充可用空间，也可以收缩子元素使之不溢出。\n\n最重要的是，**flexbox布局与方向无关**，不同于常规布局（基于垂直的块（block）和基于水平的内联（inline））。 虽然传统布局适用于页面，但它们对于大型或复杂的应用程序布局来说缺乏灵活性（特别是在改变方向，调整大小，拉伸，收缩等方面）。\n\n注:\n* **Flexbox布局最适合应用程序的组件和小规模布局，而 Gird 布局则适用于较大规模的布局。**\n* **设为Flex布局以后，子元素的float、clear和vertical-align属性将失效。**\n\n<!-- more -->\n\n## 基本概念\n> 采用 Flex 布局的元素，称为 Flex 容器（flex container），简称\"容器\"。它的所有子元素自动成为容器成员，称为 Flex 项目（flex item），简称\"项目\"。\n![基本概念](http://img.kyootah.com/2021/04/10/0426548eccf4c.png)\n  \n\n\n## flex容器属性\n\n ![属性](http://img.kyootah.com/2021/04/10/2af8fcd984ece.png)\n\n### display:flex;\n\n![](http://img.kyootah.com/2021/04/14/95163b9178a2a.png) \n\n### flex-direction\n设置轴的方向。\n* row（默认）：主轴水平方向，起点左端\n* row-reverse：主轴水平方向，起点右端\n* column：主轴垂直方向，起点上方\n* column-reverse：主轴垂直方向，起点下方\n  \n![](http://img.kyootah.com/2021/04/14/6f1554a56176c.png)\n![](http://img.kyootah.com/2021/04/14/74686ba65f227.png) \n\n \n### flex-wrap\n* nowrap（默认）：不换行\n* wrap：换行，第一行在上方\n* wrap-reverse：换行，第一行在下方\n\n![](http://img.kyootah.com/2021/04/14/07cbf0032f8d3.png)\n\n\n### justify-content\n* flex-start（默认值）：左对齐\n* flex-end：右对齐\n* center：居中\n* space-between：两端对齐，中间间隔平分\n* space-around：每个项目间隔相等排列\n\n![](http://img.kyootah.com/2021/04/14/b1ceacb101b05.png)\n![](http://img.kyootah.com/2021/04/14/7fc8fd8191def.png)\n\n### align-items（单轴线）\n* stretch（默认）：如果项目没设高度或者高度auto，将占满容器高度\n* flex-start：交叉轴的起点对齐\n* flex-end：交叉轴的终点对齐\n* center：交叉轴的中位点对齐\n* baseline：项目的第一页文字的基线对齐\n\n![](http://img.kyootah.com/2021/04/14/76e873c7bfcaf.png)\n\n对于 `align-items: stretch` 来说，必须将每一个矩形子元素(flex项)的 **高度设置为 auto**，否则 height 属性将会覆盖该 stretch，如下图\n![](http://img.kyootah.com/2021/04/15/45cc6510a98cf.png)\n\n对于 `align-items: baseline` 来说，对齐方式基于 **第一行文本内容高度**,要注意如果去掉段落标签或者没内容，矩形子元素(flex项)就会按照每个矩形的底部对齐,如下图：\n![](http://img.kyootah.com/2021/04/15/b6d6c708b75d3.png)\n\n### align-content（多轴线）\nalign-content属性定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用。\n* stretch（默认）\n* flex-start\n* flex-end\n* center\n* space-between：各轴线容器两端对齐，中间间隔均等分\n* space-around：轴线再容器间隙均等分（两边会有间隙）\n\n![](http://img.kyootah.com/2021/04/15/4acd07e1cf3eb.png)\n\n\n## 项目属性\n项目属性用来设置容器内项目（某个元素）的相关样式，用于设置项目的尺寸、位置、对齐方式\n基本语法：\n* order \n* flex-basis\n* flex-grow\n* flex-shrink\n* flex  \n* align-self\n\n### order\n`order` 属性定义项目的排列顺序。数值越小，排列越靠前，默认为0\n```html\n<div class=\"flexBox box\">\n    <div style=\"order:1\">1</div>\n    <div style=\"order:0\">0</div>\n    <div style=\"order:2\">2</div>\n    <div style=\"order:4\">4</div>\n    <div style=\"order:3\">3</div>\n    <div style=\"order:-1\">-1</div>\n</div>\n```\n![](http://img.kyootah.com/2021/04/22/7b053849d3a5d.png)\n\n\n### Flex-Basis\n`flex-basis` 控制一个子元素(flex项)的默认大小，但是它可以被其他的 Flexbox 属性影响（默认值auto）。\n\n下图可以看出它与`width`的作用相同，都能设置宽度，当两者同时存在时Flex-Basis会覆盖width\n![](http://img.kyootah.com/2021/04/23/3b7197ac49190.png)\n![](http://img.kyootah.com/2021/04/23/c1498ad79fc38.png)\n\n但是他们之间还是有不同的？flex-basis 对应于 flex 轴线而言的：\n![](http://img.kyootah.com/2021/04/23/5c881cfec67e9.png)\nflex-basis 影响元素在主轴(main axis)上的大小。\n`flex-direction`改变为`colunm`则从width切换到影响height\n \n\n### flex-grow（拉伸）\n属性定义项目的放大比例，默认为0，不放大。\n注：**flex-grow是一个相对值，拉伸放大的区域大小取决于容器承载元素后剩下的区域大小，并根据所设置flex-grow的占比进行比例拉伸**。\n示例：\n我们先将所有矩形元素（flex项）设置为相同的width,100px,与设置间距(margin)10px，容器宽度大小为1100px:\n![](http://img.kyootah.com/2021/04/26/5ce176a9f6c4a.png)\n现在我们把所有正方形的`flex-grow`设置为1，默认为0（有剩余地方也不做拉伸填充）,\n可以看到方块均匀地拉伸并把剩下的空间填充完整（间隙是因为设置了10px的margin）\n![](http://img.kyootah.com/2021/05/06/b35341e49128e.png)\n\n现在我们把第一个正方形的`flex-grow`设置为2,\n这个时候第一个方块的宽度为266.68px，拉伸了`166.68px`,其他方块的的宽度为183.34px,拉伸了`83.34px`,可以看到拉伸的大小为其他方块的2倍，这里可以得出方块总flex-grow数量为2+1+1+1=7,第一块占2/7,其余方块占1/7\n![](http://img.kyootah.com/2021/05/06/a223eb133e6b0.png)\n\n总结：每个子元素的`flex-grow`都是按比例拉伸的（默认为0，不拉伸），\n同`flex-basis`一样`flex-grow`也是只作用与主轴的默认水平方向影响的只有`width`，除非改变`flex-direction`的值。\n\n### Flex Shrink（收缩）\n与`flex-grow`同理但相反，`flex-shrink`设置的是当容器主轴长度不足以承载所有项目且`flex-wrap`没有设置换行的情况下，项目对应的收缩比例。\n同`flex-grow`一样，是相对值，`flex-shrink`默认值是1，所以他们允许被收缩。\n例：我们先把容器宽度设置500px，每个方块宽高设置100px\n![](http://img.kyootah.com/2021/05/06/caa72ce543167.png)\n我们把容器宽度从500px缩小到300px，可以看到各个项目均等比例缩小了。\n![](http://img.kyootah.com/2021/05/06/a4d53f5e50f56.png)\n这个时候我们把第二个方块的`flex-shrink`设置为**0**,不收缩，可以看到方块2就不会进行收缩固定了原来的宽度\n![](http://img.kyootah.com/2021/05/06/43fdc7dd47c8d.png)\n这个时候有的小伙伴就要问，如果全部都设置为0呢？可以从下图看到，全部设置不收缩的情况下容器就会被撑开了。\n![](http://img.kyootah.com/2021/05/06/965f7894183a7.png)\n现在我们来研究一下收缩的大小问题。\n`flex-shrink`收缩跟`flex-grow`一样是根据项目`flex-shrink`设置的总比例来收缩的。\n\n我们试下把第一个方块`flex-shrink`设置为2，第二块设置为3。\n![](http://img.kyootah.com/2021/05/06/7d80718c1f77b.png)\n最终得到第一块宽度50px,第二块宽度25px,其余75px,对应第二块跟第二块的收缩大小是其他方块的一倍跟两倍，这个是怎么来的呢？让我们列个表格计算一下。\n![](http://img.kyootah.com/2021/05/06/7638b10032503.png)\n根据表格可以看出：当容器宽度为300px时，容器内项目总宽度500px，超出的200px分别按比例在各个方块内扣除了，方块一收缩了200px的2/8,方块二3/8,其余1/8。\n这个时候我们设置一下把第一个方块设置`flex-shrink`为100\n可以看出方块1不见了，width变成了0\n![](http://img.kyootah.com/2021/05/06/1a11daac4434e.png)\n这里可以看出当收缩比例占比超出项目宽度的时候，项目的主轴长度会变成0，然后其余项目按比例收缩剩余的大小。这里200px分给了项目1还剩150px,然后项目2对应收缩了150px的3/6，其他项目收缩1/6就可以得出上图结果了。\n\n总结：`flex-shrink`设置的是当项目总宽度大于容器宽度且没设置换行时项目的收缩比例，一样也是只作用与主轴的默认水平方向影响的只有`width`，除非改变`flex-direction`的值。\n\n### flex\n`flex` 是 `flex-grow`，`flex-shrink` 和 `flex-basis` 的缩写。\n默认值是**flex:0 1 auto** 即：flex-grow:0;flex-shrink:1;flex-basis:auto;\n","source":"_posts/弹性布局flex详解.md","raw":"---\ntitle: 弹性布局flex详解\nsubtitle: \"flex学习详细记录，理解各个属性的特性及用法。\"\nheader-img: \"/img/article_header/article_header.png\"\ncatalog: true\ntoc_nav_num: true\ndate: 2020-05-11 21:17:04\nupdateDate: 2021-05-05 21:17:04\ncategories:\n- css\ntags:\n- css\n- flex弹性布局\ntoc: true\n# top: 10\n\n \n---\n \n\n## 背景\nFlex是`Flexible Box`的缩写，意为”**弹性布局**”，用来为盒状模型提供最大的灵活性,旨在提供一个更有效地布局、对齐方式，并且能够使容器中的子元素大小未知或动态变化情况下仍然能够分配好子元素之间的空间。\n\nFlex 布局的主要思想是使父容器能够调节子元素的宽度/高度（和排列顺序），从而能够最好地填充可用空间 **（主要是为了适应所有类型的显示设备和屏幕尺寸）** flex布容器能够放大子元素使之尽可能填充可用空间，也可以收缩子元素使之不溢出。\n\n最重要的是，**flexbox布局与方向无关**，不同于常规布局（基于垂直的块（block）和基于水平的内联（inline））。 虽然传统布局适用于页面，但它们对于大型或复杂的应用程序布局来说缺乏灵活性（特别是在改变方向，调整大小，拉伸，收缩等方面）。\n\n注:\n* **Flexbox布局最适合应用程序的组件和小规模布局，而 Gird 布局则适用于较大规模的布局。**\n* **设为Flex布局以后，子元素的float、clear和vertical-align属性将失效。**\n\n<!-- more -->\n\n## 基本概念\n> 采用 Flex 布局的元素，称为 Flex 容器（flex container），简称\"容器\"。它的所有子元素自动成为容器成员，称为 Flex 项目（flex item），简称\"项目\"。\n![基本概念](http://img.kyootah.com/2021/04/10/0426548eccf4c.png)\n  \n\n\n## flex容器属性\n\n ![属性](http://img.kyootah.com/2021/04/10/2af8fcd984ece.png)\n\n### display:flex;\n\n![](http://img.kyootah.com/2021/04/14/95163b9178a2a.png) \n\n### flex-direction\n设置轴的方向。\n* row（默认）：主轴水平方向，起点左端\n* row-reverse：主轴水平方向，起点右端\n* column：主轴垂直方向，起点上方\n* column-reverse：主轴垂直方向，起点下方\n  \n![](http://img.kyootah.com/2021/04/14/6f1554a56176c.png)\n![](http://img.kyootah.com/2021/04/14/74686ba65f227.png) \n\n \n### flex-wrap\n* nowrap（默认）：不换行\n* wrap：换行，第一行在上方\n* wrap-reverse：换行，第一行在下方\n\n![](http://img.kyootah.com/2021/04/14/07cbf0032f8d3.png)\n\n\n### justify-content\n* flex-start（默认值）：左对齐\n* flex-end：右对齐\n* center：居中\n* space-between：两端对齐，中间间隔平分\n* space-around：每个项目间隔相等排列\n\n![](http://img.kyootah.com/2021/04/14/b1ceacb101b05.png)\n![](http://img.kyootah.com/2021/04/14/7fc8fd8191def.png)\n\n### align-items（单轴线）\n* stretch（默认）：如果项目没设高度或者高度auto，将占满容器高度\n* flex-start：交叉轴的起点对齐\n* flex-end：交叉轴的终点对齐\n* center：交叉轴的中位点对齐\n* baseline：项目的第一页文字的基线对齐\n\n![](http://img.kyootah.com/2021/04/14/76e873c7bfcaf.png)\n\n对于 `align-items: stretch` 来说，必须将每一个矩形子元素(flex项)的 **高度设置为 auto**，否则 height 属性将会覆盖该 stretch，如下图\n![](http://img.kyootah.com/2021/04/15/45cc6510a98cf.png)\n\n对于 `align-items: baseline` 来说，对齐方式基于 **第一行文本内容高度**,要注意如果去掉段落标签或者没内容，矩形子元素(flex项)就会按照每个矩形的底部对齐,如下图：\n![](http://img.kyootah.com/2021/04/15/b6d6c708b75d3.png)\n\n### align-content（多轴线）\nalign-content属性定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用。\n* stretch（默认）\n* flex-start\n* flex-end\n* center\n* space-between：各轴线容器两端对齐，中间间隔均等分\n* space-around：轴线再容器间隙均等分（两边会有间隙）\n\n![](http://img.kyootah.com/2021/04/15/4acd07e1cf3eb.png)\n\n\n## 项目属性\n项目属性用来设置容器内项目（某个元素）的相关样式，用于设置项目的尺寸、位置、对齐方式\n基本语法：\n* order \n* flex-basis\n* flex-grow\n* flex-shrink\n* flex  \n* align-self\n\n### order\n`order` 属性定义项目的排列顺序。数值越小，排列越靠前，默认为0\n```html\n<div class=\"flexBox box\">\n    <div style=\"order:1\">1</div>\n    <div style=\"order:0\">0</div>\n    <div style=\"order:2\">2</div>\n    <div style=\"order:4\">4</div>\n    <div style=\"order:3\">3</div>\n    <div style=\"order:-1\">-1</div>\n</div>\n```\n![](http://img.kyootah.com/2021/04/22/7b053849d3a5d.png)\n\n\n### Flex-Basis\n`flex-basis` 控制一个子元素(flex项)的默认大小，但是它可以被其他的 Flexbox 属性影响（默认值auto）。\n\n下图可以看出它与`width`的作用相同，都能设置宽度，当两者同时存在时Flex-Basis会覆盖width\n![](http://img.kyootah.com/2021/04/23/3b7197ac49190.png)\n![](http://img.kyootah.com/2021/04/23/c1498ad79fc38.png)\n\n但是他们之间还是有不同的？flex-basis 对应于 flex 轴线而言的：\n![](http://img.kyootah.com/2021/04/23/5c881cfec67e9.png)\nflex-basis 影响元素在主轴(main axis)上的大小。\n`flex-direction`改变为`colunm`则从width切换到影响height\n \n\n### flex-grow（拉伸）\n属性定义项目的放大比例，默认为0，不放大。\n注：**flex-grow是一个相对值，拉伸放大的区域大小取决于容器承载元素后剩下的区域大小，并根据所设置flex-grow的占比进行比例拉伸**。\n示例：\n我们先将所有矩形元素（flex项）设置为相同的width,100px,与设置间距(margin)10px，容器宽度大小为1100px:\n![](http://img.kyootah.com/2021/04/26/5ce176a9f6c4a.png)\n现在我们把所有正方形的`flex-grow`设置为1，默认为0（有剩余地方也不做拉伸填充）,\n可以看到方块均匀地拉伸并把剩下的空间填充完整（间隙是因为设置了10px的margin）\n![](http://img.kyootah.com/2021/05/06/b35341e49128e.png)\n\n现在我们把第一个正方形的`flex-grow`设置为2,\n这个时候第一个方块的宽度为266.68px，拉伸了`166.68px`,其他方块的的宽度为183.34px,拉伸了`83.34px`,可以看到拉伸的大小为其他方块的2倍，这里可以得出方块总flex-grow数量为2+1+1+1=7,第一块占2/7,其余方块占1/7\n![](http://img.kyootah.com/2021/05/06/a223eb133e6b0.png)\n\n总结：每个子元素的`flex-grow`都是按比例拉伸的（默认为0，不拉伸），\n同`flex-basis`一样`flex-grow`也是只作用与主轴的默认水平方向影响的只有`width`，除非改变`flex-direction`的值。\n\n### Flex Shrink（收缩）\n与`flex-grow`同理但相反，`flex-shrink`设置的是当容器主轴长度不足以承载所有项目且`flex-wrap`没有设置换行的情况下，项目对应的收缩比例。\n同`flex-grow`一样，是相对值，`flex-shrink`默认值是1，所以他们允许被收缩。\n例：我们先把容器宽度设置500px，每个方块宽高设置100px\n![](http://img.kyootah.com/2021/05/06/caa72ce543167.png)\n我们把容器宽度从500px缩小到300px，可以看到各个项目均等比例缩小了。\n![](http://img.kyootah.com/2021/05/06/a4d53f5e50f56.png)\n这个时候我们把第二个方块的`flex-shrink`设置为**0**,不收缩，可以看到方块2就不会进行收缩固定了原来的宽度\n![](http://img.kyootah.com/2021/05/06/43fdc7dd47c8d.png)\n这个时候有的小伙伴就要问，如果全部都设置为0呢？可以从下图看到，全部设置不收缩的情况下容器就会被撑开了。\n![](http://img.kyootah.com/2021/05/06/965f7894183a7.png)\n现在我们来研究一下收缩的大小问题。\n`flex-shrink`收缩跟`flex-grow`一样是根据项目`flex-shrink`设置的总比例来收缩的。\n\n我们试下把第一个方块`flex-shrink`设置为2，第二块设置为3。\n![](http://img.kyootah.com/2021/05/06/7d80718c1f77b.png)\n最终得到第一块宽度50px,第二块宽度25px,其余75px,对应第二块跟第二块的收缩大小是其他方块的一倍跟两倍，这个是怎么来的呢？让我们列个表格计算一下。\n![](http://img.kyootah.com/2021/05/06/7638b10032503.png)\n根据表格可以看出：当容器宽度为300px时，容器内项目总宽度500px，超出的200px分别按比例在各个方块内扣除了，方块一收缩了200px的2/8,方块二3/8,其余1/8。\n这个时候我们设置一下把第一个方块设置`flex-shrink`为100\n可以看出方块1不见了，width变成了0\n![](http://img.kyootah.com/2021/05/06/1a11daac4434e.png)\n这里可以看出当收缩比例占比超出项目宽度的时候，项目的主轴长度会变成0，然后其余项目按比例收缩剩余的大小。这里200px分给了项目1还剩150px,然后项目2对应收缩了150px的3/6，其他项目收缩1/6就可以得出上图结果了。\n\n总结：`flex-shrink`设置的是当项目总宽度大于容器宽度且没设置换行时项目的收缩比例，一样也是只作用与主轴的默认水平方向影响的只有`width`，除非改变`flex-direction`的值。\n\n### flex\n`flex` 是 `flex-grow`，`flex-shrink` 和 `flex-basis` 的缩写。\n默认值是**flex:0 1 auto** 即：flex-grow:0;flex-shrink:1;flex-basis:auto;\n","slug":"弹性布局flex详解","published":1,"updated":"2022-02-14T08:41:57.248Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl27vhg5u000tu8q5xdne0dn9","content":"<h2 id=\"背景\">背景</h2>\n<p>Flex是<code>Flexible Box</code>的缩写，意为”<strong>弹性布局</strong>”，用来为盒状模型提供最大的灵活性,旨在提供一个更有效地布局、对齐方式，并且能够使容器中的子元素大小未知或动态变化情况下仍然能够分配好子元素之间的空间。</p>\n<p>Flex 布局的主要思想是使父容器能够调节子元素的宽度/高度（和排列顺序），从而能够最好地填充可用空间 <strong>（主要是为了适应所有类型的显示设备和屏幕尺寸）</strong> flex布容器能够放大子元素使之尽可能填充可用空间，也可以收缩子元素使之不溢出。</p>\n<p>最重要的是，<strong>flexbox布局与方向无关</strong>，不同于常规布局（基于垂直的块（block）和基于水平的内联（inline））。 虽然传统布局适用于页面，但它们对于大型或复杂的应用程序布局来说缺乏灵活性（特别是在改变方向，调整大小，拉伸，收缩等方面）。</p>\n<p>注:</p>\n<ul>\n<li><strong>Flexbox布局最适合应用程序的组件和小规模布局，而 Gird 布局则适用于较大规模的布局。</strong></li>\n<li><strong>设为Flex布局以后，子元素的float、clear和vertical-align属性将失效。</strong></li>\n</ul>\n<a id=\"more\"></a>\n<h2 id=\"基本概念\">基本概念</h2>\n<blockquote>\n<p>采用 Flex 布局的元素，称为 Flex 容器（flex container），简称&quot;容器&quot;。它的所有子元素自动成为容器成员，称为 Flex 项目（flex item），简称&quot;项目&quot;。<br>\n<img src=\"http://img.kyootah.com/2021/04/10/0426548eccf4c.png\" alt=\"基本概念\"></p>\n</blockquote>\n<h2 id=\"flex容器属性\">flex容器属性</h2>\n<p><img src=\"http://img.kyootah.com/2021/04/10/2af8fcd984ece.png\" alt=\"属性\"></p>\n<h3 id=\"displayflex\">display:flex;</h3>\n<p><img src=\"http://img.kyootah.com/2021/04/14/95163b9178a2a.png\" alt></p>\n<h3 id=\"flex-direction\">flex-direction</h3>\n<p>设置轴的方向。</p>\n<ul>\n<li>row（默认）：主轴水平方向，起点左端</li>\n<li>row-reverse：主轴水平方向，起点右端</li>\n<li>column：主轴垂直方向，起点上方</li>\n<li>column-reverse：主轴垂直方向，起点下方</li>\n</ul>\n<p><img src=\"http://img.kyootah.com/2021/04/14/6f1554a56176c.png\" alt><br>\n<img src=\"http://img.kyootah.com/2021/04/14/74686ba65f227.png\" alt></p>\n<h3 id=\"flex-wrap\">flex-wrap</h3>\n<ul>\n<li>nowrap（默认）：不换行</li>\n<li>wrap：换行，第一行在上方</li>\n<li>wrap-reverse：换行，第一行在下方</li>\n</ul>\n<p><img src=\"http://img.kyootah.com/2021/04/14/07cbf0032f8d3.png\" alt></p>\n<h3 id=\"justify-content\">justify-content</h3>\n<ul>\n<li>flex-start（默认值）：左对齐</li>\n<li>flex-end：右对齐</li>\n<li>center：居中</li>\n<li>space-between：两端对齐，中间间隔平分</li>\n<li>space-around：每个项目间隔相等排列</li>\n</ul>\n<p><img src=\"http://img.kyootah.com/2021/04/14/b1ceacb101b05.png\" alt><br>\n<img src=\"http://img.kyootah.com/2021/04/14/7fc8fd8191def.png\" alt></p>\n<h3 id=\"align-items单轴线\">align-items（单轴线）</h3>\n<ul>\n<li>stretch（默认）：如果项目没设高度或者高度auto，将占满容器高度</li>\n<li>flex-start：交叉轴的起点对齐</li>\n<li>flex-end：交叉轴的终点对齐</li>\n<li>center：交叉轴的中位点对齐</li>\n<li>baseline：项目的第一页文字的基线对齐</li>\n</ul>\n<p><img src=\"http://img.kyootah.com/2021/04/14/76e873c7bfcaf.png\" alt></p>\n<p>对于 <code>align-items: stretch</code> 来说，必须将每一个矩形子元素(flex项)的 <strong>高度设置为 auto</strong>，否则 height 属性将会覆盖该 stretch，如下图<br>\n<img src=\"http://img.kyootah.com/2021/04/15/45cc6510a98cf.png\" alt></p>\n<p>对于 <code>align-items: baseline</code> 来说，对齐方式基于 <strong>第一行文本内容高度</strong>,要注意如果去掉段落标签或者没内容，矩形子元素(flex项)就会按照每个矩形的底部对齐,如下图：<br>\n<img src=\"http://img.kyootah.com/2021/04/15/b6d6c708b75d3.png\" alt></p>\n<h3 id=\"align-content多轴线\">align-content（多轴线）</h3>\n<p>align-content属性定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用。</p>\n<ul>\n<li>stretch（默认）</li>\n<li>flex-start</li>\n<li>flex-end</li>\n<li>center</li>\n<li>space-between：各轴线容器两端对齐，中间间隔均等分</li>\n<li>space-around：轴线再容器间隙均等分（两边会有间隙）</li>\n</ul>\n<p><img src=\"http://img.kyootah.com/2021/04/15/4acd07e1cf3eb.png\" alt></p>\n<h2 id=\"项目属性\">项目属性</h2>\n<p>项目属性用来设置容器内项目（某个元素）的相关样式，用于设置项目的尺寸、位置、对齐方式<br>\n基本语法：</p>\n<ul>\n<li>order</li>\n<li>flex-basis</li>\n<li>flex-grow</li>\n<li>flex-shrink</li>\n<li>flex</li>\n<li>align-self</li>\n</ul>\n<h3 id=\"order\">order</h3>\n<p><code>order</code> 属性定义项目的排列顺序。数值越小，排列越靠前，默认为0</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"flexBox box\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">style</span>=<span class=\"string\">\"order:1\"</span>&gt;</span>1<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">style</span>=<span class=\"string\">\"order:0\"</span>&gt;</span>0<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">style</span>=<span class=\"string\">\"order:2\"</span>&gt;</span>2<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">style</span>=<span class=\"string\">\"order:4\"</span>&gt;</span>4<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">style</span>=<span class=\"string\">\"order:3\"</span>&gt;</span>3<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">style</span>=<span class=\"string\">\"order:-1\"</span>&gt;</span>-1<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p><img src=\"http://img.kyootah.com/2021/04/22/7b053849d3a5d.png\" alt></p>\n<h3 id=\"flex-basis\">Flex-Basis</h3>\n<p><code>flex-basis</code> 控制一个子元素(flex项)的默认大小，但是它可以被其他的 Flexbox 属性影响（默认值auto）。</p>\n<p>下图可以看出它与<code>width</code>的作用相同，都能设置宽度，当两者同时存在时Flex-Basis会覆盖width<br>\n<img src=\"http://img.kyootah.com/2021/04/23/3b7197ac49190.png\" alt><br>\n<img src=\"http://img.kyootah.com/2021/04/23/c1498ad79fc38.png\" alt></p>\n<p>但是他们之间还是有不同的？flex-basis 对应于 flex 轴线而言的：<br>\n<img src=\"http://img.kyootah.com/2021/04/23/5c881cfec67e9.png\" alt><br>\nflex-basis 影响元素在主轴(main axis)上的大小。<br>\n<code>flex-direction</code>改变为<code>colunm</code>则从width切换到影响height</p>\n<h3 id=\"flex-grow拉伸\">flex-grow（拉伸）</h3>\n<p>属性定义项目的放大比例，默认为0，不放大。<br>\n注：<strong>flex-grow是一个相对值，拉伸放大的区域大小取决于容器承载元素后剩下的区域大小，并根据所设置flex-grow的占比进行比例拉伸</strong>。<br>\n示例：<br>\n我们先将所有矩形元素（flex项）设置为相同的width,100px,与设置间距(margin)10px，容器宽度大小为1100px:<br>\n<img src=\"http://img.kyootah.com/2021/04/26/5ce176a9f6c4a.png\" alt><br>\n现在我们把所有正方形的<code>flex-grow</code>设置为1，默认为0（有剩余地方也不做拉伸填充）,<br>\n可以看到方块均匀地拉伸并把剩下的空间填充完整（间隙是因为设置了10px的margin）<br>\n<img src=\"http://img.kyootah.com/2021/05/06/b35341e49128e.png\" alt></p>\n<p>现在我们把第一个正方形的<code>flex-grow</code>设置为2,<br>\n这个时候第一个方块的宽度为266.68px，拉伸了<code>166.68px</code>,其他方块的的宽度为183.34px,拉伸了<code>83.34px</code>,可以看到拉伸的大小为其他方块的2倍，这里可以得出方块总flex-grow数量为2+1+1+1=7,第一块占2/7,其余方块占1/7<br>\n<img src=\"http://img.kyootah.com/2021/05/06/a223eb133e6b0.png\" alt></p>\n<p>总结：每个子元素的<code>flex-grow</code>都是按比例拉伸的（默认为0，不拉伸），<br>\n同<code>flex-basis</code>一样<code>flex-grow</code>也是只作用与主轴的默认水平方向影响的只有<code>width</code>，除非改变<code>flex-direction</code>的值。</p>\n<h3 id=\"flex-shrink收缩\">Flex Shrink（收缩）</h3>\n<p>与<code>flex-grow</code>同理但相反，<code>flex-shrink</code>设置的是当容器主轴长度不足以承载所有项目且<code>flex-wrap</code>没有设置换行的情况下，项目对应的收缩比例。<br>\n同<code>flex-grow</code>一样，是相对值，<code>flex-shrink</code>默认值是1，所以他们允许被收缩。<br>\n例：我们先把容器宽度设置500px，每个方块宽高设置100px<br>\n<img src=\"http://img.kyootah.com/2021/05/06/caa72ce543167.png\" alt><br>\n我们把容器宽度从500px缩小到300px，可以看到各个项目均等比例缩小了。<br>\n<img src=\"http://img.kyootah.com/2021/05/06/a4d53f5e50f56.png\" alt><br>\n这个时候我们把第二个方块的<code>flex-shrink</code>设置为<strong>0</strong>,不收缩，可以看到方块2就不会进行收缩固定了原来的宽度<br>\n<img src=\"http://img.kyootah.com/2021/05/06/43fdc7dd47c8d.png\" alt><br>\n这个时候有的小伙伴就要问，如果全部都设置为0呢？可以从下图看到，全部设置不收缩的情况下容器就会被撑开了。<br>\n<img src=\"http://img.kyootah.com/2021/05/06/965f7894183a7.png\" alt><br>\n现在我们来研究一下收缩的大小问题。<br>\n<code>flex-shrink</code>收缩跟<code>flex-grow</code>一样是根据项目<code>flex-shrink</code>设置的总比例来收缩的。</p>\n<p>我们试下把第一个方块<code>flex-shrink</code>设置为2，第二块设置为3。<br>\n<img src=\"http://img.kyootah.com/2021/05/06/7d80718c1f77b.png\" alt><br>\n最终得到第一块宽度50px,第二块宽度25px,其余75px,对应第二块跟第二块的收缩大小是其他方块的一倍跟两倍，这个是怎么来的呢？让我们列个表格计算一下。<br>\n<img src=\"http://img.kyootah.com/2021/05/06/7638b10032503.png\" alt><br>\n根据表格可以看出：当容器宽度为300px时，容器内项目总宽度500px，超出的200px分别按比例在各个方块内扣除了，方块一收缩了200px的2/8,方块二3/8,其余1/8。<br>\n这个时候我们设置一下把第一个方块设置<code>flex-shrink</code>为100<br>\n可以看出方块1不见了，width变成了0<br>\n<img src=\"http://img.kyootah.com/2021/05/06/1a11daac4434e.png\" alt><br>\n这里可以看出当收缩比例占比超出项目宽度的时候，项目的主轴长度会变成0，然后其余项目按比例收缩剩余的大小。这里200px分给了项目1还剩150px,然后项目2对应收缩了150px的3/6，其他项目收缩1/6就可以得出上图结果了。</p>\n<p>总结：<code>flex-shrink</code>设置的是当项目总宽度大于容器宽度且没设置换行时项目的收缩比例，一样也是只作用与主轴的默认水平方向影响的只有<code>width</code>，除非改变<code>flex-direction</code>的值。</p>\n<h3 id=\"flex\">flex</h3>\n<p><code>flex</code> 是 <code>flex-grow</code>，<code>flex-shrink</code> 和 <code>flex-basis</code> 的缩写。<br>\n默认值是<strong>flex:0 1 auto</strong> 即：flex-grow:0;flex-shrink:1;flex-basis:auto;</p>\n","site":{"data":{}},"excerpt":"<h2>背景</h2>\n<p>Flex是<code>Flexible Box</code>的缩写，意为”<strong>弹性布局</strong>”，用来为盒状模型提供最大的灵活性,旨在提供一个更有效地布局、对齐方式，并且能够使容器中的子元素大小未知或动态变化情况下仍然能够分配好子元素之间的空间。</p>\n<p>Flex 布局的主要思想是使父容器能够调节子元素的宽度/高度（和排列顺序），从而能够最好地填充可用空间 <strong>（主要是为了适应所有类型的显示设备和屏幕尺寸）</strong> flex布容器能够放大子元素使之尽可能填充可用空间，也可以收缩子元素使之不溢出。</p>\n<p>最重要的是，<strong>flexbox布局与方向无关</strong>，不同于常规布局（基于垂直的块（block）和基于水平的内联（inline））。 虽然传统布局适用于页面，但它们对于大型或复杂的应用程序布局来说缺乏灵活性（特别是在改变方向，调整大小，拉伸，收缩等方面）。</p>\n<p>注:</p>\n<ul>\n<li><strong>Flexbox布局最适合应用程序的组件和小规模布局，而 Gird 布局则适用于较大规模的布局。</strong></li>\n<li><strong>设为Flex布局以后，子元素的float、clear和vertical-align属性将失效。</strong></li>\n</ul>","more":"<h2>基本概念</h2>\n<blockquote>\n<p>采用 Flex 布局的元素，称为 Flex 容器（flex container），简称&quot;容器&quot;。它的所有子元素自动成为容器成员，称为 Flex 项目（flex item），简称&quot;项目&quot;。<br>\n<img src=\"http://img.kyootah.com/2021/04/10/0426548eccf4c.png\" alt=\"基本概念\"></p>\n</blockquote>\n<h2>flex容器属性</h2>\n<p><img src=\"http://img.kyootah.com/2021/04/10/2af8fcd984ece.png\" alt=\"属性\"></p>\n<h3>display:flex;</h3>\n<p><img src=\"http://img.kyootah.com/2021/04/14/95163b9178a2a.png\" alt></p>\n<h3>flex-direction</h3>\n<p>设置轴的方向。</p>\n<ul>\n<li>row（默认）：主轴水平方向，起点左端</li>\n<li>row-reverse：主轴水平方向，起点右端</li>\n<li>column：主轴垂直方向，起点上方</li>\n<li>column-reverse：主轴垂直方向，起点下方</li>\n</ul>\n<p><img src=\"http://img.kyootah.com/2021/04/14/6f1554a56176c.png\" alt><br>\n<img src=\"http://img.kyootah.com/2021/04/14/74686ba65f227.png\" alt></p>\n<h3>flex-wrap</h3>\n<ul>\n<li>nowrap（默认）：不换行</li>\n<li>wrap：换行，第一行在上方</li>\n<li>wrap-reverse：换行，第一行在下方</li>\n</ul>\n<p><img src=\"http://img.kyootah.com/2021/04/14/07cbf0032f8d3.png\" alt></p>\n<h3>justify-content</h3>\n<ul>\n<li>flex-start（默认值）：左对齐</li>\n<li>flex-end：右对齐</li>\n<li>center：居中</li>\n<li>space-between：两端对齐，中间间隔平分</li>\n<li>space-around：每个项目间隔相等排列</li>\n</ul>\n<p><img src=\"http://img.kyootah.com/2021/04/14/b1ceacb101b05.png\" alt><br>\n<img src=\"http://img.kyootah.com/2021/04/14/7fc8fd8191def.png\" alt></p>\n<h3>align-items（单轴线）</h3>\n<ul>\n<li>stretch（默认）：如果项目没设高度或者高度auto，将占满容器高度</li>\n<li>flex-start：交叉轴的起点对齐</li>\n<li>flex-end：交叉轴的终点对齐</li>\n<li>center：交叉轴的中位点对齐</li>\n<li>baseline：项目的第一页文字的基线对齐</li>\n</ul>\n<p><img src=\"http://img.kyootah.com/2021/04/14/76e873c7bfcaf.png\" alt></p>\n<p>对于 <code>align-items: stretch</code> 来说，必须将每一个矩形子元素(flex项)的 <strong>高度设置为 auto</strong>，否则 height 属性将会覆盖该 stretch，如下图<br>\n<img src=\"http://img.kyootah.com/2021/04/15/45cc6510a98cf.png\" alt></p>\n<p>对于 <code>align-items: baseline</code> 来说，对齐方式基于 <strong>第一行文本内容高度</strong>,要注意如果去掉段落标签或者没内容，矩形子元素(flex项)就会按照每个矩形的底部对齐,如下图：<br>\n<img src=\"http://img.kyootah.com/2021/04/15/b6d6c708b75d3.png\" alt></p>\n<h3>align-content（多轴线）</h3>\n<p>align-content属性定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用。</p>\n<ul>\n<li>stretch（默认）</li>\n<li>flex-start</li>\n<li>flex-end</li>\n<li>center</li>\n<li>space-between：各轴线容器两端对齐，中间间隔均等分</li>\n<li>space-around：轴线再容器间隙均等分（两边会有间隙）</li>\n</ul>\n<p><img src=\"http://img.kyootah.com/2021/04/15/4acd07e1cf3eb.png\" alt></p>\n<h2>项目属性</h2>\n<p>项目属性用来设置容器内项目（某个元素）的相关样式，用于设置项目的尺寸、位置、对齐方式<br>\n基本语法：</p>\n<ul>\n<li>order</li>\n<li>flex-basis</li>\n<li>flex-grow</li>\n<li>flex-shrink</li>\n<li>flex</li>\n<li>align-self</li>\n</ul>\n<h3>order</h3>\n<p><code>order</code> 属性定义项目的排列顺序。数值越小，排列越靠前，默认为0</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"flexBox box\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">style</span>=<span class=\"string\">\"order:1\"</span>&gt;</span>1<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">style</span>=<span class=\"string\">\"order:0\"</span>&gt;</span>0<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">style</span>=<span class=\"string\">\"order:2\"</span>&gt;</span>2<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">style</span>=<span class=\"string\">\"order:4\"</span>&gt;</span>4<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">style</span>=<span class=\"string\">\"order:3\"</span>&gt;</span>3<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">style</span>=<span class=\"string\">\"order:-1\"</span>&gt;</span>-1<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p><img src=\"http://img.kyootah.com/2021/04/22/7b053849d3a5d.png\" alt></p>\n<h3>Flex-Basis</h3>\n<p><code>flex-basis</code> 控制一个子元素(flex项)的默认大小，但是它可以被其他的 Flexbox 属性影响（默认值auto）。</p>\n<p>下图可以看出它与<code>width</code>的作用相同，都能设置宽度，当两者同时存在时Flex-Basis会覆盖width<br>\n<img src=\"http://img.kyootah.com/2021/04/23/3b7197ac49190.png\" alt><br>\n<img src=\"http://img.kyootah.com/2021/04/23/c1498ad79fc38.png\" alt></p>\n<p>但是他们之间还是有不同的？flex-basis 对应于 flex 轴线而言的：<br>\n<img src=\"http://img.kyootah.com/2021/04/23/5c881cfec67e9.png\" alt><br>\nflex-basis 影响元素在主轴(main axis)上的大小。<br>\n<code>flex-direction</code>改变为<code>colunm</code>则从width切换到影响height</p>\n<h3>flex-grow（拉伸）</h3>\n<p>属性定义项目的放大比例，默认为0，不放大。<br>\n注：<strong>flex-grow是一个相对值，拉伸放大的区域大小取决于容器承载元素后剩下的区域大小，并根据所设置flex-grow的占比进行比例拉伸</strong>。<br>\n示例：<br>\n我们先将所有矩形元素（flex项）设置为相同的width,100px,与设置间距(margin)10px，容器宽度大小为1100px:<br>\n<img src=\"http://img.kyootah.com/2021/04/26/5ce176a9f6c4a.png\" alt><br>\n现在我们把所有正方形的<code>flex-grow</code>设置为1，默认为0（有剩余地方也不做拉伸填充）,<br>\n可以看到方块均匀地拉伸并把剩下的空间填充完整（间隙是因为设置了10px的margin）<br>\n<img src=\"http://img.kyootah.com/2021/05/06/b35341e49128e.png\" alt></p>\n<p>现在我们把第一个正方形的<code>flex-grow</code>设置为2,<br>\n这个时候第一个方块的宽度为266.68px，拉伸了<code>166.68px</code>,其他方块的的宽度为183.34px,拉伸了<code>83.34px</code>,可以看到拉伸的大小为其他方块的2倍，这里可以得出方块总flex-grow数量为2+1+1+1=7,第一块占2/7,其余方块占1/7<br>\n<img src=\"http://img.kyootah.com/2021/05/06/a223eb133e6b0.png\" alt></p>\n<p>总结：每个子元素的<code>flex-grow</code>都是按比例拉伸的（默认为0，不拉伸），<br>\n同<code>flex-basis</code>一样<code>flex-grow</code>也是只作用与主轴的默认水平方向影响的只有<code>width</code>，除非改变<code>flex-direction</code>的值。</p>\n<h3>Flex Shrink（收缩）</h3>\n<p>与<code>flex-grow</code>同理但相反，<code>flex-shrink</code>设置的是当容器主轴长度不足以承载所有项目且<code>flex-wrap</code>没有设置换行的情况下，项目对应的收缩比例。<br>\n同<code>flex-grow</code>一样，是相对值，<code>flex-shrink</code>默认值是1，所以他们允许被收缩。<br>\n例：我们先把容器宽度设置500px，每个方块宽高设置100px<br>\n<img src=\"http://img.kyootah.com/2021/05/06/caa72ce543167.png\" alt><br>\n我们把容器宽度从500px缩小到300px，可以看到各个项目均等比例缩小了。<br>\n<img src=\"http://img.kyootah.com/2021/05/06/a4d53f5e50f56.png\" alt><br>\n这个时候我们把第二个方块的<code>flex-shrink</code>设置为<strong>0</strong>,不收缩，可以看到方块2就不会进行收缩固定了原来的宽度<br>\n<img src=\"http://img.kyootah.com/2021/05/06/43fdc7dd47c8d.png\" alt><br>\n这个时候有的小伙伴就要问，如果全部都设置为0呢？可以从下图看到，全部设置不收缩的情况下容器就会被撑开了。<br>\n<img src=\"http://img.kyootah.com/2021/05/06/965f7894183a7.png\" alt><br>\n现在我们来研究一下收缩的大小问题。<br>\n<code>flex-shrink</code>收缩跟<code>flex-grow</code>一样是根据项目<code>flex-shrink</code>设置的总比例来收缩的。</p>\n<p>我们试下把第一个方块<code>flex-shrink</code>设置为2，第二块设置为3。<br>\n<img src=\"http://img.kyootah.com/2021/05/06/7d80718c1f77b.png\" alt><br>\n最终得到第一块宽度50px,第二块宽度25px,其余75px,对应第二块跟第二块的收缩大小是其他方块的一倍跟两倍，这个是怎么来的呢？让我们列个表格计算一下。<br>\n<img src=\"http://img.kyootah.com/2021/05/06/7638b10032503.png\" alt><br>\n根据表格可以看出：当容器宽度为300px时，容器内项目总宽度500px，超出的200px分别按比例在各个方块内扣除了，方块一收缩了200px的2/8,方块二3/8,其余1/8。<br>\n这个时候我们设置一下把第一个方块设置<code>flex-shrink</code>为100<br>\n可以看出方块1不见了，width变成了0<br>\n<img src=\"http://img.kyootah.com/2021/05/06/1a11daac4434e.png\" alt><br>\n这里可以看出当收缩比例占比超出项目宽度的时候，项目的主轴长度会变成0，然后其余项目按比例收缩剩余的大小。这里200px分给了项目1还剩150px,然后项目2对应收缩了150px的3/6，其他项目收缩1/6就可以得出上图结果了。</p>\n<p>总结：<code>flex-shrink</code>设置的是当项目总宽度大于容器宽度且没设置换行时项目的收缩比例，一样也是只作用与主轴的默认水平方向影响的只有<code>width</code>，除非改变<code>flex-direction</code>的值。</p>\n<h3>flex</h3>\n<p><code>flex</code> 是 <code>flex-grow</code>，<code>flex-shrink</code> 和 <code>flex-basis</code> 的缩写。<br>\n默认值是<strong>flex:0 1 auto</strong> 即：flex-grow:0;flex-shrink:1;flex-basis:auto;</p>"},{"title":"理解浏览器缓存与存取流程","catalog":true,"date":"2021-10-02T12:16:10.000Z","subtitle":null,"header-img":null,"_content":"\n> 在解析URL之后浏览器根据缓存（强缓存、协商缓存）规则来决定是否取用缓存还是加载服务器资源来进行加载。\n\n## 强缓存\n强制缓存就是向浏览器缓存查找该请求结果，并根据该结果的缓存规则来决定是否使用该缓存结果的过程。\n强缓存又分为两种：`Expires`和`Cache-Control`\n![](http://img.kyootah.com/2022/02/12/ab29c20beebcc.png)\n### 强缓存验证\n* 验证位置：**本地**（内存或者硬盘，根据浏览器策略决定）\n* 验证字段：`expires` (http1.0中出现)和`cache-control` (http1.1中出现)两个，**如果这两个字段同时出现，cache-control会覆盖expires**\n* 验证流程： 查看两个字段的指定时间，如果过期则跳到下一阶段（协商缓存）\n* 如果命中： 状态码：200 (from disk cache)或是200 OK (from memory cache) **注：根据该缓存的内存占用进行存储，内存占用过高则存入磁盘**\n\n\n### cache-control参数\n>常用参数：\n`private`：客户端可以缓存\n`public`：客户端和代理服务器均可缓存；\n`max-age=xxx`：缓存的资源将在 xxx 秒后过期，常见：2592000（三十天）、31536000（一年）；\n`no-cache`：跳过当前强验证步骤，使用下一阶段协商缓存来验证是否过期；\n`must-revalidate`：如果强缓存时间过期，必须去服务器进行有效性检验这个旧的缓存\n`no-transform`：多用于图片，不允许对资源进行转换压缩\n\n其他参数：\n- 请求头：\n    - **no-cache**：告知 (代理) 服务器不直接使用缓存，要求向原服务器发起请求\n    - **no-store**：所有内容都不会被保存到缓存或 Internet 临时文件中\n    - **max-age=delta-seconds**：告知服务器客户端希望接收一个存在时间不大于 delta-secconds 秒的资源\n    - **max-stale=delta-seconds**：告知 (代理) 服务器客户端愿意接收一个超过缓存时间的资源，若有定义 delta-seconds 则为 delta-seconds 秒，若没有则为任意超出时间\n    - **min-fresh=delta-seconds**：告知 (代理) 服务器客户端希望接收一个在小于 delta-seconds 秒内被更新过的资源\n    - **no-transform**：告知 (代理) 服务器客户端希望获取实体数据没有被转换 (比如压缩) 过的资源\n    - **noly-if-cached**：告知 (代理) 服务器客户端希望获取缓存的内容(若有), 而不用向原服务器发去请求\n    - **cache-extension**：自定义扩展值，若服务器不识别该值将被忽略掉\n- 响应头：\n    - **public**：表明任何情况下都得缓存该资源 (即使是需要 HTTP 认证的资源)\n    - **Private=field-name**：表明返回报文中全部或部分 (若指定了 field-name 则为 field-name 的字段数据) 仅开放给某些用户 (服务器指定的 share-user，如代理服务器) 做缓存使用，其他用户则不能缓存这些数据\n    - **no-cache**：不直接使用缓存，要求向服务器发起 (新鲜度校验) 请求\n    - **no-store**：所有内容都不会被保存到缓存或 Internet 临时文件中\n    - **no-transform**：告知客户端缓存文件时不得对实体数据做任何改变\n    - **noly-if-cached**：告知 (代理) 服务器客户端希望获取缓存的内容(若有), 而不用向原服务器发去请求\n    - **must-revalidate**：当前资源一定是向原方法服务器发去验证请求的，如请求是吧会返回 504(而非代理服务器上的缓存)\n    - **proxy-revalidate**：与 must-revalidate 类似，但仅能应用于共享缓存 (如代理)\n    - **max-age=delta-seconds**：告知客户端该资源在 delta-seconds 秒内是新鲜的，无需向服务器发请求\n    - **s-maxage=delta-seconds**：同 max-age，但仅能应用于共享缓存 (如代理)\n    - **cache-extension**：自定义扩展值，若服务器不识别该值将被忽略掉\n\n## 协商缓存\n协商缓存就是强制缓存失效后，浏览器携带缓存标识向服务器发起请求，由服务器根据缓存标识决定是否使用缓存的过程。\n   \n\n### 协商缓存验证\n* 验证位置：**服务器**\n* 验证字段：有两组，`Last-Modified(响应头) + If-Modified-Since(请求头)`和`ETag(响应头) + If-None-Match(请求头)`,**如果两种方式都支持的话，服务器会优先考虑 ETag**\n* 验证流程如下\n![](http://img.kyootah.com/2022/02/12/cedcec762c907.png)\n\n     \n* **Last-Modified(响应头) + If-Modified-Since(请求头)**\n在浏览器第一次给服务器发送请求后，服务器会在响应头中加上这个字段。\n浏览器接收到后，如果再次请求，会在请求头中携带`If-Modified-Since`字段，这个字段的值也就是服务器传来的最后修改时间。\n服务器拿到请求头中的`If-Modified-Since`的字段后，其实会和这个服务器中该资源的最后修改时间`Last-Modified`对比, 询问服务器在该日期后资源是否有更新，有更新的话就会将新的资源发送回来。但是如果在本地打开缓存文件，就会造成 `Last-Modified` 被修改，所以在 HTTP / 1.1 出现了 `ETag`。\n\n* **ETag(响应头)、If-None-Match(请求头)**\n`ETag`是服务器根据当前文件的内容，给文件生成的**唯一标识**，只要里面的内容有改动，这个值就会变。服务器通过响应头把这个值给浏览器。\n浏览器接收到 `ETag` 的值，会在下次请求时，将这个值作为`If-None-Match`这个字段的内容，并放到请求头中，然后发给服务器。","source":"_posts/浏览器缓存.md","raw":"---\ntitle: 理解浏览器缓存与存取流程\ncatalog: true \ndate: 2021-10-02 20:16:10\nsubtitle:\nheader-img:\ntags:\n- 网络基础\n- 浏览器缓存\n---\n\n> 在解析URL之后浏览器根据缓存（强缓存、协商缓存）规则来决定是否取用缓存还是加载服务器资源来进行加载。\n\n## 强缓存\n强制缓存就是向浏览器缓存查找该请求结果，并根据该结果的缓存规则来决定是否使用该缓存结果的过程。\n强缓存又分为两种：`Expires`和`Cache-Control`\n![](http://img.kyootah.com/2022/02/12/ab29c20beebcc.png)\n### 强缓存验证\n* 验证位置：**本地**（内存或者硬盘，根据浏览器策略决定）\n* 验证字段：`expires` (http1.0中出现)和`cache-control` (http1.1中出现)两个，**如果这两个字段同时出现，cache-control会覆盖expires**\n* 验证流程： 查看两个字段的指定时间，如果过期则跳到下一阶段（协商缓存）\n* 如果命中： 状态码：200 (from disk cache)或是200 OK (from memory cache) **注：根据该缓存的内存占用进行存储，内存占用过高则存入磁盘**\n\n\n### cache-control参数\n>常用参数：\n`private`：客户端可以缓存\n`public`：客户端和代理服务器均可缓存；\n`max-age=xxx`：缓存的资源将在 xxx 秒后过期，常见：2592000（三十天）、31536000（一年）；\n`no-cache`：跳过当前强验证步骤，使用下一阶段协商缓存来验证是否过期；\n`must-revalidate`：如果强缓存时间过期，必须去服务器进行有效性检验这个旧的缓存\n`no-transform`：多用于图片，不允许对资源进行转换压缩\n\n其他参数：\n- 请求头：\n    - **no-cache**：告知 (代理) 服务器不直接使用缓存，要求向原服务器发起请求\n    - **no-store**：所有内容都不会被保存到缓存或 Internet 临时文件中\n    - **max-age=delta-seconds**：告知服务器客户端希望接收一个存在时间不大于 delta-secconds 秒的资源\n    - **max-stale=delta-seconds**：告知 (代理) 服务器客户端愿意接收一个超过缓存时间的资源，若有定义 delta-seconds 则为 delta-seconds 秒，若没有则为任意超出时间\n    - **min-fresh=delta-seconds**：告知 (代理) 服务器客户端希望接收一个在小于 delta-seconds 秒内被更新过的资源\n    - **no-transform**：告知 (代理) 服务器客户端希望获取实体数据没有被转换 (比如压缩) 过的资源\n    - **noly-if-cached**：告知 (代理) 服务器客户端希望获取缓存的内容(若有), 而不用向原服务器发去请求\n    - **cache-extension**：自定义扩展值，若服务器不识别该值将被忽略掉\n- 响应头：\n    - **public**：表明任何情况下都得缓存该资源 (即使是需要 HTTP 认证的资源)\n    - **Private=field-name**：表明返回报文中全部或部分 (若指定了 field-name 则为 field-name 的字段数据) 仅开放给某些用户 (服务器指定的 share-user，如代理服务器) 做缓存使用，其他用户则不能缓存这些数据\n    - **no-cache**：不直接使用缓存，要求向服务器发起 (新鲜度校验) 请求\n    - **no-store**：所有内容都不会被保存到缓存或 Internet 临时文件中\n    - **no-transform**：告知客户端缓存文件时不得对实体数据做任何改变\n    - **noly-if-cached**：告知 (代理) 服务器客户端希望获取缓存的内容(若有), 而不用向原服务器发去请求\n    - **must-revalidate**：当前资源一定是向原方法服务器发去验证请求的，如请求是吧会返回 504(而非代理服务器上的缓存)\n    - **proxy-revalidate**：与 must-revalidate 类似，但仅能应用于共享缓存 (如代理)\n    - **max-age=delta-seconds**：告知客户端该资源在 delta-seconds 秒内是新鲜的，无需向服务器发请求\n    - **s-maxage=delta-seconds**：同 max-age，但仅能应用于共享缓存 (如代理)\n    - **cache-extension**：自定义扩展值，若服务器不识别该值将被忽略掉\n\n## 协商缓存\n协商缓存就是强制缓存失效后，浏览器携带缓存标识向服务器发起请求，由服务器根据缓存标识决定是否使用缓存的过程。\n   \n\n### 协商缓存验证\n* 验证位置：**服务器**\n* 验证字段：有两组，`Last-Modified(响应头) + If-Modified-Since(请求头)`和`ETag(响应头) + If-None-Match(请求头)`,**如果两种方式都支持的话，服务器会优先考虑 ETag**\n* 验证流程如下\n![](http://img.kyootah.com/2022/02/12/cedcec762c907.png)\n\n     \n* **Last-Modified(响应头) + If-Modified-Since(请求头)**\n在浏览器第一次给服务器发送请求后，服务器会在响应头中加上这个字段。\n浏览器接收到后，如果再次请求，会在请求头中携带`If-Modified-Since`字段，这个字段的值也就是服务器传来的最后修改时间。\n服务器拿到请求头中的`If-Modified-Since`的字段后，其实会和这个服务器中该资源的最后修改时间`Last-Modified`对比, 询问服务器在该日期后资源是否有更新，有更新的话就会将新的资源发送回来。但是如果在本地打开缓存文件，就会造成 `Last-Modified` 被修改，所以在 HTTP / 1.1 出现了 `ETag`。\n\n* **ETag(响应头)、If-None-Match(请求头)**\n`ETag`是服务器根据当前文件的内容，给文件生成的**唯一标识**，只要里面的内容有改动，这个值就会变。服务器通过响应头把这个值给浏览器。\n浏览器接收到 `ETag` 的值，会在下次请求时，将这个值作为`If-None-Match`这个字段的内容，并放到请求头中，然后发给服务器。","slug":"浏览器缓存","published":1,"updated":"2022-02-12T09:13:31.937Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl27vhg5w000vu8q5l2gdrdlv","content":"<blockquote>\n<p>在解析URL之后浏览器根据缓存（强缓存、协商缓存）规则来决定是否取用缓存还是加载服务器资源来进行加载。</p>\n</blockquote>\n<h2 id=\"强缓存\">强缓存</h2>\n<p>强制缓存就是向浏览器缓存查找该请求结果，并根据该结果的缓存规则来决定是否使用该缓存结果的过程。<br>\n强缓存又分为两种：<code>Expires</code>和<code>Cache-Control</code><br>\n<img src=\"http://img.kyootah.com/2022/02/12/ab29c20beebcc.png\" alt></p>\n<h3 id=\"强缓存验证\">强缓存验证</h3>\n<ul>\n<li>验证位置：<strong>本地</strong>（内存或者硬盘，根据浏览器策略决定）</li>\n<li>验证字段：<code>expires</code> (http1.0中出现)和<code>cache-control</code> (http1.1中出现)两个，<strong>如果这两个字段同时出现，cache-control会覆盖expires</strong></li>\n<li>验证流程： 查看两个字段的指定时间，如果过期则跳到下一阶段（协商缓存）</li>\n<li>如果命中： 状态码：200 (from disk cache)或是200 OK (from memory cache) <strong>注：根据该缓存的内存占用进行存储，内存占用过高则存入磁盘</strong></li>\n</ul>\n<h3 id=\"cache-control参数\">cache-control参数</h3>\n<blockquote>\n<p>常用参数：<br>\n<code>private</code>：客户端可以缓存<br>\n<code>public</code>：客户端和代理服务器均可缓存；<br>\n<code>max-age=xxx</code>：缓存的资源将在 xxx 秒后过期，常见：2592000（三十天）、31536000（一年）；<br>\n<code>no-cache</code>：跳过当前强验证步骤，使用下一阶段协商缓存来验证是否过期；<br>\n<code>must-revalidate</code>：如果强缓存时间过期，必须去服务器进行有效性检验这个旧的缓存<br>\n<code>no-transform</code>：多用于图片，不允许对资源进行转换压缩</p>\n</blockquote>\n<p>其他参数：</p>\n<ul>\n<li>请求头：\n<ul>\n<li><strong>no-cache</strong>：告知 (代理) 服务器不直接使用缓存，要求向原服务器发起请求</li>\n<li><strong>no-store</strong>：所有内容都不会被保存到缓存或 Internet 临时文件中</li>\n<li><strong>max-age=delta-seconds</strong>：告知服务器客户端希望接收一个存在时间不大于 delta-secconds 秒的资源</li>\n<li><strong>max-stale=delta-seconds</strong>：告知 (代理) 服务器客户端愿意接收一个超过缓存时间的资源，若有定义 delta-seconds 则为 delta-seconds 秒，若没有则为任意超出时间</li>\n<li><strong>min-fresh=delta-seconds</strong>：告知 (代理) 服务器客户端希望接收一个在小于 delta-seconds 秒内被更新过的资源</li>\n<li><strong>no-transform</strong>：告知 (代理) 服务器客户端希望获取实体数据没有被转换 (比如压缩) 过的资源</li>\n<li><strong>noly-if-cached</strong>：告知 (代理) 服务器客户端希望获取缓存的内容(若有), 而不用向原服务器发去请求</li>\n<li><strong>cache-extension</strong>：自定义扩展值，若服务器不识别该值将被忽略掉</li>\n</ul>\n</li>\n<li>响应头：\n<ul>\n<li><strong>public</strong>：表明任何情况下都得缓存该资源 (即使是需要 HTTP 认证的资源)</li>\n<li><strong>Private=field-name</strong>：表明返回报文中全部或部分 (若指定了 field-name 则为 field-name 的字段数据) 仅开放给某些用户 (服务器指定的 share-user，如代理服务器) 做缓存使用，其他用户则不能缓存这些数据</li>\n<li><strong>no-cache</strong>：不直接使用缓存，要求向服务器发起 (新鲜度校验) 请求</li>\n<li><strong>no-store</strong>：所有内容都不会被保存到缓存或 Internet 临时文件中</li>\n<li><strong>no-transform</strong>：告知客户端缓存文件时不得对实体数据做任何改变</li>\n<li><strong>noly-if-cached</strong>：告知 (代理) 服务器客户端希望获取缓存的内容(若有), 而不用向原服务器发去请求</li>\n<li><strong>must-revalidate</strong>：当前资源一定是向原方法服务器发去验证请求的，如请求是吧会返回 504(而非代理服务器上的缓存)</li>\n<li><strong>proxy-revalidate</strong>：与 must-revalidate 类似，但仅能应用于共享缓存 (如代理)</li>\n<li><strong>max-age=delta-seconds</strong>：告知客户端该资源在 delta-seconds 秒内是新鲜的，无需向服务器发请求</li>\n<li><strong>s-maxage=delta-seconds</strong>：同 max-age，但仅能应用于共享缓存 (如代理)</li>\n<li><strong>cache-extension</strong>：自定义扩展值，若服务器不识别该值将被忽略掉</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"协商缓存\">协商缓存</h2>\n<p>协商缓存就是强制缓存失效后，浏览器携带缓存标识向服务器发起请求，由服务器根据缓存标识决定是否使用缓存的过程。</p>\n<h3 id=\"协商缓存验证\">协商缓存验证</h3>\n<ul>\n<li>验证位置：<strong>服务器</strong></li>\n<li>验证字段：有两组，<code>Last-Modified(响应头) + If-Modified-Since(请求头)</code>和<code>ETag(响应头) + If-None-Match(请求头)</code>,<strong>如果两种方式都支持的话，服务器会优先考虑 ETag</strong></li>\n<li>验证流程如下<br>\n<img src=\"http://img.kyootah.com/2022/02/12/cedcec762c907.png\" alt></li>\n</ul>\n<ul>\n<li>\n<p><strong>Last-Modified(响应头) + If-Modified-Since(请求头)</strong><br>\n在浏览器第一次给服务器发送请求后，服务器会在响应头中加上这个字段。<br>\n浏览器接收到后，如果再次请求，会在请求头中携带<code>If-Modified-Since</code>字段，这个字段的值也就是服务器传来的最后修改时间。<br>\n服务器拿到请求头中的<code>If-Modified-Since</code>的字段后，其实会和这个服务器中该资源的最后修改时间<code>Last-Modified</code>对比, 询问服务器在该日期后资源是否有更新，有更新的话就会将新的资源发送回来。但是如果在本地打开缓存文件，就会造成 <code>Last-Modified</code> 被修改，所以在 HTTP / 1.1 出现了 <code>ETag</code>。</p>\n</li>\n<li>\n<p><strong>ETag(响应头)、If-None-Match(请求头)</strong><br>\n<code>ETag</code>是服务器根据当前文件的内容，给文件生成的<strong>唯一标识</strong>，只要里面的内容有改动，这个值就会变。服务器通过响应头把这个值给浏览器。<br>\n浏览器接收到 <code>ETag</code> 的值，会在下次请求时，将这个值作为<code>If-None-Match</code>这个字段的内容，并放到请求头中，然后发给服务器。</p>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>在解析URL之后浏览器根据缓存（强缓存、协商缓存）规则来决定是否取用缓存还是加载服务器资源来进行加载。</p>\n</blockquote>\n<h2>强缓存</h2>\n<p>强制缓存就是向浏览器缓存查找该请求结果，并根据该结果的缓存规则来决定是否使用该缓存结果的过程。<br>\n强缓存又分为两种：<code>Expires</code>和<code>Cache-Control</code><br>\n<img src=\"http://img.kyootah.com/2022/02/12/ab29c20beebcc.png\" alt></p>\n<h3>强缓存验证</h3>\n<ul>\n<li>验证位置：<strong>本地</strong>（内存或者硬盘，根据浏览器策略决定）</li>\n<li>验证字段：<code>expires</code> (http1.0中出现)和<code>cache-control</code> (http1.1中出现)两个，<strong>如果这两个字段同时出现，cache-control会覆盖expires</strong></li>\n<li>验证流程： 查看两个字段的指定时间，如果过期则跳到下一阶段（协商缓存）</li>\n<li>如果命中： 状态码：200 (from disk cache)或是200 OK (from memory cache) <strong>注：根据该缓存的内存占用进行存储，内存占用过高则存入磁盘</strong></li>\n</ul>\n<h3>cache-control参数</h3>\n<blockquote>\n<p>常用参数：<br>\n<code>private</code>：客户端可以缓存<br>\n<code>public</code>：客户端和代理服务器均可缓存；<br>\n<code>max-age=xxx</code>：缓存的资源将在 xxx 秒后过期，常见：2592000（三十天）、31536000（一年）；<br>\n<code>no-cache</code>：跳过当前强验证步骤，使用下一阶段协商缓存来验证是否过期；<br>\n<code>must-revalidate</code>：如果强缓存时间过期，必须去服务器进行有效性检验这个旧的缓存<br>\n<code>no-transform</code>：多用于图片，不允许对资源进行转换压缩</p>\n</blockquote>\n<p>其他参数：</p>\n<ul>\n<li>请求头：\n<ul>\n<li><strong>no-cache</strong>：告知 (代理) 服务器不直接使用缓存，要求向原服务器发起请求</li>\n<li><strong>no-store</strong>：所有内容都不会被保存到缓存或 Internet 临时文件中</li>\n<li><strong>max-age=delta-seconds</strong>：告知服务器客户端希望接收一个存在时间不大于 delta-secconds 秒的资源</li>\n<li><strong>max-stale=delta-seconds</strong>：告知 (代理) 服务器客户端愿意接收一个超过缓存时间的资源，若有定义 delta-seconds 则为 delta-seconds 秒，若没有则为任意超出时间</li>\n<li><strong>min-fresh=delta-seconds</strong>：告知 (代理) 服务器客户端希望接收一个在小于 delta-seconds 秒内被更新过的资源</li>\n<li><strong>no-transform</strong>：告知 (代理) 服务器客户端希望获取实体数据没有被转换 (比如压缩) 过的资源</li>\n<li><strong>noly-if-cached</strong>：告知 (代理) 服务器客户端希望获取缓存的内容(若有), 而不用向原服务器发去请求</li>\n<li><strong>cache-extension</strong>：自定义扩展值，若服务器不识别该值将被忽略掉</li>\n</ul>\n</li>\n<li>响应头：\n<ul>\n<li><strong>public</strong>：表明任何情况下都得缓存该资源 (即使是需要 HTTP 认证的资源)</li>\n<li><strong>Private=field-name</strong>：表明返回报文中全部或部分 (若指定了 field-name 则为 field-name 的字段数据) 仅开放给某些用户 (服务器指定的 share-user，如代理服务器) 做缓存使用，其他用户则不能缓存这些数据</li>\n<li><strong>no-cache</strong>：不直接使用缓存，要求向服务器发起 (新鲜度校验) 请求</li>\n<li><strong>no-store</strong>：所有内容都不会被保存到缓存或 Internet 临时文件中</li>\n<li><strong>no-transform</strong>：告知客户端缓存文件时不得对实体数据做任何改变</li>\n<li><strong>noly-if-cached</strong>：告知 (代理) 服务器客户端希望获取缓存的内容(若有), 而不用向原服务器发去请求</li>\n<li><strong>must-revalidate</strong>：当前资源一定是向原方法服务器发去验证请求的，如请求是吧会返回 504(而非代理服务器上的缓存)</li>\n<li><strong>proxy-revalidate</strong>：与 must-revalidate 类似，但仅能应用于共享缓存 (如代理)</li>\n<li><strong>max-age=delta-seconds</strong>：告知客户端该资源在 delta-seconds 秒内是新鲜的，无需向服务器发请求</li>\n<li><strong>s-maxage=delta-seconds</strong>：同 max-age，但仅能应用于共享缓存 (如代理)</li>\n<li><strong>cache-extension</strong>：自定义扩展值，若服务器不识别该值将被忽略掉</li>\n</ul>\n</li>\n</ul>\n<h2>协商缓存</h2>\n<p>协商缓存就是强制缓存失效后，浏览器携带缓存标识向服务器发起请求，由服务器根据缓存标识决定是否使用缓存的过程。</p>\n<h3>协商缓存验证</h3>\n<ul>\n<li>验证位置：<strong>服务器</strong></li>\n<li>验证字段：有两组，<code>Last-Modified(响应头) + If-Modified-Since(请求头)</code>和<code>ETag(响应头) + If-None-Match(请求头)</code>,<strong>如果两种方式都支持的话，服务器会优先考虑 ETag</strong></li>\n<li>验证流程如下<br>\n<img src=\"http://img.kyootah.com/2022/02/12/cedcec762c907.png\" alt></li>\n</ul>\n<ul>\n<li>\n<p><strong>Last-Modified(响应头) + If-Modified-Since(请求头)</strong><br>\n在浏览器第一次给服务器发送请求后，服务器会在响应头中加上这个字段。<br>\n浏览器接收到后，如果再次请求，会在请求头中携带<code>If-Modified-Since</code>字段，这个字段的值也就是服务器传来的最后修改时间。<br>\n服务器拿到请求头中的<code>If-Modified-Since</code>的字段后，其实会和这个服务器中该资源的最后修改时间<code>Last-Modified</code>对比, 询问服务器在该日期后资源是否有更新，有更新的话就会将新的资源发送回来。但是如果在本地打开缓存文件，就会造成 <code>Last-Modified</code> 被修改，所以在 HTTP / 1.1 出现了 <code>ETag</code>。</p>\n</li>\n<li>\n<p><strong>ETag(响应头)、If-None-Match(请求头)</strong><br>\n<code>ETag</code>是服务器根据当前文件的内容，给文件生成的<strong>唯一标识</strong>，只要里面的内容有改动，这个值就会变。服务器通过响应头把这个值给浏览器。<br>\n浏览器接收到 <code>ETag</code> 的值，会在下次请求时，将这个值作为<code>If-None-Match</code>这个字段的内容，并放到请求头中，然后发给服务器。</p>\n</li>\n</ul>\n"},{"title":"计算机基础知识-什么是http？","catalog":true,"date":"2021-05-08T14:31:55.000Z","subtitle":null,"header-img":null,"_content":"\n> 阅读《图解http》总结，这本书通俗易懂，推荐阅读^_^\n> http 是 TCP/IP 内部的一个子集。\n\n## 名词解释 \n\n| 名词         | 解释                                                         | 功能                                                         |\n| :----------- | ------------------------------------------------------------ | ------------------------------------------------------------ |\n| HTTP         | Hyper Text Transfer Protocol（超文本传输协议）**（应用层）** | 从服务器传输**文本**到本地浏览器的传输协议                   |\n| HTML         | 超文本标记语言                                               |                                                              |\n| URL          | 统一资源定位系统（uniform resource locator）                 | 表示资源的地点。是URI的子集。                                |\n| URI          | 统一资源标志符（universal resource identifier）              | 用字符串表示某一互联网资源                                   |\n| TCP/IP协议族 | 与互联网相关的协议集合                                       | 数据链路层、网络层、传输层和应用层四个协议集合               |\n| DNS          | 域名系统（Domain Name System）                               | 域名到IP地址之间的解析服务。DNS协议提供通过域名/IP名双向查找。 |\n| TCP          | 传输控制协议（Transmission Control Protocol）（**传输层**）  | 进行数据分组，即对HTTP请求报文进行分割（为了方便运输，将大块数据分割成以报文段为单位的数据包进行管理）；并打上标记序号和端口号后转发给网络层。**三次握手** |\n| IP           | 网际协议**（网络层）**                                       | `把各种数据包传给对方。要确保传送有两个重要条件：IP地址、MAC地址。 |\n| IP地址       | 指明了节点被分配到的地址；                                   |                                                              |\n| MAC地址      | 指网卡所属的固定地址                                         | （**通信双方经过多台计算机和网络设备中转进行连接，中转的时候，会利用下一站中转设备的MAC地址来搜索下一个中转目标**） |\n| ARP协议      | 解析地址的协议                                               | **根据通信方的IP地址，反查出对应的MAC地址**                  |\n| SSL          | 安全套接字协议（Secure Sockets Layer）                       | SSL协议位于TCP/IP协议与各种应用层协议之间，为数据通讯提供安全支持。（对传输数据进行加密） |\n| TLS          | 传输层安全（Transport Layer Security）                       | 它的前身是SSL，实现了将应用层的报文进行加密后再交由TCP进行传输 |\n| MIME         | 多用途因特网邮件扩展（Multipurpose Internet Mail Extensions） | 用MIME类型可以设定某种扩展名的文件用一种应用程序来打开的方式类型，当该扩展名文件被访问的时候，浏览器会自动使用指定应用程序来打开 |\n\n## 了解Web及网络基础\n### 网络基础TCP/IP 的分层管理\n\n注 http是TCP/IP内部的一个子集。\n\n- **应用层：**决定了向用户提供应用服务时的通信的活动。**DNS（域名系统）、FTP（文件传输协议）、HTTP协议处于应用层**\n\n- **传输层：**传输层对上层应用层，提供处于网络连接中的两台计算机之间的数据传输。传输层有两个性质不同的协议：TCP（传输     控制器协议）和UDP（用户数据报协议）**TCP（传输控制协议）、UDP（用户数据报协议）属于传输层。**\n\n- **网络层(又名网络互联层)：**用来处理在网络上流动的数据包。  与对方计算机之间通过多台计算机或网络设备进行传输时，网络层所起的作用就是在众多的选项内选择一条传输路线。**IP（网际协议）属于网络层。**\n\n- **链路层（数据链路层，网络接口层）：**用来处理网络连接的硬件部分。**包括控制操作系统、硬件设备的驱动、NIC（网络适配器，即网卡）**\n\n数据包是网络传输的最小数据单位。\n\nTCP/IP通信传输流：客户端到服务器通过分层顺序传输 路由选择：在到达通信目标前的中转过程，计算机和路由器等网络设备，都只能获悉很粗略的传输路线，无法掌握互联网中全面传输情况\n\n发送端：从应用层**往下走**；每通过一层会**增加该层**的首部信息（这种把数据信息包装起来的做法称为封装）；\n\n接收端：则从链路层**往上走**到应用层；每通过一层会**删除该层**的首部信息；\n\n![](http://img.kyootah.com/2021/05/09/cd4c7817e4c51.png)\n\n![](http://img.kyootah.com/2021/05/09/c370e3ba7bf2a.png)\n\n客户端发送到服务器的过程：\n\n![](http://img.kyootah.com/2021/05/09/39dd3f5883eec.png)\n\n### TCP的三次握手\nTCP的三次握手（是为了准确无误得将数据送达目标处，把包送出去后，向对方确认是否送达成功）\n1. 发送端受限发送一个带SYN标志的数据包给对方。\n2. 接收端收到后，回传一个带有SYN/ACK标志的数据包传达确认信息。\n3. 最后，发送端再回传一个带ACK标志的数据包，代表握手结束。","source":"_posts/计算机基础知识-什么是http？.md","raw":"---\ntitle: 计算机基础知识-什么是http？\ncatalog: true\ndate: 2021-05-08 22:31:55\nsubtitle:\nheader-img:\ntags:\n- http\n---\n\n> 阅读《图解http》总结，这本书通俗易懂，推荐阅读^_^\n> http 是 TCP/IP 内部的一个子集。\n\n## 名词解释 \n\n| 名词         | 解释                                                         | 功能                                                         |\n| :----------- | ------------------------------------------------------------ | ------------------------------------------------------------ |\n| HTTP         | Hyper Text Transfer Protocol（超文本传输协议）**（应用层）** | 从服务器传输**文本**到本地浏览器的传输协议                   |\n| HTML         | 超文本标记语言                                               |                                                              |\n| URL          | 统一资源定位系统（uniform resource locator）                 | 表示资源的地点。是URI的子集。                                |\n| URI          | 统一资源标志符（universal resource identifier）              | 用字符串表示某一互联网资源                                   |\n| TCP/IP协议族 | 与互联网相关的协议集合                                       | 数据链路层、网络层、传输层和应用层四个协议集合               |\n| DNS          | 域名系统（Domain Name System）                               | 域名到IP地址之间的解析服务。DNS协议提供通过域名/IP名双向查找。 |\n| TCP          | 传输控制协议（Transmission Control Protocol）（**传输层**）  | 进行数据分组，即对HTTP请求报文进行分割（为了方便运输，将大块数据分割成以报文段为单位的数据包进行管理）；并打上标记序号和端口号后转发给网络层。**三次握手** |\n| IP           | 网际协议**（网络层）**                                       | `把各种数据包传给对方。要确保传送有两个重要条件：IP地址、MAC地址。 |\n| IP地址       | 指明了节点被分配到的地址；                                   |                                                              |\n| MAC地址      | 指网卡所属的固定地址                                         | （**通信双方经过多台计算机和网络设备中转进行连接，中转的时候，会利用下一站中转设备的MAC地址来搜索下一个中转目标**） |\n| ARP协议      | 解析地址的协议                                               | **根据通信方的IP地址，反查出对应的MAC地址**                  |\n| SSL          | 安全套接字协议（Secure Sockets Layer）                       | SSL协议位于TCP/IP协议与各种应用层协议之间，为数据通讯提供安全支持。（对传输数据进行加密） |\n| TLS          | 传输层安全（Transport Layer Security）                       | 它的前身是SSL，实现了将应用层的报文进行加密后再交由TCP进行传输 |\n| MIME         | 多用途因特网邮件扩展（Multipurpose Internet Mail Extensions） | 用MIME类型可以设定某种扩展名的文件用一种应用程序来打开的方式类型，当该扩展名文件被访问的时候，浏览器会自动使用指定应用程序来打开 |\n\n## 了解Web及网络基础\n### 网络基础TCP/IP 的分层管理\n\n注 http是TCP/IP内部的一个子集。\n\n- **应用层：**决定了向用户提供应用服务时的通信的活动。**DNS（域名系统）、FTP（文件传输协议）、HTTP协议处于应用层**\n\n- **传输层：**传输层对上层应用层，提供处于网络连接中的两台计算机之间的数据传输。传输层有两个性质不同的协议：TCP（传输     控制器协议）和UDP（用户数据报协议）**TCP（传输控制协议）、UDP（用户数据报协议）属于传输层。**\n\n- **网络层(又名网络互联层)：**用来处理在网络上流动的数据包。  与对方计算机之间通过多台计算机或网络设备进行传输时，网络层所起的作用就是在众多的选项内选择一条传输路线。**IP（网际协议）属于网络层。**\n\n- **链路层（数据链路层，网络接口层）：**用来处理网络连接的硬件部分。**包括控制操作系统、硬件设备的驱动、NIC（网络适配器，即网卡）**\n\n数据包是网络传输的最小数据单位。\n\nTCP/IP通信传输流：客户端到服务器通过分层顺序传输 路由选择：在到达通信目标前的中转过程，计算机和路由器等网络设备，都只能获悉很粗略的传输路线，无法掌握互联网中全面传输情况\n\n发送端：从应用层**往下走**；每通过一层会**增加该层**的首部信息（这种把数据信息包装起来的做法称为封装）；\n\n接收端：则从链路层**往上走**到应用层；每通过一层会**删除该层**的首部信息；\n\n![](http://img.kyootah.com/2021/05/09/cd4c7817e4c51.png)\n\n![](http://img.kyootah.com/2021/05/09/c370e3ba7bf2a.png)\n\n客户端发送到服务器的过程：\n\n![](http://img.kyootah.com/2021/05/09/39dd3f5883eec.png)\n\n### TCP的三次握手\nTCP的三次握手（是为了准确无误得将数据送达目标处，把包送出去后，向对方确认是否送达成功）\n1. 发送端受限发送一个带SYN标志的数据包给对方。\n2. 接收端收到后，回传一个带有SYN/ACK标志的数据包传达确认信息。\n3. 最后，发送端再回传一个带ACK标志的数据包，代表握手结束。","slug":"计算机基础知识-什么是http？","published":1,"updated":"2022-02-14T08:41:57.244Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl27vhg5x000yu8q55fulnsnq","content":"<blockquote>\n<p>阅读《图解http》总结，这本书通俗易懂，推荐阅读^_^<br>\nhttp 是 TCP/IP 内部的一个子集。</p>\n</blockquote>\n<h2 id=\"名词解释\">名词解释</h2>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">名词</th>\n<th>解释</th>\n<th>功能</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">HTTP</td>\n<td>Hyper Text Transfer Protocol（超文本传输协议）<strong>（应用层）</strong></td>\n<td>从服务器传输<strong>文本</strong>到本地浏览器的传输协议</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">HTML</td>\n<td>超文本标记语言</td>\n<td></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">URL</td>\n<td>统一资源定位系统（uniform resource locator）</td>\n<td>表示资源的地点。是URI的子集。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">URI</td>\n<td>统一资源标志符（universal resource identifier）</td>\n<td>用字符串表示某一互联网资源</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">TCP/IP协议族</td>\n<td>与互联网相关的协议集合</td>\n<td>数据链路层、网络层、传输层和应用层四个协议集合</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">DNS</td>\n<td>域名系统（Domain Name System）</td>\n<td>域名到IP地址之间的解析服务。DNS协议提供通过域名/IP名双向查找。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">TCP</td>\n<td>传输控制协议（Transmission Control Protocol）（<strong>传输层</strong>）</td>\n<td>进行数据分组，即对HTTP请求报文进行分割（为了方便运输，将大块数据分割成以报文段为单位的数据包进行管理）；并打上标记序号和端口号后转发给网络层。<strong>三次握手</strong></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">IP</td>\n<td>网际协议**（网络层）**</td>\n<td>`把各种数据包传给对方。要确保传送有两个重要条件：IP地址、MAC地址。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">IP地址</td>\n<td>指明了节点被分配到的地址；</td>\n<td></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">MAC地址</td>\n<td>指网卡所属的固定地址</td>\n<td>（<strong>通信双方经过多台计算机和网络设备中转进行连接，中转的时候，会利用下一站中转设备的MAC地址来搜索下一个中转目标</strong>）</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">ARP协议</td>\n<td>解析地址的协议</td>\n<td><strong>根据通信方的IP地址，反查出对应的MAC地址</strong></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">SSL</td>\n<td>安全套接字协议（Secure Sockets Layer）</td>\n<td>SSL协议位于TCP/IP协议与各种应用层协议之间，为数据通讯提供安全支持。（对传输数据进行加密）</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">TLS</td>\n<td>传输层安全（Transport Layer Security）</td>\n<td>它的前身是SSL，实现了将应用层的报文进行加密后再交由TCP进行传输</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">MIME</td>\n<td>多用途因特网邮件扩展（Multipurpose Internet Mail Extensions）</td>\n<td>用MIME类型可以设定某种扩展名的文件用一种应用程序来打开的方式类型，当该扩展名文件被访问的时候，浏览器会自动使用指定应用程序来打开</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"了解web及网络基础\">了解Web及网络基础</h2>\n<h3 id=\"网络基础tcpip-的分层管理\">网络基础TCP/IP 的分层管理</h3>\n<p>注 http是TCP/IP内部的一个子集。</p>\n<ul>\n<li>\n<p>**应用层：**决定了向用户提供应用服务时的通信的活动。<strong>DNS（域名系统）、FTP（文件传输协议）、HTTP协议处于应用层</strong></p>\n</li>\n<li>\n<p>**传输层：**传输层对上层应用层，提供处于网络连接中的两台计算机之间的数据传输。传输层有两个性质不同的协议：TCP（传输     控制器协议）和UDP（用户数据报协议）<strong>TCP（传输控制协议）、UDP（用户数据报协议）属于传输层。</strong></p>\n</li>\n<li>\n<p>**网络层(又名网络互联层)：**用来处理在网络上流动的数据包。  与对方计算机之间通过多台计算机或网络设备进行传输时，网络层所起的作用就是在众多的选项内选择一条传输路线。<strong>IP（网际协议）属于网络层。</strong></p>\n</li>\n<li>\n<p>**链路层（数据链路层，网络接口层）：**用来处理网络连接的硬件部分。<strong>包括控制操作系统、硬件设备的驱动、NIC（网络适配器，即网卡）</strong></p>\n</li>\n</ul>\n<p>数据包是网络传输的最小数据单位。</p>\n<p>TCP/IP通信传输流：客户端到服务器通过分层顺序传输 路由选择：在到达通信目标前的中转过程，计算机和路由器等网络设备，都只能获悉很粗略的传输路线，无法掌握互联网中全面传输情况</p>\n<p>发送端：从应用层<strong>往下走</strong>；每通过一层会<strong>增加该层</strong>的首部信息（这种把数据信息包装起来的做法称为封装）；</p>\n<p>接收端：则从链路层<strong>往上走</strong>到应用层；每通过一层会<strong>删除该层</strong>的首部信息；</p>\n<p><img src=\"http://img.kyootah.com/2021/05/09/cd4c7817e4c51.png\" alt></p>\n<p><img src=\"http://img.kyootah.com/2021/05/09/c370e3ba7bf2a.png\" alt></p>\n<p>客户端发送到服务器的过程：</p>\n<p><img src=\"http://img.kyootah.com/2021/05/09/39dd3f5883eec.png\" alt></p>\n<h3 id=\"tcp的三次握手\">TCP的三次握手</h3>\n<p>TCP的三次握手（是为了准确无误得将数据送达目标处，把包送出去后，向对方确认是否送达成功）</p>\n<ol>\n<li>发送端受限发送一个带SYN标志的数据包给对方。</li>\n<li>接收端收到后，回传一个带有SYN/ACK标志的数据包传达确认信息。</li>\n<li>最后，发送端再回传一个带ACK标志的数据包，代表握手结束。</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>阅读《图解http》总结，这本书通俗易懂，推荐阅读^_^<br>\nhttp 是 TCP/IP 内部的一个子集。</p>\n</blockquote>\n<h2>名词解释</h2>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">名词</th>\n<th>解释</th>\n<th>功能</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">HTTP</td>\n<td>Hyper Text Transfer Protocol（超文本传输协议）<strong>（应用层）</strong></td>\n<td>从服务器传输<strong>文本</strong>到本地浏览器的传输协议</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">HTML</td>\n<td>超文本标记语言</td>\n<td></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">URL</td>\n<td>统一资源定位系统（uniform resource locator）</td>\n<td>表示资源的地点。是URI的子集。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">URI</td>\n<td>统一资源标志符（universal resource identifier）</td>\n<td>用字符串表示某一互联网资源</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">TCP/IP协议族</td>\n<td>与互联网相关的协议集合</td>\n<td>数据链路层、网络层、传输层和应用层四个协议集合</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">DNS</td>\n<td>域名系统（Domain Name System）</td>\n<td>域名到IP地址之间的解析服务。DNS协议提供通过域名/IP名双向查找。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">TCP</td>\n<td>传输控制协议（Transmission Control Protocol）（<strong>传输层</strong>）</td>\n<td>进行数据分组，即对HTTP请求报文进行分割（为了方便运输，将大块数据分割成以报文段为单位的数据包进行管理）；并打上标记序号和端口号后转发给网络层。<strong>三次握手</strong></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">IP</td>\n<td>网际协议**（网络层）**</td>\n<td>`把各种数据包传给对方。要确保传送有两个重要条件：IP地址、MAC地址。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">IP地址</td>\n<td>指明了节点被分配到的地址；</td>\n<td></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">MAC地址</td>\n<td>指网卡所属的固定地址</td>\n<td>（<strong>通信双方经过多台计算机和网络设备中转进行连接，中转的时候，会利用下一站中转设备的MAC地址来搜索下一个中转目标</strong>）</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">ARP协议</td>\n<td>解析地址的协议</td>\n<td><strong>根据通信方的IP地址，反查出对应的MAC地址</strong></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">SSL</td>\n<td>安全套接字协议（Secure Sockets Layer）</td>\n<td>SSL协议位于TCP/IP协议与各种应用层协议之间，为数据通讯提供安全支持。（对传输数据进行加密）</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">TLS</td>\n<td>传输层安全（Transport Layer Security）</td>\n<td>它的前身是SSL，实现了将应用层的报文进行加密后再交由TCP进行传输</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">MIME</td>\n<td>多用途因特网邮件扩展（Multipurpose Internet Mail Extensions）</td>\n<td>用MIME类型可以设定某种扩展名的文件用一种应用程序来打开的方式类型，当该扩展名文件被访问的时候，浏览器会自动使用指定应用程序来打开</td>\n</tr>\n</tbody>\n</table>\n<h2>了解Web及网络基础</h2>\n<h3>网络基础TCP/IP 的分层管理</h3>\n<p>注 http是TCP/IP内部的一个子集。</p>\n<ul>\n<li>\n<p>**应用层：**决定了向用户提供应用服务时的通信的活动。<strong>DNS（域名系统）、FTP（文件传输协议）、HTTP协议处于应用层</strong></p>\n</li>\n<li>\n<p>**传输层：**传输层对上层应用层，提供处于网络连接中的两台计算机之间的数据传输。传输层有两个性质不同的协议：TCP（传输     控制器协议）和UDP（用户数据报协议）<strong>TCP（传输控制协议）、UDP（用户数据报协议）属于传输层。</strong></p>\n</li>\n<li>\n<p>**网络层(又名网络互联层)：**用来处理在网络上流动的数据包。  与对方计算机之间通过多台计算机或网络设备进行传输时，网络层所起的作用就是在众多的选项内选择一条传输路线。<strong>IP（网际协议）属于网络层。</strong></p>\n</li>\n<li>\n<p>**链路层（数据链路层，网络接口层）：**用来处理网络连接的硬件部分。<strong>包括控制操作系统、硬件设备的驱动、NIC（网络适配器，即网卡）</strong></p>\n</li>\n</ul>\n<p>数据包是网络传输的最小数据单位。</p>\n<p>TCP/IP通信传输流：客户端到服务器通过分层顺序传输 路由选择：在到达通信目标前的中转过程，计算机和路由器等网络设备，都只能获悉很粗略的传输路线，无法掌握互联网中全面传输情况</p>\n<p>发送端：从应用层<strong>往下走</strong>；每通过一层会<strong>增加该层</strong>的首部信息（这种把数据信息包装起来的做法称为封装）；</p>\n<p>接收端：则从链路层<strong>往上走</strong>到应用层；每通过一层会<strong>删除该层</strong>的首部信息；</p>\n<p><img src=\"http://img.kyootah.com/2021/05/09/cd4c7817e4c51.png\" alt></p>\n<p><img src=\"http://img.kyootah.com/2021/05/09/c370e3ba7bf2a.png\" alt></p>\n<p>客户端发送到服务器的过程：</p>\n<p><img src=\"http://img.kyootah.com/2021/05/09/39dd3f5883eec.png\" alt></p>\n<h3>TCP的三次握手</h3>\n<p>TCP的三次握手（是为了准确无误得将数据送达目标处，把包送出去后，向对方确认是否送达成功）</p>\n<ol>\n<li>发送端受限发送一个带SYN标志的数据包给对方。</li>\n<li>接收端收到后，回传一个带有SYN/ACK标志的数据包传达确认信息。</li>\n<li>最后，发送端再回传一个带ACK标志的数据包，代表握手结束。</li>\n</ol>\n"},{"title":"理解JS中的new及其工作","catalog":true,"date":"2020-06-30T08:16:40.000Z","subtitle":null,"header-img":null,"_content":"\n> 日常开发中`new`经常会出现在代码里，是时候花点时间深入理解一下`new`相关的知识点了。\n\n### new到底做了哪些事情\n\n先举个栗子\n```js\nfunction Person(firtName, lastName) {\n  this.firtName = firtName;\n  this.lastName = lastName;\n}\n\nPerson.prototype.getFullName = function () {\n  return `${this.firtName} ${this.lastName}`;\n};\n\nconst wyf = new Person('Wu', 'yifang');\nconsole.log(wyf); \n``` ","source":"_posts/理解JS中的new及其工作.md","raw":"---\ntitle: 理解JS中的new及其工作\ncatalog: true\ndate: 2020-06-30 16:16:40\nsubtitle:\nheader-img:\ntags:\n- JS基础\n- JavaScript深入\n---\n\n> 日常开发中`new`经常会出现在代码里，是时候花点时间深入理解一下`new`相关的知识点了。\n\n### new到底做了哪些事情\n\n先举个栗子\n```js\nfunction Person(firtName, lastName) {\n  this.firtName = firtName;\n  this.lastName = lastName;\n}\n\nPerson.prototype.getFullName = function () {\n  return `${this.firtName} ${this.lastName}`;\n};\n\nconst wyf = new Person('Wu', 'yifang');\nconsole.log(wyf); \n``` ","slug":"理解JS中的new及其工作","published":1,"updated":"2022-02-17T01:06:03.010Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl27vhg5z0011u8q5xzopyv3f","content":"<blockquote>\n<p>日常开发中<code>new</code>经常会出现在代码里，是时候花点时间深入理解一下<code>new</code>相关的知识点了。</p>\n</blockquote>\n<h3 id=\"new到底做了哪些事情\">new到底做了哪些事情</h3>\n<p>先举个栗子</p>\n<pre><code class=\"language-js\">function Person(firtName, lastName) {\n  this.firtName = firtName;\n  this.lastName = lastName;\n}\n\nPerson.prototype.getFullName = function () {\n  return `${this.firtName} ${this.lastName}`;\n};\n\nconst wyf = new Person('Wu', 'yifang');\nconsole.log(wyf); \n</code></pre>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>日常开发中<code>new</code>经常会出现在代码里，是时候花点时间深入理解一下<code>new</code>相关的知识点了。</p>\n</blockquote>\n<h3>new到底做了哪些事情</h3>\n<p>先举个栗子</p>\n<pre><code class=\"language-js\">function Person(firtName, lastName) {\n  this.firtName = firtName;\n  this.lastName = lastName;\n}\n\nPerson.prototype.getFullName = function () {\n  return `${this.firtName} ${this.lastName}`;\n};\n\nconst wyf = new Person('Wu', 'yifang');\nconsole.log(wyf); \n</code></pre>\n"},{"title":"回流(reflow)和重绘(repaint)","catalog":true,"date":"2021-08-12T12:16:40.000Z","subtitle":null,"header-img":null,"_content":"\n> 平时聊到关于前端优化的问题的时候经常听到`回流重绘`这个词，很多人都知道要减少浏览器的回流和重绘但对于具体操作及其原理比不了解，今天我们就要彻底掌握他！\n\n## 网页生成过程\n在了解回流重绘前我们先得知道html的渲染过程。\n1. HTML被HTML解析器解析成DOM 树\n2. css则被css解析器解析成CSSOM 树\n3. 结合DOM树和CSSOM树，生成一棵渲染树(Render Tree)\n4. 生成布局（`flow`），即将所有渲染树的所有节点进行平面合成\n5. 将布局绘制（`paint`）在屏幕上\n**第四步和第五步是最耗时的部分**，这两步合起来，就是我们通常所说的`渲染`。\n\n\n## 渲染\n**网页生成的时候，至少会渲染一次。**\n\n**在用户访问的过程中，还会不断重新渲染**\n\n重新渲染需要重复之前的第四步(重新生成布局)+第五步(重新绘制)或者只有第五个步(重新绘制)。\n\n**重排比重绘大：**\n大，在这个语境里的意思是：谁能影响谁？\n\n* 重绘：某些元素的外观被改变，例如：元素的填充颜色\n* 重排：重新生成布局，重新排列元素。\n\n就如上面的概念一样，单单改变元素的外观，肯定不会引起网页重新生成布局，但当浏览器完成重排之后，将会重新绘制受到此次重排影响的部分。 \n**回流必将引起重绘，重绘不一定会引起回流。**\n \n## 回流 (Reflow)\n当`Render Tree`中部分或全部元素的尺寸、结构、或某些属性发生改变时，浏览器重新渲染部分或全部文档的过程称为回流。\n\n**会导致回流的操作：**\n\n* 页面首次渲染\n* 浏览器窗口大小发生改变\n* 元素尺寸或位置发生改变\n* 元素内容变化（文字数量或图片大小等等）\n* 元素字体大小变化\n* 添加或者删除可见的DOM元素\n* 激活CSS伪类（例如：:hover）\n* 查询某些属性或调用某些方法\n  \n\n**一些常用且会导致回流的属性和方法:**\n\n* clientWidth、clientHeight、clientTop、clientLeft\n* offsetWidth、offsetHeight、offsetTop、offsetLeft\n* scrollWidth、scrollHeight、scrollTop、scrollLeft\n* scrollIntoView()、scrollIntoViewIfNeeded()\n* getComputedStyle()\n* getBoundingClientRect()\n* scrollTo()\n\n\n## 重绘(repaint)\n当页面中元素样式的改变并不影响它在文档流中的位置时（例如：color、background-color、visibility等），浏览器会将新样式赋予给元素并重新绘制它，这个过程称为重绘。\n\n\n## 浏览器的渲染队列\n思考以下代码将会触发几次渲染？\n```js\ndiv.style.left = '10px';\ndiv.style.top = '10px';\ndiv.style.width = '20px';\ndiv.style.height = '20px';\n```\n根据我们上文的定义，**这段代码理论上会触发4次重排+重绘**，因为每一次都改变了元素的几何属性，**实际上最后只触发了一次重排**，这都得益于浏览器的`渲染队列机制` ：\n当我们修改了元素的几何属性，导致浏览器触发重排或重绘时。它会把该操作放进渲染队列，等到队列中的操作到了**一定的数量或者到了一定的时间间隔时**，浏览器就会批量执行这些操作。\n\n### 强制刷新队列\n```js\ndiv.style.left = '10px';\nconsole.log(div.offsetLeft);\ndiv.style.top = '10px';\nconsole.log(div.offsetTop);\ndiv.style.width = '20px';\nconsole.log(div.offsetWidth);\ndiv.style.height = '20px';\nconsole.log(div.offsetHeight);\n```\n**这段代码会触发4次重排+重绘**，因为在console中**你请求的这几个样式信息**，无论何时浏览器都会立即执行渲染队列的任务，即使该值与你操作中修改的值没关联。\n**因为队列中，可能会有影响到这些值的操作，为了给我们最精确的值，浏览器会立即重排+重绘。**\n**我们在开发中，应该谨慎的使用这些style请求，注意上下文关系,避免一行代码一个重排，这对性能是个巨大的消耗**\n\n## 优化建议\n### 1.分离读写操作\n```js\ndiv.style.left = '10px';\ndiv.style.top = '10px';\ndiv.style.width = '20px';\ndiv.style.height = '20px';\nconsole.log(div.offsetLeft);\nconsole.log(div.offsetTop);\nconsole.log(div.offsetWidth);\nconsole.log(div.offsetHeight);\n```\n代码注意上下文关系，例如上面这样写的话就只触发了一次重排\n\n### 2.样式集中改变\n```js\ndiv.style.left = '10px';\ndiv.style.top = '10px';\ndiv.style.width = '20px';\ndiv.style.height = '20px';\n```\n虽然现在大部分浏览器有渲染队列优化，不排除有些浏览器以及老版本的浏览器效率仍然低下\n建议通过改变class或者csstext属性集中改变样式\n```js\n// bad\nvar left = 10;\nvar top = 10;\nel.style.left = left + \"px\";\nel.style.top  = top  + \"px\";\n// good \nel.className += \" theclassname\";\n// good\nel.style.cssText += \"; left: \" + left + \"px; top: \" + top + \"px;\";\n```\n\n### 3.缓存布局信息\n```js\n// bad 强制刷新 触发两次重排\ndiv.style.left = div.offsetLeft + 1 + 'px';\ndiv.style.top = div.offsetTop + 1 + 'px';\n\n// good 缓存布局信息 相当于读写分离\nvar curLeft = div.offsetLeft;\nvar curTop = div.offsetTop;\ndiv.style.left = curLeft + 1 + 'px';\ndiv.style.top = curTop + 1 + 'px';\n```\n\n### 4.离线改变dom\n1. 隐藏要操作的dom\n在要操作dom之前，通过display隐藏dom，当操作完成之后，才将元素的display属性为可见，因为不可见的元素不会触发重排和重绘。\n```js\ndom.display = 'none'\n// 修改dom样式\ndom.display = 'block'\n```\n2. 通过使用[DocumentFragment](https://developer.mozilla.org/zh-CN/docs/Web/API/DocumentFragment)创建一个dom碎片,在它上面批量操作dom，操作完成之后，再添加到文档中，这样只会触发一次重排。\n3. 复制节点，在副本上工作，然后替换它\n\n\n### 5.position属性为absolute或fixed\nposition属性为absolute或fixed的元素，重排开销比较小，不用考虑它对其他元素的影响(脱离文档流，不会对父元素造成影响)\n\n\n### 6.CSS相关优化\n* **position属性为absolute或fixed**\n可以把动画效果应用到position属性为absolute或fixed的元素上，这样对其他元素影响较小.\n动画效果还应牺牲一些平滑，来换取速度，这中间的度自己衡量：\n\n比如实现一个动画，以1个像素为单位移动这样最平滑，但是reflow就会过于频繁，大量消耗CPU资源，如果以3个像素为单位移动则会好很多。\n\n* **避免使用table布局**\n由于浏览器使用流式布局，对Render Tree的计算通常只需要遍历一次就可以完成，但table及其内部元素除外，他们可能需要多次计算，通常要花3倍于同等元素的时间，这也是为什么要避免使用table布局的原因之一。\n\n* **避免设置多层内联样式**\n \n* **避免使用CSS表达式**","source":"_posts/重排(reflow)和重绘(repaint).md","raw":"---\ntitle: 回流(reflow)和重绘(repaint)\ncatalog: true\ndate: 2021-08-12 20:16:40\nsubtitle:\nheader-img:\ntags:\n- 渲染队列\n- 回流重绘\n- 前端进阶\n- 项目优化\n---\n\n> 平时聊到关于前端优化的问题的时候经常听到`回流重绘`这个词，很多人都知道要减少浏览器的回流和重绘但对于具体操作及其原理比不了解，今天我们就要彻底掌握他！\n\n## 网页生成过程\n在了解回流重绘前我们先得知道html的渲染过程。\n1. HTML被HTML解析器解析成DOM 树\n2. css则被css解析器解析成CSSOM 树\n3. 结合DOM树和CSSOM树，生成一棵渲染树(Render Tree)\n4. 生成布局（`flow`），即将所有渲染树的所有节点进行平面合成\n5. 将布局绘制（`paint`）在屏幕上\n**第四步和第五步是最耗时的部分**，这两步合起来，就是我们通常所说的`渲染`。\n\n\n## 渲染\n**网页生成的时候，至少会渲染一次。**\n\n**在用户访问的过程中，还会不断重新渲染**\n\n重新渲染需要重复之前的第四步(重新生成布局)+第五步(重新绘制)或者只有第五个步(重新绘制)。\n\n**重排比重绘大：**\n大，在这个语境里的意思是：谁能影响谁？\n\n* 重绘：某些元素的外观被改变，例如：元素的填充颜色\n* 重排：重新生成布局，重新排列元素。\n\n就如上面的概念一样，单单改变元素的外观，肯定不会引起网页重新生成布局，但当浏览器完成重排之后，将会重新绘制受到此次重排影响的部分。 \n**回流必将引起重绘，重绘不一定会引起回流。**\n \n## 回流 (Reflow)\n当`Render Tree`中部分或全部元素的尺寸、结构、或某些属性发生改变时，浏览器重新渲染部分或全部文档的过程称为回流。\n\n**会导致回流的操作：**\n\n* 页面首次渲染\n* 浏览器窗口大小发生改变\n* 元素尺寸或位置发生改变\n* 元素内容变化（文字数量或图片大小等等）\n* 元素字体大小变化\n* 添加或者删除可见的DOM元素\n* 激活CSS伪类（例如：:hover）\n* 查询某些属性或调用某些方法\n  \n\n**一些常用且会导致回流的属性和方法:**\n\n* clientWidth、clientHeight、clientTop、clientLeft\n* offsetWidth、offsetHeight、offsetTop、offsetLeft\n* scrollWidth、scrollHeight、scrollTop、scrollLeft\n* scrollIntoView()、scrollIntoViewIfNeeded()\n* getComputedStyle()\n* getBoundingClientRect()\n* scrollTo()\n\n\n## 重绘(repaint)\n当页面中元素样式的改变并不影响它在文档流中的位置时（例如：color、background-color、visibility等），浏览器会将新样式赋予给元素并重新绘制它，这个过程称为重绘。\n\n\n## 浏览器的渲染队列\n思考以下代码将会触发几次渲染？\n```js\ndiv.style.left = '10px';\ndiv.style.top = '10px';\ndiv.style.width = '20px';\ndiv.style.height = '20px';\n```\n根据我们上文的定义，**这段代码理论上会触发4次重排+重绘**，因为每一次都改变了元素的几何属性，**实际上最后只触发了一次重排**，这都得益于浏览器的`渲染队列机制` ：\n当我们修改了元素的几何属性，导致浏览器触发重排或重绘时。它会把该操作放进渲染队列，等到队列中的操作到了**一定的数量或者到了一定的时间间隔时**，浏览器就会批量执行这些操作。\n\n### 强制刷新队列\n```js\ndiv.style.left = '10px';\nconsole.log(div.offsetLeft);\ndiv.style.top = '10px';\nconsole.log(div.offsetTop);\ndiv.style.width = '20px';\nconsole.log(div.offsetWidth);\ndiv.style.height = '20px';\nconsole.log(div.offsetHeight);\n```\n**这段代码会触发4次重排+重绘**，因为在console中**你请求的这几个样式信息**，无论何时浏览器都会立即执行渲染队列的任务，即使该值与你操作中修改的值没关联。\n**因为队列中，可能会有影响到这些值的操作，为了给我们最精确的值，浏览器会立即重排+重绘。**\n**我们在开发中，应该谨慎的使用这些style请求，注意上下文关系,避免一行代码一个重排，这对性能是个巨大的消耗**\n\n## 优化建议\n### 1.分离读写操作\n```js\ndiv.style.left = '10px';\ndiv.style.top = '10px';\ndiv.style.width = '20px';\ndiv.style.height = '20px';\nconsole.log(div.offsetLeft);\nconsole.log(div.offsetTop);\nconsole.log(div.offsetWidth);\nconsole.log(div.offsetHeight);\n```\n代码注意上下文关系，例如上面这样写的话就只触发了一次重排\n\n### 2.样式集中改变\n```js\ndiv.style.left = '10px';\ndiv.style.top = '10px';\ndiv.style.width = '20px';\ndiv.style.height = '20px';\n```\n虽然现在大部分浏览器有渲染队列优化，不排除有些浏览器以及老版本的浏览器效率仍然低下\n建议通过改变class或者csstext属性集中改变样式\n```js\n// bad\nvar left = 10;\nvar top = 10;\nel.style.left = left + \"px\";\nel.style.top  = top  + \"px\";\n// good \nel.className += \" theclassname\";\n// good\nel.style.cssText += \"; left: \" + left + \"px; top: \" + top + \"px;\";\n```\n\n### 3.缓存布局信息\n```js\n// bad 强制刷新 触发两次重排\ndiv.style.left = div.offsetLeft + 1 + 'px';\ndiv.style.top = div.offsetTop + 1 + 'px';\n\n// good 缓存布局信息 相当于读写分离\nvar curLeft = div.offsetLeft;\nvar curTop = div.offsetTop;\ndiv.style.left = curLeft + 1 + 'px';\ndiv.style.top = curTop + 1 + 'px';\n```\n\n### 4.离线改变dom\n1. 隐藏要操作的dom\n在要操作dom之前，通过display隐藏dom，当操作完成之后，才将元素的display属性为可见，因为不可见的元素不会触发重排和重绘。\n```js\ndom.display = 'none'\n// 修改dom样式\ndom.display = 'block'\n```\n2. 通过使用[DocumentFragment](https://developer.mozilla.org/zh-CN/docs/Web/API/DocumentFragment)创建一个dom碎片,在它上面批量操作dom，操作完成之后，再添加到文档中，这样只会触发一次重排。\n3. 复制节点，在副本上工作，然后替换它\n\n\n### 5.position属性为absolute或fixed\nposition属性为absolute或fixed的元素，重排开销比较小，不用考虑它对其他元素的影响(脱离文档流，不会对父元素造成影响)\n\n\n### 6.CSS相关优化\n* **position属性为absolute或fixed**\n可以把动画效果应用到position属性为absolute或fixed的元素上，这样对其他元素影响较小.\n动画效果还应牺牲一些平滑，来换取速度，这中间的度自己衡量：\n\n比如实现一个动画，以1个像素为单位移动这样最平滑，但是reflow就会过于频繁，大量消耗CPU资源，如果以3个像素为单位移动则会好很多。\n\n* **避免使用table布局**\n由于浏览器使用流式布局，对Render Tree的计算通常只需要遍历一次就可以完成，但table及其内部元素除外，他们可能需要多次计算，通常要花3倍于同等元素的时间，这也是为什么要避免使用table布局的原因之一。\n\n* **避免设置多层内联样式**\n \n* **避免使用CSS表达式**","slug":"重排(reflow)和重绘(repaint)","published":1,"updated":"2022-03-03T09:16:39.052Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl27vhg600013u8q5eq3xkeli","content":"<blockquote>\n<p>平时聊到关于前端优化的问题的时候经常听到<code>回流重绘</code>这个词，很多人都知道要减少浏览器的回流和重绘但对于具体操作及其原理比不了解，今天我们就要彻底掌握他！</p>\n</blockquote>\n<h2 id=\"网页生成过程\">网页生成过程</h2>\n<p>在了解回流重绘前我们先得知道html的渲染过程。</p>\n<ol>\n<li>HTML被HTML解析器解析成DOM 树</li>\n<li>css则被css解析器解析成CSSOM 树</li>\n<li>结合DOM树和CSSOM树，生成一棵渲染树(Render Tree)</li>\n<li>生成布局（<code>flow</code>），即将所有渲染树的所有节点进行平面合成</li>\n<li>将布局绘制（<code>paint</code>）在屏幕上<br>\n<strong>第四步和第五步是最耗时的部分</strong>，这两步合起来，就是我们通常所说的<code>渲染</code>。</li>\n</ol>\n<h2 id=\"渲染\">渲染</h2>\n<p><strong>网页生成的时候，至少会渲染一次。</strong></p>\n<p><strong>在用户访问的过程中，还会不断重新渲染</strong></p>\n<p>重新渲染需要重复之前的第四步(重新生成布局)+第五步(重新绘制)或者只有第五个步(重新绘制)。</p>\n<p><strong>重排比重绘大：</strong><br>\n大，在这个语境里的意思是：谁能影响谁？</p>\n<ul>\n<li>重绘：某些元素的外观被改变，例如：元素的填充颜色</li>\n<li>重排：重新生成布局，重新排列元素。</li>\n</ul>\n<p>就如上面的概念一样，单单改变元素的外观，肯定不会引起网页重新生成布局，但当浏览器完成重排之后，将会重新绘制受到此次重排影响的部分。<br>\n<strong>回流必将引起重绘，重绘不一定会引起回流。</strong></p>\n<h2 id=\"回流-reflow\">回流 (Reflow)</h2>\n<p>当<code>Render Tree</code>中部分或全部元素的尺寸、结构、或某些属性发生改变时，浏览器重新渲染部分或全部文档的过程称为回流。</p>\n<p><strong>会导致回流的操作：</strong></p>\n<ul>\n<li>页面首次渲染</li>\n<li>浏览器窗口大小发生改变</li>\n<li>元素尺寸或位置发生改变</li>\n<li>元素内容变化（文字数量或图片大小等等）</li>\n<li>元素字体大小变化</li>\n<li>添加或者删除可见的DOM元素</li>\n<li>激活CSS伪类（例如：:hover）</li>\n<li>查询某些属性或调用某些方法</li>\n</ul>\n<p><strong>一些常用且会导致回流的属性和方法:</strong></p>\n<ul>\n<li>clientWidth、clientHeight、clientTop、clientLeft</li>\n<li>offsetWidth、offsetHeight、offsetTop、offsetLeft</li>\n<li>scrollWidth、scrollHeight、scrollTop、scrollLeft</li>\n<li>scrollIntoView()、scrollIntoViewIfNeeded()</li>\n<li>getComputedStyle()</li>\n<li>getBoundingClientRect()</li>\n<li>scrollTo()</li>\n</ul>\n<h2 id=\"重绘repaint\">重绘(repaint)</h2>\n<p>当页面中元素样式的改变并不影响它在文档流中的位置时（例如：color、background-color、visibility等），浏览器会将新样式赋予给元素并重新绘制它，这个过程称为重绘。</p>\n<h2 id=\"浏览器的渲染队列\">浏览器的渲染队列</h2>\n<p>思考以下代码将会触发几次渲染？</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">div.style.left = <span class=\"string\">'10px'</span>;</span><br><span class=\"line\">div.style.top = <span class=\"string\">'10px'</span>;</span><br><span class=\"line\">div.style.width = <span class=\"string\">'20px'</span>;</span><br><span class=\"line\">div.style.height = <span class=\"string\">'20px'</span>;</span><br></pre></td></tr></table></figure>\n<p>根据我们上文的定义，<strong>这段代码理论上会触发4次重排+重绘</strong>，因为每一次都改变了元素的几何属性，<strong>实际上最后只触发了一次重排</strong>，这都得益于浏览器的<code>渲染队列机制</code> ：<br>\n当我们修改了元素的几何属性，导致浏览器触发重排或重绘时。它会把该操作放进渲染队列，等到队列中的操作到了<strong>一定的数量或者到了一定的时间间隔时</strong>，浏览器就会批量执行这些操作。</p>\n<h3 id=\"强制刷新队列\">强制刷新队列</h3>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">div.style.left = <span class=\"string\">'10px'</span>;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(div.offsetLeft);</span><br><span class=\"line\">div.style.top = <span class=\"string\">'10px'</span>;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(div.offsetTop);</span><br><span class=\"line\">div.style.width = <span class=\"string\">'20px'</span>;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(div.offsetWidth);</span><br><span class=\"line\">div.style.height = <span class=\"string\">'20px'</span>;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(div.offsetHeight);</span><br></pre></td></tr></table></figure>\n<p><strong>这段代码会触发4次重排+重绘</strong>，因为在console中<strong>你请求的这几个样式信息</strong>，无论何时浏览器都会立即执行渲染队列的任务，即使该值与你操作中修改的值没关联。<br>\n<strong>因为队列中，可能会有影响到这些值的操作，为了给我们最精确的值，浏览器会立即重排+重绘。</strong><br>\n<strong>我们在开发中，应该谨慎的使用这些style请求，注意上下文关系,避免一行代码一个重排，这对性能是个巨大的消耗</strong></p>\n<h2 id=\"优化建议\">优化建议</h2>\n<h3 id=\"1分离读写操作\">1.分离读写操作</h3>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">div.style.left = <span class=\"string\">'10px'</span>;</span><br><span class=\"line\">div.style.top = <span class=\"string\">'10px'</span>;</span><br><span class=\"line\">div.style.width = <span class=\"string\">'20px'</span>;</span><br><span class=\"line\">div.style.height = <span class=\"string\">'20px'</span>;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(div.offsetLeft);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(div.offsetTop);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(div.offsetWidth);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(div.offsetHeight);</span><br></pre></td></tr></table></figure>\n<p>代码注意上下文关系，例如上面这样写的话就只触发了一次重排</p>\n<h3 id=\"2样式集中改变\">2.样式集中改变</h3>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">div.style.left = <span class=\"string\">'10px'</span>;</span><br><span class=\"line\">div.style.top = <span class=\"string\">'10px'</span>;</span><br><span class=\"line\">div.style.width = <span class=\"string\">'20px'</span>;</span><br><span class=\"line\">div.style.height = <span class=\"string\">'20px'</span>;</span><br></pre></td></tr></table></figure>\n<p>虽然现在大部分浏览器有渲染队列优化，不排除有些浏览器以及老版本的浏览器效率仍然低下<br>\n建议通过改变class或者csstext属性集中改变样式</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// bad</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> left = <span class=\"number\">10</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> top = <span class=\"number\">10</span>;</span><br><span class=\"line\">el.style.left = left + <span class=\"string\">\"px\"</span>;</span><br><span class=\"line\">el.style.top  = top  + <span class=\"string\">\"px\"</span>;</span><br><span class=\"line\"><span class=\"comment\">// good </span></span><br><span class=\"line\">el.className += <span class=\"string\">\" theclassname\"</span>;</span><br><span class=\"line\"><span class=\"comment\">// good</span></span><br><span class=\"line\">el.style.cssText += <span class=\"string\">\"; left: \"</span> + left + <span class=\"string\">\"px; top: \"</span> + top + <span class=\"string\">\"px;\"</span>;</span><br></pre></td></tr></table></figure>\n<h3 id=\"3缓存布局信息\">3.缓存布局信息</h3>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// bad 强制刷新 触发两次重排</span></span><br><span class=\"line\">div.style.left = div.offsetLeft + <span class=\"number\">1</span> + <span class=\"string\">'px'</span>;</span><br><span class=\"line\">div.style.top = div.offsetTop + <span class=\"number\">1</span> + <span class=\"string\">'px'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// good 缓存布局信息 相当于读写分离</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> curLeft = div.offsetLeft;</span><br><span class=\"line\"><span class=\"keyword\">var</span> curTop = div.offsetTop;</span><br><span class=\"line\">div.style.left = curLeft + <span class=\"number\">1</span> + <span class=\"string\">'px'</span>;</span><br><span class=\"line\">div.style.top = curTop + <span class=\"number\">1</span> + <span class=\"string\">'px'</span>;</span><br></pre></td></tr></table></figure>\n<h3 id=\"4离线改变dom\">4.离线改变dom</h3>\n<ol>\n<li>隐藏要操作的dom<br>\n在要操作dom之前，通过display隐藏dom，当操作完成之后，才将元素的display属性为可见，因为不可见的元素不会触发重排和重绘。</li>\n</ol>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dom.display = <span class=\"string\">'none'</span></span><br><span class=\"line\"><span class=\"comment\">// 修改dom样式</span></span><br><span class=\"line\">dom.display = <span class=\"string\">'block'</span></span><br></pre></td></tr></table></figure>\n<ol start=\"2\">\n<li>通过使用<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/API/DocumentFragment\" target=\"_blank\" rel=\"noopener\">DocumentFragment</a>创建一个dom碎片,在它上面批量操作dom，操作完成之后，再添加到文档中，这样只会触发一次重排。</li>\n<li>复制节点，在副本上工作，然后替换它</li>\n</ol>\n<h3 id=\"5position属性为absolute或fixed\">5.position属性为absolute或fixed</h3>\n<p>position属性为absolute或fixed的元素，重排开销比较小，不用考虑它对其他元素的影响(脱离文档流，不会对父元素造成影响)</p>\n<h3 id=\"6css相关优化\">6.CSS相关优化</h3>\n<ul>\n<li><strong>position属性为absolute或fixed</strong><br>\n可以把动画效果应用到position属性为absolute或fixed的元素上，这样对其他元素影响较小.<br>\n动画效果还应牺牲一些平滑，来换取速度，这中间的度自己衡量：</li>\n</ul>\n<p>比如实现一个动画，以1个像素为单位移动这样最平滑，但是reflow就会过于频繁，大量消耗CPU资源，如果以3个像素为单位移动则会好很多。</p>\n<ul>\n<li>\n<p><strong>避免使用table布局</strong><br>\n由于浏览器使用流式布局，对Render Tree的计算通常只需要遍历一次就可以完成，但table及其内部元素除外，他们可能需要多次计算，通常要花3倍于同等元素的时间，这也是为什么要避免使用table布局的原因之一。</p>\n</li>\n<li>\n<p><strong>避免设置多层内联样式</strong></p>\n</li>\n<li>\n<p><strong>避免使用CSS表达式</strong></p>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>平时聊到关于前端优化的问题的时候经常听到<code>回流重绘</code>这个词，很多人都知道要减少浏览器的回流和重绘但对于具体操作及其原理比不了解，今天我们就要彻底掌握他！</p>\n</blockquote>\n<h2>网页生成过程</h2>\n<p>在了解回流重绘前我们先得知道html的渲染过程。</p>\n<ol>\n<li>HTML被HTML解析器解析成DOM 树</li>\n<li>css则被css解析器解析成CSSOM 树</li>\n<li>结合DOM树和CSSOM树，生成一棵渲染树(Render Tree)</li>\n<li>生成布局（<code>flow</code>），即将所有渲染树的所有节点进行平面合成</li>\n<li>将布局绘制（<code>paint</code>）在屏幕上<br>\n<strong>第四步和第五步是最耗时的部分</strong>，这两步合起来，就是我们通常所说的<code>渲染</code>。</li>\n</ol>\n<h2>渲染</h2>\n<p><strong>网页生成的时候，至少会渲染一次。</strong></p>\n<p><strong>在用户访问的过程中，还会不断重新渲染</strong></p>\n<p>重新渲染需要重复之前的第四步(重新生成布局)+第五步(重新绘制)或者只有第五个步(重新绘制)。</p>\n<p><strong>重排比重绘大：</strong><br>\n大，在这个语境里的意思是：谁能影响谁？</p>\n<ul>\n<li>重绘：某些元素的外观被改变，例如：元素的填充颜色</li>\n<li>重排：重新生成布局，重新排列元素。</li>\n</ul>\n<p>就如上面的概念一样，单单改变元素的外观，肯定不会引起网页重新生成布局，但当浏览器完成重排之后，将会重新绘制受到此次重排影响的部分。<br>\n<strong>回流必将引起重绘，重绘不一定会引起回流。</strong></p>\n<h2>回流 (Reflow)</h2>\n<p>当<code>Render Tree</code>中部分或全部元素的尺寸、结构、或某些属性发生改变时，浏览器重新渲染部分或全部文档的过程称为回流。</p>\n<p><strong>会导致回流的操作：</strong></p>\n<ul>\n<li>页面首次渲染</li>\n<li>浏览器窗口大小发生改变</li>\n<li>元素尺寸或位置发生改变</li>\n<li>元素内容变化（文字数量或图片大小等等）</li>\n<li>元素字体大小变化</li>\n<li>添加或者删除可见的DOM元素</li>\n<li>激活CSS伪类（例如：:hover）</li>\n<li>查询某些属性或调用某些方法</li>\n</ul>\n<p><strong>一些常用且会导致回流的属性和方法:</strong></p>\n<ul>\n<li>clientWidth、clientHeight、clientTop、clientLeft</li>\n<li>offsetWidth、offsetHeight、offsetTop、offsetLeft</li>\n<li>scrollWidth、scrollHeight、scrollTop、scrollLeft</li>\n<li>scrollIntoView()、scrollIntoViewIfNeeded()</li>\n<li>getComputedStyle()</li>\n<li>getBoundingClientRect()</li>\n<li>scrollTo()</li>\n</ul>\n<h2>重绘(repaint)</h2>\n<p>当页面中元素样式的改变并不影响它在文档流中的位置时（例如：color、background-color、visibility等），浏览器会将新样式赋予给元素并重新绘制它，这个过程称为重绘。</p>\n<h2>浏览器的渲染队列</h2>\n<p>思考以下代码将会触发几次渲染？</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">div.style.left = <span class=\"string\">'10px'</span>;</span><br><span class=\"line\">div.style.top = <span class=\"string\">'10px'</span>;</span><br><span class=\"line\">div.style.width = <span class=\"string\">'20px'</span>;</span><br><span class=\"line\">div.style.height = <span class=\"string\">'20px'</span>;</span><br></pre></td></tr></table></figure>\n<p>根据我们上文的定义，<strong>这段代码理论上会触发4次重排+重绘</strong>，因为每一次都改变了元素的几何属性，<strong>实际上最后只触发了一次重排</strong>，这都得益于浏览器的<code>渲染队列机制</code> ：<br>\n当我们修改了元素的几何属性，导致浏览器触发重排或重绘时。它会把该操作放进渲染队列，等到队列中的操作到了<strong>一定的数量或者到了一定的时间间隔时</strong>，浏览器就会批量执行这些操作。</p>\n<h3>强制刷新队列</h3>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">div.style.left = <span class=\"string\">'10px'</span>;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(div.offsetLeft);</span><br><span class=\"line\">div.style.top = <span class=\"string\">'10px'</span>;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(div.offsetTop);</span><br><span class=\"line\">div.style.width = <span class=\"string\">'20px'</span>;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(div.offsetWidth);</span><br><span class=\"line\">div.style.height = <span class=\"string\">'20px'</span>;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(div.offsetHeight);</span><br></pre></td></tr></table></figure>\n<p><strong>这段代码会触发4次重排+重绘</strong>，因为在console中<strong>你请求的这几个样式信息</strong>，无论何时浏览器都会立即执行渲染队列的任务，即使该值与你操作中修改的值没关联。<br>\n<strong>因为队列中，可能会有影响到这些值的操作，为了给我们最精确的值，浏览器会立即重排+重绘。</strong><br>\n<strong>我们在开发中，应该谨慎的使用这些style请求，注意上下文关系,避免一行代码一个重排，这对性能是个巨大的消耗</strong></p>\n<h2>优化建议</h2>\n<h3>1.分离读写操作</h3>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">div.style.left = <span class=\"string\">'10px'</span>;</span><br><span class=\"line\">div.style.top = <span class=\"string\">'10px'</span>;</span><br><span class=\"line\">div.style.width = <span class=\"string\">'20px'</span>;</span><br><span class=\"line\">div.style.height = <span class=\"string\">'20px'</span>;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(div.offsetLeft);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(div.offsetTop);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(div.offsetWidth);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(div.offsetHeight);</span><br></pre></td></tr></table></figure>\n<p>代码注意上下文关系，例如上面这样写的话就只触发了一次重排</p>\n<h3>2.样式集中改变</h3>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">div.style.left = <span class=\"string\">'10px'</span>;</span><br><span class=\"line\">div.style.top = <span class=\"string\">'10px'</span>;</span><br><span class=\"line\">div.style.width = <span class=\"string\">'20px'</span>;</span><br><span class=\"line\">div.style.height = <span class=\"string\">'20px'</span>;</span><br></pre></td></tr></table></figure>\n<p>虽然现在大部分浏览器有渲染队列优化，不排除有些浏览器以及老版本的浏览器效率仍然低下<br>\n建议通过改变class或者csstext属性集中改变样式</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// bad</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> left = <span class=\"number\">10</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> top = <span class=\"number\">10</span>;</span><br><span class=\"line\">el.style.left = left + <span class=\"string\">\"px\"</span>;</span><br><span class=\"line\">el.style.top  = top  + <span class=\"string\">\"px\"</span>;</span><br><span class=\"line\"><span class=\"comment\">// good </span></span><br><span class=\"line\">el.className += <span class=\"string\">\" theclassname\"</span>;</span><br><span class=\"line\"><span class=\"comment\">// good</span></span><br><span class=\"line\">el.style.cssText += <span class=\"string\">\"; left: \"</span> + left + <span class=\"string\">\"px; top: \"</span> + top + <span class=\"string\">\"px;\"</span>;</span><br></pre></td></tr></table></figure>\n<h3>3.缓存布局信息</h3>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// bad 强制刷新 触发两次重排</span></span><br><span class=\"line\">div.style.left = div.offsetLeft + <span class=\"number\">1</span> + <span class=\"string\">'px'</span>;</span><br><span class=\"line\">div.style.top = div.offsetTop + <span class=\"number\">1</span> + <span class=\"string\">'px'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// good 缓存布局信息 相当于读写分离</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> curLeft = div.offsetLeft;</span><br><span class=\"line\"><span class=\"keyword\">var</span> curTop = div.offsetTop;</span><br><span class=\"line\">div.style.left = curLeft + <span class=\"number\">1</span> + <span class=\"string\">'px'</span>;</span><br><span class=\"line\">div.style.top = curTop + <span class=\"number\">1</span> + <span class=\"string\">'px'</span>;</span><br></pre></td></tr></table></figure>\n<h3>4.离线改变dom</h3>\n<ol>\n<li>隐藏要操作的dom<br>\n在要操作dom之前，通过display隐藏dom，当操作完成之后，才将元素的display属性为可见，因为不可见的元素不会触发重排和重绘。</li>\n</ol>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dom.display = <span class=\"string\">'none'</span></span><br><span class=\"line\"><span class=\"comment\">// 修改dom样式</span></span><br><span class=\"line\">dom.display = <span class=\"string\">'block'</span></span><br></pre></td></tr></table></figure>\n<ol start=\"2\">\n<li>通过使用<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/API/DocumentFragment\" target=\"_blank\" rel=\"noopener\">DocumentFragment</a>创建一个dom碎片,在它上面批量操作dom，操作完成之后，再添加到文档中，这样只会触发一次重排。</li>\n<li>复制节点，在副本上工作，然后替换它</li>\n</ol>\n<h3>5.position属性为absolute或fixed</h3>\n<p>position属性为absolute或fixed的元素，重排开销比较小，不用考虑它对其他元素的影响(脱离文档流，不会对父元素造成影响)</p>\n<h3>6.CSS相关优化</h3>\n<ul>\n<li><strong>position属性为absolute或fixed</strong><br>\n可以把动画效果应用到position属性为absolute或fixed的元素上，这样对其他元素影响较小.<br>\n动画效果还应牺牲一些平滑，来换取速度，这中间的度自己衡量：</li>\n</ul>\n<p>比如实现一个动画，以1个像素为单位移动这样最平滑，但是reflow就会过于频繁，大量消耗CPU资源，如果以3个像素为单位移动则会好很多。</p>\n<ul>\n<li>\n<p><strong>避免使用table布局</strong><br>\n由于浏览器使用流式布局，对Render Tree的计算通常只需要遍历一次就可以完成，但table及其内部元素除外，他们可能需要多次计算，通常要花3倍于同等元素的时间，这也是为什么要避免使用table布局的原因之一。</p>\n</li>\n<li>\n<p><strong>避免设置多层内联样式</strong></p>\n</li>\n<li>\n<p><strong>避免使用CSS表达式</strong></p>\n</li>\n</ul>\n"}],"PostAsset":[],"PostCategory":[{"post_id":"cl27vhg550003u8q559ywynem","category_id":"cl27vhg5d0008u8q5vixblpzh","_id":"cl27vhg5m000hu8q5l5lco5ex"},{"post_id":"cl27vhg5p000nu8q55obzn2ad","category_id":"cl27vhg5n000ju8q5oh39jo5p","_id":"cl27vhg5w000wu8q535d8oag6"},{"post_id":"cl27vhg5k000eu8q5wu3aehgs","category_id":"cl27vhg5n000ju8q5oh39jo5p","_id":"cl27vhg5y000zu8q5r5pv2mfp"},{"post_id":"cl27vhg5q000pu8q5y6it75k7","category_id":"cl27vhg5n000ju8q5oh39jo5p","_id":"cl27vhg5z0012u8q5lof6zsgu"},{"post_id":"cl27vhg5u000tu8q5xdne0dn9","category_id":"cl27vhg5d0008u8q5vixblpzh","_id":"cl27vhg600014u8q5v8s5w7bz"},{"post_id":"cl27vhg5n000ku8q5jy6vuqlj","category_id":"cl27vhg5n000ju8q5oh39jo5p","_id":"cl27vhg610016u8q5uizr0u4f"}],"PostTag":[{"post_id":"cl27vhg5d0009u8q5c0im9slx","tag_id":"cl27vhg590005u8q5y8ci2ybb","_id":"cl27vhg5h000cu8q5hifab22k"},{"post_id":"cl27vhg510001u8q5uztrs37v","tag_id":"cl27vhg590005u8q5y8ci2ybb","_id":"cl27vhg5m000iu8q5f26of0ux"},{"post_id":"cl27vhg510001u8q5uztrs37v","tag_id":"cl27vhg5g000bu8q5cuzixnqx","_id":"cl27vhg5o000lu8q5l1w1ldka"},{"post_id":"cl27vhg550003u8q559ywynem","tag_id":"cl27vhg5l000fu8q51qscytai","_id":"cl27vhg5q000ou8q5los7l6l1"},{"post_id":"cl27vhg5n000ku8q5jy6vuqlj","tag_id":"cl27vhg590005u8q5y8ci2ybb","_id":"cl27vhg5t000ru8q5mac0i2lp"},{"post_id":"cl27vhg5p000nu8q55obzn2ad","tag_id":"cl27vhg590005u8q5y8ci2ybb","_id":"cl27vhg5v000uu8q5yl9axvk4"},{"post_id":"cl27vhg5q000pu8q5y6it75k7","tag_id":"cl27vhg590005u8q5y8ci2ybb","_id":"cl27vhg5x000xu8q5l4v3798j"},{"post_id":"cl27vhg5a0006u8q5povh1sr9","tag_id":"cl27vhg5o000mu8q5za8aw24a","_id":"cl27vhg620018u8q5zwq47276"},{"post_id":"cl27vhg5a0006u8q5povh1sr9","tag_id":"cl27vhg5u000su8q54oyc2hb4","_id":"cl27vhg630019u8q5rcg3hjon"},{"post_id":"cl27vhg5a0006u8q5povh1sr9","tag_id":"cl27vhg5y0010u8q51d98jhmg","_id":"cl27vhg63001bu8q5tjovmmz8"},{"post_id":"cl27vhg5a0006u8q5povh1sr9","tag_id":"cl27vhg5l000fu8q51qscytai","_id":"cl27vhg63001cu8q5363dofw1"},{"post_id":"cl27vhg5f000au8q595v94p4k","tag_id":"cl27vhg620017u8q5igncyvvk","_id":"cl27vhg64001eu8q5esxzpyl7"},{"post_id":"cl27vhg5f000au8q595v94p4k","tag_id":"cl27vhg63001au8q56nhhz45d","_id":"cl27vhg64001fu8q5uca3st0p"},{"post_id":"cl27vhg5h000du8q5zc0r6odm","tag_id":"cl27vhg590005u8q5y8ci2ybb","_id":"cl27vhg65001iu8q5qo1229qn"},{"post_id":"cl27vhg5h000du8q5zc0r6odm","tag_id":"cl27vhg63001du8q5n615x1y5","_id":"cl27vhg65001ju8q5vwcpgrzy"},{"post_id":"cl27vhg5h000du8q5zc0r6odm","tag_id":"cl27vhg64001gu8q5iv806rvk","_id":"cl27vhg66001lu8q59pbz4vza"},{"post_id":"cl27vhg5k000eu8q5wu3aehgs","tag_id":"cl27vhg590005u8q5y8ci2ybb","_id":"cl27vhg66001nu8q5ozsuchxp"},{"post_id":"cl27vhg5k000eu8q5wu3aehgs","tag_id":"cl27vhg65001hu8q5idt2qn5c","_id":"cl27vhg67001ou8q5o4i24mvr"},{"post_id":"cl27vhg5k000eu8q5wu3aehgs","tag_id":"cl27vhg66001ku8q5u0nnztmm","_id":"cl27vhg67001qu8q5piimcxwr"},{"post_id":"cl27vhg5l000gu8q561a3vu8l","tag_id":"cl27vhg66001mu8q5w28dr3gi","_id":"cl27vhg68001su8q5zs4wnhll"},{"post_id":"cl27vhg5l000gu8q561a3vu8l","tag_id":"cl27vhg67001pu8q56r6wlruc","_id":"cl27vhg68001tu8q5l5plilq7"},{"post_id":"cl27vhg5u000tu8q5xdne0dn9","tag_id":"cl27vhg5l000fu8q51qscytai","_id":"cl27vhg69001vu8q5oiww3lce"},{"post_id":"cl27vhg5u000tu8q5xdne0dn9","tag_id":"cl27vhg67001ru8q5w1z9rmi8","_id":"cl27vhg69001wu8q5pbtig98s"},{"post_id":"cl27vhg5w000vu8q5l2gdrdlv","tag_id":"cl27vhg68001uu8q5b7aqawk1","_id":"cl27vhg6e001zu8q574objyvs"},{"post_id":"cl27vhg5w000vu8q5l2gdrdlv","tag_id":"cl27vhg69001xu8q5c92gxqvl","_id":"cl27vhg6e0020u8q5bpqt1nha"},{"post_id":"cl27vhg5x000yu8q55fulnsnq","tag_id":"cl27vhg6e001yu8q5y81qb2fw","_id":"cl27vhg6f0022u8q5803ydo2z"},{"post_id":"cl27vhg5z0011u8q5xzopyv3f","tag_id":"cl27vhg6f0021u8q5uc8kd8zn","_id":"cl27vhg6g0025u8q55pn1l9wj"},{"post_id":"cl27vhg5z0011u8q5xzopyv3f","tag_id":"cl27vhg620017u8q5igncyvvk","_id":"cl27vhg6g0026u8q5qvtmhxyl"},{"post_id":"cl27vhg600013u8q5eq3xkeli","tag_id":"cl27vhg6g0024u8q5atcot5se","_id":"cl27vhg6i002au8q5xmntd55p"},{"post_id":"cl27vhg600013u8q5eq3xkeli","tag_id":"cl27vhg6h0027u8q5tsf3vc3i","_id":"cl27vhg6i002bu8q5z3ma03bz"},{"post_id":"cl27vhg600013u8q5eq3xkeli","tag_id":"cl27vhg6h0028u8q5ordr5azk","_id":"cl27vhg6i002cu8q5zcxdgk8x"},{"post_id":"cl27vhg600013u8q5eq3xkeli","tag_id":"cl27vhg6h0029u8q5crvm4enq","_id":"cl27vhg6i002du8q522e4x0vm"}],"Tag":[{"name":"工作中遇到的问题","_id":"cl27vhg590005u8q5y8ci2ybb"},{"name":"js基础","_id":"cl27vhg5g000bu8q5cuzixnqx"},{"name":"css","_id":"cl27vhg5l000fu8q51qscytai"},{"name":"BFC","_id":"cl27vhg5o000mu8q5za8aw24a"},{"name":"边距重合","_id":"cl27vhg5u000su8q54oyc2hb4"},{"name":"边距塌陷","_id":"cl27vhg5y0010u8q51d98jhmg"},{"name":"JavaScript深入","_id":"cl27vhg620017u8q5igncyvvk"},{"name":"事件循环","_id":"cl27vhg63001au8q56nhhz45d"},{"name":"js进阶","_id":"cl27vhg63001du8q5n615x1y5"},{"name":"深拷贝","_id":"cl27vhg64001gu8q5iv806rvk"},{"name":"拖拽排序","_id":"cl27vhg65001hu8q5idt2qn5c"},{"name":"uniapp","_id":"cl27vhg66001ku8q5u0nnztmm"},{"name":"前端基础","_id":"cl27vhg66001mu8q5w28dr3gi"},{"name":"浏览器基础","_id":"cl27vhg67001pu8q56r6wlruc"},{"name":"flex弹性布局","_id":"cl27vhg67001ru8q5w1z9rmi8"},{"name":"网络基础","_id":"cl27vhg68001uu8q5b7aqawk1"},{"name":"浏览器缓存","_id":"cl27vhg69001xu8q5c92gxqvl"},{"name":"http","_id":"cl27vhg6e001yu8q5y81qb2fw"},{"name":"JS基础","_id":"cl27vhg6f0021u8q5uc8kd8zn"},{"name":"渲染队列","_id":"cl27vhg6g0024u8q5atcot5se"},{"name":"回流重绘","_id":"cl27vhg6h0027u8q5tsf3vc3i"},{"name":"前端进阶","_id":"cl27vhg6h0028u8q5ordr5azk"},{"name":"项目优化","_id":"cl27vhg6h0029u8q5crvm4enq"}]}}