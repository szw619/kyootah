---
title: 理解浏览器与node的事件循环机制
catalog: true 
date: 2021-10-03 21:33:21
subtitle:
header-img:
tags:
- JavaScript深入
- 事件循环
---
 

 


## 事件循环机制并不是js本身的特性

>在谈事件循环的时候，经常会说请说一说JS的事件循环机制。这常常会让人产生一种误解，事件循环好像是JS语言的特性。实际上并不是，简单来说是宿主环境提供事件循环。


浏览器宿主环境包含JS引擎和渲染引擎。最常见的宿主环境就是浏览器提供的环境。
* JS引擎：运行JavaScript代码。最出名的是Chrome的V8引擎。
* 渲染引擎：对网页进行排版和显示。最出名的是Webkit引擎。

**除了浏览器**，`Node.js`也是一个主要的宿主环境，这个环境就不包含渲染引擎了。它也提供了同浏览器稍有不同的事件循环机制。



## JS是单线程语言
>在浏览器环境中，有JS 引擎线程和渲染线程，且两个线程互斥。
Node环境中，只有JS 线程。


JS是单线程的，一个任务完成之后才能执行另一个任务。 
比如下面这串代码,我们可以思考下输出结果是`setTimeout`的会穿插到`for`之间还是说在最后
```js
for(let i=0;i<2000;i++){
    console.log(1)
} 
setTimeout(()=>{console.log(2)},0);
console.log(3);
```
结果是输出了2000个1之后再输出3,再输出2。

因为JS引擎并不提供事件循环，且关键的一点，JS是单线程语言，所以浏览器**需要有一种机制，让JS能处理异步任务**，于是有了事件循环机制。

## 调用栈 Call Stack
在`JavaScript`运行的时候，主线程会形成一个栈，这个栈主要是解释器用来最终函数执行流的一种机制。通常这个栈被称为`调用栈Call Stack`，或者`执行栈（Execution Context Stack）`。

* 每调用一个函数，解释器就会把该函数的执行上下文添加到调用栈并开始执行；
* 正在调用栈中执行的函数，如果还调用了其他函数，那么新函数也会被添加到调用栈，并立即执行；
* 当前函数执行完毕后，解释器会将其执行上下文清除调用栈，继续执行剩余执行上下文中的剩余代码；
* 但分配的调用栈空间被占满，会引发”堆栈溢出“的报错。  
 
## 任务队列
由于js是单线程的执行方式，这个时候会衍生出一些问题，就是如果当一个语句需要执行很长一段事件的话，比如请求数据、定时器、读取文件等，后面的语句就一定得等到前面的执行语句结束之后才会执行，显而易见，这是不可取的。

所以js将所有执行任务分为了`同步任务`和`异步任务`。

其实我们每个任务都是在做两件事情，就是**发起调用**和**得到结果**。
而同步任务和异步任务最主要的差别就是，同步任务发起调用后，很快就可以得到结果，而异步任务是无法立即得到结果，比如请求接口，每个接口都会有一定的响应时间，根据网速、服务器等等因素决定，再比如定时器，它需要固定时间后才会返回结果。

因此，对于同步任务和异步任务的执行机制也不同。
**同步任务的执行**，就是按照代码顺序和调用循序，进入调用栈中并执行，执行结束后就移除调用栈。
而**异步任务的执行**，首先它依旧会进入调用栈中，并发起调用，然后解析器会**将其响应回调任务**放入一个**任务队列**，接着调用栈会将这个任务一处，当主线程清空后（即所有同步任务结束后）,解析器会读取任务队列，并一次将**已完成的异步任务（事件回调）**加入调用栈中并执行。
**注： 异步任务不是直接进入任务队列的**

### 宏任务微任务

在任务队列中，分为`宏任务队列（Task Queue）`和`微任务队列（Microtask Queue）`，对应的里面存放的就是`宏任务`和`微任务`。

**宏任务:** `Ajax` 、`setTimeout`、`setInterval`、`setImediate`（node）、`requestAnimationFrame`(浏览器)、`读取文件`，这些任务都是宏任务 
**微任务:** `Promise.then/catch/finally` 、`MutaionObserver`（浏览器）、`process.nextTick`（Node.js），这些任务都是微任务

首先，**宏任务和微任务都是异步任务**。


### 任务队列入队
虽说JS是单线程语言，**但是浏览器是多线程的**。对于不同的线程会对不同的事件进行处理，当事件可以执行的时候，就会放入任务队列之中。
* **js引擎线程**：用于解释执行js代码、用户输入、网络请求等；
* **GUI渲染线程**：绘制用户界面，与JS主线程互斥（因为js可以操作DOM，进而会影响到GUI的渲染结果）；
* **http异步网络请求线程**：处理用户的get、post等请求，等返回结果后将回调函数推入到任务队列；
* **定时触发器线程**：setInterval、setTimeout等待时间结束后，会把执行函数推入任务队列中；
* **浏览器事件处理线程**：将click、mouse等UI交互事件发生后，将要执行的回调函数放入到事件队列中。 

我们根据下面代码来理解一下：
```js
setTimeout(()=>{
console.log(1)
},1000)

setTimeout(()=>{
console.log(2)
},100)
```
按照上面结论**当事件可以执行的时候,就会放入任务队列之中**，第二个定时器的事件比第一个事件先执行，即先放入队列之中，所以是先输出的2再是1.

### 执行顺序
1. 同步程序
2. process.nextTick
3. 微任务
4. 宏任务
5. setimmediate

## 事件循环
![](https://img.kyootah.com/2022/03/08/97916a96baef2.png)


从这张图 我们可以得出来一个结论，**同步任务永远先于异步任务执行**。因为执行栈判断出该任务是同步任务，会直接执行，而异步任务会加入到任务队列(一种先进先出的数据结构）后，暂且不会执行。等到执行栈为空后，再看任务队列的首任务有没有事件回调，存在事件回调那就执行，执行完后移出任务队列，依次往复，直到任务队列为空。

我们来通过一个常见的面试题来理解一下事件循环
```js
console.log("a");

setTimeout(function () {
    console.log("b");
}, 0);

new Promise((resolve) => {
    console.log("c");
    resolve();
}).then(function () {
        console.log("d");
}).then(function () {
        console.log("e");
    });

console.log("f");

/**
* 输出结果：a c f d e b
*/
```
我们来解析一下循环步骤：
1. 代码执行，先将**整体代码script**推入宏任务队列中，执行该宏任务。
2. 执行同步代码`console.log("a")`：推入调用栈，执行完成后移出调用栈。
3. 执行`setTimeout()`：由于`setTimeout()`是宏任务，所以进入调用栈中，将它的callback推入宏任务队列后移出调用栈
4. 接下来是`Promise`,先将`Promise`推入调用栈，执行`console.log("c")`...,执行`resolve()`...。（这里...省略调用栈的入栈出栈
5. 接下来是`new Promise().then()`，这是一个微任务，因此推入微任务队列之中`new Promise()`结束，移出调用栈
6. 接下来是`console.log('f')`,执行结束，`script`宏任务就结束了，移出宏任务队列。
7. 接下来就开始清空微任务队列。首先执行的是`new Promise().then()`，推入调用栈，执行并移出调用栈
8. 结束`console.log('d')`后检测还有一个`then`，将其推入微任务队列后将本次then移出微任务队列。
9. 接着再查一遍微任务队列，发现还有一个`then`，因此继续执行下一个`then`,将其推入调用栈，执行并移除，此时微任务队列就清空了，第一个事件循环结束
10. 接下来执行下一个宏任务，`setTimeout callback`,执行结束后，它也被移除宏任务队列和调用栈。
11. 这时候微任务队列里面没有任务，因此第二个事件循环也结束了

总结：
* 从宏任务队列中，按照入队顺序，找到第一个执行的宏任务，放入调用栈，开始执行；
* 执行完该宏任务下所有同步任务后，即调用栈清空后，该宏任务被推出宏任务队列，然后微任务队列开始按照入队顺序，依次执行其中的微任务，直至微任务队列清空为止；
* 当微任务队列清空后，一个事件循环结束；
* 接着从宏任务队列中，找到下一个执行的宏任务，开始第二个事件循环，直至宏任务队列清空为止。

重点： 
* 当我们第一次执行的时候，解释器会将整体代码script放入宏任务队列中，因此事件循环是从第一个宏任务开始的；
* 如果在执行微任务的过程中，产生新的微任务添加到微任务队列中，也需要一起清空；微任务队列没清空之前，是不会执行下一个宏任务的。



## async await
 

 